var representation = require("./restlet-representation.js");
var core = require("./restlet-core.js");
var data = require("./restlet-data.js");

var introspect = require('introspect');
var commons = require("./commons.js");

var AnnotationInfo = new commons.Class({
    initialize: function(resourceClass, restletMethod, javaScriptMethod, value) {
        this.resourceClass = resourceClass;
        this.restletMethod = restletMethod;
        this.javaScriptMethod = javaScriptMethod;

        // Parse the main components of the annotation value
        if ((value != null) && !value.equals("")) {
            var queryIndex = value.indexOf('?');

            if (queryIndex != -1) {
                this.query = value.substring(queryIndex + 1);
                value = value.substring(0, queryIndex);
            } else {
                this.query = null;
            }

            var ioSeparatorIndex = value.indexOf(':');

            if (ioSeparatorIndex != -1) {
                this.input = value.substring(0, ioSeparatorIndex);
                this.output = value.substring(ioSeparatorIndex + 1);
            } else {
                this.input = value;
                this.output = value;
            }

        } else {
            this.query = null;
            this.input = null;
            this.output = null;
        }
    },

    equals: function(other) {
        var result = (other instanceof AnnotationInfo);

        if (result && (other != this)) {
            var otherAnnotation = other;

            // Compare the method
            if (result) {
                result = ((this.getJavaScriptMethod() == null)
                        && (otherAnnotation.getJavaScriptMethod() == null) || (this.getJavaScriptMethod() != null)
                        && this.getJavaScriptMethod().equals(
                                otherAnnotation.getJavaScriptMethod()));
            }

            // Compare the resource interface
            if (result) {
                result = ((getResourceClass() == null)
                        && (otherAnnotation.getResourceClass() == null) || (getResourceClass() != null)
                        && getResourceClass().equals(
                                otherAnnotation.getResourceClass()));
            }

            // Compare the Restlet method
            if (result) {
                result = ((this.getRestletMethod() == null)
                        && (otherAnnotation.getRestletMethod() == null) || (this.getRestletMethod() != null)
                        && this.getRestletMethod().equals(
                                otherAnnotation.getRestletMethod()));
            }

            // Compare the input annotation value
            if (result) {
                result = ((this.getInput() == null)
                        && (otherAnnotation.getInput() == null) || (this.getInput() != null)
                        && this.getInput().equals(otherAnnotation.getInput()));
            }

            // Compare the output annotation value
            if (result) {
                result = ((this.getOutput() == null)
                        && (otherAnnotation.getOutput() == null) || (this.getOutput() != null)
                        && this.getOutput().equals(otherAnnotation.getOutput()));
            }

            // Compare the query annotation value
            if (result) {
                result = ((this.getQuery() == null)
                        && (otherAnnotation.getQuery() == null) || (this.getQuery() != null)
                        && this.getQuery().equals(otherAnnotation.getQuery()));
            }
        }

        return result;
    },

    getInput: function() {
        return this.input;
    },

    getJavaInputTypes: function() {
        var types = introspect(this.getJavaScriptMethod());

        for (var i=0; i<types.length; i++) {
        	types[i] = types[i].toLowerCase();
        }

        return types;
    },

    getJavaScriptMethod: function() {
        return this.javaScriptMethod;
    },

    getOutput: function() {
        return this.output;
    },

    getQuery: function() {
        return this.query;
    },

    getRequestVariants: function(metadataService, converterService) {
        var result = null;
        var types = this.getJavaScriptInputTypes();

        if (types != null && types.length >= 1) {
            result = this.getVariants(metadataService, this.getInput());

            if (result == null) {
                var inputType = types[0];
                if (inputClass != null) {
                    result = converterService.getVariants(
                            inputType, null);
                }
            }
        }

        return result;
    },

    getResourceClass: function() {
        return this.resourceClass;
    },

    getResponseVariants: function(metadataService, converterService) {
        var result = null;
        
        result = this.getVariants(metadataService, this.getOutput());

        /*if ((getJavaOutputType() != null)
                && (getJavaOutputType() != void.class)
                && (getJavaOutputType() != Void.class)) {
            result = getVariants(metadataService, getOutput());

            if (result == null) {
                result = (List<Variant>) converterService.getVariants(
                        getJavaOutputType(), null);
            }
        }*/

        return result;
    },

    getRestletMethod: function() {
        return this.restletMethod;
    },
    
    getValue: function() {
    	return this.value;
    },

    getVariants: function(metadataService, annotationValue) {
        var result = null;

        if (annotationValue != null) {
            var variants = annotationValue.split("\\|");

            for (var i=0; i<variants.length; i++) {
            	var variantValue = variants[i];
                var variant = null;
                var extensions = variantValue.split("\\+");
                var mediaTypes = null;
                var languages = null;
                var characterSet = null;

                for (var j=0; j<extensions.length; j++) {
                	var extension = extensions[j];
                    if (extension != null) {
                        var metadataList = metadataService
                                .getAllMetadata(extension);

                        if (metadataList != null) {
                            for (var k=0; k<metadataList.length; k++) {
                            	var metadata = metadataList[k];
                                if (metadata instanceof data.MediaType) {
                                    if (mediaTypes == null) {
                                        mediaTypes = [];
                                    }

                                    mediaTypes.push(metadata);
                                } else if (metadata instanceof data.Language) {
                                    if (languages == null) {
                                        languages = [];
                                    }

                                    languages.push(metadata);
                                } else if (metadata instanceof data.CharacterSet) {
                                    if (characterSet == null) {
                                        characterSet = metadata;
                                    } else {
                                        core.Context.getCurrentLogger()
                                                .warning(
                                                        "A representation variant can have only one character set. Please check your annotation value.");
                                    }
                                }
                            }
                        }
                    }
                }

                // Now build the representation variants
                if (mediaTypes != null) {
                    for (var j=0; j<mediaTypes.length; j++) {
                    	var mediaType = mediaTypes[j];
                        if ((result == null) || (!result.contains(mediaType))) {
                            if (result == null) {
                                result = [];
                            }

                            variant = new representation.Variant(mediaType);

                            if (languages != null) {
                                variant.getLanguages().addAll(languages);
                            }

                            if (characterSet != null) {
                                variant.setCharacterSet(characterSet);
                            }

                            result.add(variant);
                        }
                    }
                }
            }
        }

        return result;
    },

    isCompatible: function(restletMethod, queryParams, requestEntity, metadataService, converterService) {
        var result = true;

        // Verify query parameters
        if (this.getQuery() != null) {
            var requiredParams = new data.Form(this.getQuery());

            //TODO: migrate...
            for (Iterator<Parameter> iter = requiredParams.iterator(); iter
                    .hasNext() && result;) {
                result = queryParams.contains(iter.next());
            }
        }

        // Verify HTTP method
        if (result) {
            result = this.getRestletMethod().equals(restletMethod);
        }

        // Verify request entity
        if (result) {
            result = this.isCompatibleRequestEntity(requestEntity, metadataService,
                    converterService);

        }

        return result;
    },

    isCompatibleRequestEntity: function(requestEntity, metadataService, converterService) {
        var result = true;

        if ((requestEntity != null) && requestEntity.isAvailable()) {
            var requestVariants = this.getRequestVariants(metadataService,
                    converterService);

            if ((requestVariants != null) && !requestVariants.isEmpty()) {
                // Check that the compatibility
                result = false;

                for (var i = 0; (!result) && (i < requestVariants.length); i++) {
                    result = (requestVariants.get(i)
                            .isCompatible(requestEntity));
                }
            } else {
                result = false;
            }
        }

        return result;
    },

    toString: function() {
        return "AnnotationInfo [resourceInterface: " + this.resourceClass + ", restletMethod: "
                + this.restletMethod + ", input: " + this.getInput() + ", output: "
                + this.getOutput() + ", query: " + this.getQuery() + ", value = "+ this.getValue() +"]";
    }
});

var VariantInfo = new commons.Class(representation.Variant, {
    initialize: function(mediaType, annotationInfo) {
    	var mediaType = arguments[0];
    	if (mediaType instanceof representation.Variant) {
    		var variant = mediaType;
    		mediaType = mediaType.getMediaType();
            this.setCharacterSet(variant.getCharacterSet());
            this.setEncodings(variant.getEncodings());
            this.setLanguages(variant.getLanguages());
    	}
        this.callSuperCstr(mediaType);

        this.annotationInfo = annotationInfo;
        this.inputScore = 1.0;
    },

    equals: function(other) {
        var result = this.callSuper("equals", other) && (other instanceof VariantInfo);

        if (result && (other != this)) {
            var otherVariant = other;

            // Compare the annotation info
            if (result) {
                result = ((this.getAnnotationInfo() == null)
                        && (otherVariant.getAnnotationInfo() == null) || (this.getAnnotationInfo() != null)
                        && this.getAnnotationInfo().equals(
                                otherVariant.getAnnotationInfo()));
            }
        }

        return result;
    },

    getAnnotationInfo: function() {
        return this.annotationInfo;
    },

    getInputScore: function() {
        return this.inputScore;
    },

    setInputScore: function(inputScore) {
        this.inputScore = inputScore;
    },
});

var AnnotationInfo = new commons.Class({
    initialize: function(resourceClass, restletMethod, javaScriptMethod, value) {
        this.resourceClass = resourceClass;
        this.restletMethod = restletMethod;
        this.javaScriptMethod = javaScriptMethod;

        // Parse the main components of the annotation value
        if ((value != null) && !value.equals("")) {
            var queryIndex = value.indexOf('?');

            if (queryIndex != -1) {
                this.query = value.substring(queryIndex + 1);
                value = value.substring(0, queryIndex);
            } else {
                this.query = null;
            }

            var ioSeparatorIndex = value.indexOf(':');

            if (ioSeparatorIndex != -1) {
                this.input = value.substring(0, ioSeparatorIndex);
                this.output = value.substring(ioSeparatorIndex + 1);
            } else {
                this.input = value;
                this.output = value;
            }

        } else {
            this.query = null;
            this.input = null;
            this.output = null;
        }
    },

    equals: function(other) {
        var result = (other instanceof AnnotationInfo);

        if (result && (other != this)) {
            var otherAnnotation = other;

            // Compare the method
            if (result) {
                result = ((this.getJavaScriptMethod() == null)
                        && (otherAnnotation.getJavaScriptMethod() == null) || (this.getJavaScriptMethod() != null)
                        && this.getJavaScriptMethod().equals(
                                otherAnnotation.getJavaScriptMethod()));
            }

            // Compare the resource interface
            if (result) {
                result = ((getResourceClass() == null)
                        && (otherAnnotation.getResourceClass() == null) || (getResourceClass() != null)
                        && getResourceClass().equals(
                                otherAnnotation.getResourceClass()));
            }

            // Compare the Restlet method
            if (result) {
                result = ((this.getRestletMethod() == null)
                        && (otherAnnotation.getRestletMethod() == null) || (this.getRestletMethod() != null)
                        && this.getRestletMethod().equals(
                                otherAnnotation.getRestletMethod()));
            }

            // Compare the input annotation value
            if (result) {
                result = ((this.getInput() == null)
                        && (otherAnnotation.getInput() == null) || (this.getInput() != null)
                        && this.getInput().equals(otherAnnotation.getInput()));
            }

            // Compare the output annotation value
            if (result) {
                result = ((this.getOutput() == null)
                        && (otherAnnotation.getOutput() == null) || (this.getOutput() != null)
                        && this.getOutput().equals(otherAnnotation.getOutput()));
            }

            // Compare the query annotation value
            if (result) {
                result = ((this.getQuery() == null)
                        && (otherAnnotation.getQuery() == null) || (this.getQuery() != null)
                        && this.getQuery().equals(otherAnnotation.getQuery()));
            }
        }

        return result;
    },

    getInput: function() {
        return this.input;
    },

    getJavaInputTypes: function() {
        var types = introspect(this.getJavaScriptMethod());

        for (var i=0; i<types.length; i++) {
        	types[i] = types[i].toLowerCase();
        }

        return types;
    },

    getJavaScriptMethod: function() {
        return this.javaScriptMethod;
    },

    getOutput: function() {
        return this.output;
    },

    getQuery: function() {
        return this.query;
    },

    getRequestVariants: function(metadataService, converterService) {
        var result = null;
        var types = this.getJavaScriptInputTypes();

        if (types != null && types.length >= 1) {
            result = this.getVariants(metadataService, this.getInput());

            if (result == null) {
                var inputType = types[0];
                if (inputClass != null) {
                    result = converterService.getVariants(
                            inputType, null);
                }
            }
        }

        return result;
    },

    getResourceClass: function() {
        return this.resourceClass;
    },

    getResponseVariants: function(metadataService, converterService) {
        var result = null;
        
        result = this.getVariants(metadataService, this.getOutput());

        /*if ((getJavaOutputType() != null)
                && (getJavaOutputType() != void.class)
                && (getJavaOutputType() != Void.class)) {
            result = getVariants(metadataService, getOutput());

            if (result == null) {
                result = (List<Variant>) converterService.getVariants(
                        getJavaOutputType(), null);
            }
        }*/

        return result;
    },

    getRestletMethod: function() {
        return this.restletMethod;
    },
    
    getValue: function() {
    	return this.value;
    },

    getVariants: function(metadataService, annotationValue) {
        var result = null;

        if (annotationValue != null) {
            var variants = annotationValue.split("\\|");

            for (var i=0; i<variants.length; i++) {
            	var variantValue = variants[i];
                var variant = null;
                var extensions = variantValue.split("\\+");
                var mediaTypes = null;
                var languages = null;
                var characterSet = null;

                for (var j=0; j<extensions.length; j++) {
                	var extension = extensions[j];
                    if (extension != null) {
                        var metadataList = metadataService
                                .getAllMetadata(extension);

                        if (metadataList != null) {
                            for (var k=0; k<metadataList.length; k++) {
                            	var metadata = metadataList[k];
                                if (metadata instanceof data.MediaType) {
                                    if (mediaTypes == null) {
                                        mediaTypes = [];
                                    }

                                    mediaTypes.push(metadata);
                                } else if (metadata instanceof data.Language) {
                                    if (languages == null) {
                                        languages = [];
                                    }

                                    languages.push(metadata);
                                } else if (metadata instanceof data.CharacterSet) {
                                    if (characterSet == null) {
                                        characterSet = metadata;
                                    } else {
                                        core.Context.getCurrentLogger()
                                                .warning(
                                                        "A representation variant can have only one character set. Please check your annotation value.");
                                    }
                                }
                            }
                        }
                    }
                }

                // Now build the representation variants
                if (mediaTypes != null) {
                    for (var j=0; j<mediaTypes.length; j++) {
                    	var mediaType = mediaTypes[j];
                        if ((result == null) || (!result.contains(mediaType))) {
                            if (result == null) {
                                result = [];
                            }

                            variant = new representation.Variant(mediaType);

                            if (languages != null) {
                                variant.getLanguages().addAll(languages);
                            }

                            if (characterSet != null) {
                                variant.setCharacterSet(characterSet);
                            }

                            result.add(variant);
                        }
                    }
                }
            }
        }

        return result;
    },

    isCompatible: function(restletMethod, queryParams, requestEntity, metadataService, converterService) {
        var result = true;

        // Verify query parameters
        if (this.getQuery() != null) {
            var requiredParams = new data.Form(this.getQuery());

            //TODO: migrate...
            for (Iterator<Parameter> iter = requiredParams.iterator(); iter
                    .hasNext() && result;) {
                result = queryParams.contains(iter.next());
            }
        }

        // Verify HTTP method
        if (result) {
            result = this.getRestletMethod().equals(restletMethod);
        }

        // Verify request entity
        if (result) {
            result = this.isCompatibleRequestEntity(requestEntity, metadataService,
                    converterService);

        }

        return result;
    },

    isCompatibleRequestEntity: function(requestEntity, metadataService, converterService) {
        var result = true;

        if ((requestEntity != null) && requestEntity.isAvailable()) {
            var requestVariants = this.getRequestVariants(metadataService,
                    converterService);

            if ((requestVariants != null) && !requestVariants.isEmpty()) {
                // Check that the compatibility
                result = false;

                for (var i = 0; (!result) && (i < requestVariants.length); i++) {
                    result = (requestVariants.get(i)
                            .isCompatible(requestEntity));
                }
            } else {
                result = false;
            }
        }

        return result;
    },

    toString: function() {
        return "AnnotationInfo [resourceInterface: " + this.resourceClass + ", restletMethod: "
                + this.restletMethod + ", input: " + this.getInput() + ", output: "
                + this.getOutput() + ", query: " + this.getQuery() + ", value = "+ this.getValue() +"]";
    }
});

var AnnotationUtils = new commons.Class({
	initialize: function() {
	    this.cache = {};
	},

	addAnnotationDescriptors: function(descriptors, resourceClass,
            			initialResourceClass, javaScriptMethod) {
        var result = descriptors;

        // Add the annotation descriptor
        if (result == null) {
            result = [];
        }

        var methodAnnotation = javaScriptMethod.metadata;

        var restletMethod = this.getRestletMethod(methodAnnotation);
        if (restletMethod != null) {
            /*var toString = annotation.toString();
            var startIndex = annotation.annotationType().getCanonicalName()
                    .length() + 8;
            var endIndex = toString.length() - 1;
            var value = null;

            if (endIndex > startIndex) {
                value = toString.substring(startIndex, endIndex);

                if ("".equals(value)) {
                    value = null;
                }
            }*/
        	var value = methodAnnotation.extension;

            result.push(new AnnotationInfo(initialResourceClass, restletMethod,
                    javaScriptMethod, value));

        }

        return result;
    },

    addAnnotations: function(descriptors, clazz, initialClass) {
        var result = descriptors;

        if (clazz != null && ServerResource!=clazz) {
            // Add the annotation descriptor
            if (result == null) {
                result = [];
            }

            // Inspect the current class
            for (var javaScriptMethodName in clazz.prototype) {
            	var javaScriptMethod = clazz.prototype[javaScriptMethodName];
            	if (typeof javaScriptMethod == "function") {
            		this.addAnnotationDescriptors(result, clazz, initialClass, javaScriptMethod);
            	}
            }
        }

        return result;
    },

    clearCache: function() {
        this.cache.clear();
    },

    getAnnotation: function() {
    	if (arguments.length==2) {
    		return this._getAnnotationTwoParams.apply(this, arguments);
    	} else if (arguments.length==6) {
    		return this._getAnnotationFiveParams.apply(this, arguments);
    	}
    },
    
    _getAnnotationTwoParams: function(annotations, javaScriptMethod) {
        if (annotations != null) {
            for (var i=0; i<annotations.length; i++) {
            	var annotationInfo = annotations[i];
                if (annotationInfo.getJavaMethod().equals(javaMethod)) {
                    return annotationInfo;
                }
            }
        }

        return null;
    },

    _getAnnotationFiveParams: function(annotations, restletMethod,
    				query, entity, metadataService, converterService) {
        if (annotations != null) {
            for (var i=0; i<annotations.length; i++) {
            	var annotationInfo = annotations[i];
                if (annotationInfo.isCompatible(restletMethod, query, entity,
                        metadataService, converterService)) {
                    return annotationInfo;
                }
            }
        }

        return null;
    },

    getAnnotations: function(clazz, javaScriptMethod) {
    	if (javaScriptMethod!=null) {
            return this.addAnnotationDescriptors(null, clazz, clazz, javaScriptMethod);
    	} else {
            var result = /*this.cache.get(clazz);*/null;

            if (result == null) {
                // Inspect the class itself for annotations
                result = this.addAnnotations(result, clazz, clazz);

                // Put the list in the cache if no one was previously present
                /*var prev = this.cache.putIfAbsent(clazz, result);

                if (prev != null) {
                    // Reuse the previous entry
                    result = prev;
                }*/
            }

            return result;
    	}
    },

    getRestletMethod: function(methodAnnotation) {
        return methodAnnotation == null ? null
                : data.Method.valueOf(methodAnnotation.method);
    }
});

AnnotationUtils.extend({
    instance: new AnnotationUtils(),
    getInstance: function() {
        return AnnotationUtils.instance;
    }
});



var Resource = new commons.Class({
    doCatch: function(err) {
        this.getLogger().log(core.Level.INFO, "Exception or error caught in resource",
                err);
    },

    /*protected void doError(Status errorStatus) {
    }

    protected final void doError(Status errorStatus, String errorMessage) {
        doError(new Status(errorStatus, errorMessage));
    }*/

    doInit: function() {
    },

    doRelease: function() {
    },

    getAllowedMethods: function() {
        return this.getResponse() == null ? null : this.getResponse().getAllowedMethods();
    },

    getApplication: function() {
        return this.application;
    },

    getChallengeRequests: function() {
        return this.getResponse() == null ? null : this.getResponse()
                .getChallengeRequests();
    },

    getChallengeResponse: function() {
        return this.getRequest() == null ? null : this.getRequest()
                .getChallengeResponse();
    },

    getClientInfo: function() {
        return this.getRequest() == null ? null : this.getRequest().getClientInfo();
    },

    getConditions: function() {
        return this.getRequest() == null ? null : this.getRequest().getConditions();
    },

    getContext: function() {
        return this.context;
    },

    getConnegService: function() {
        var result = null;

        result = this.getApplication().getConnegService();

        if (result == null) {
            result = new core.ConnegService();
        }

        return result;
    },

    getConverterService: function() {
        var result = null;

        result = this.getApplication().getConverterService();

        if (result == null) {
            result = new core.ConverterService();
        }

        return result;
    },

    getCookies: function() {
        return this.getRequest() == null ? null : this.getRequest().getCookies();
    },

    getCookieSettings: function() {
        return this.getResponse() == null ? null : this.getResponse().getCookieSettings();
    },

    getDimensions: function() {
        return this.getResponse() == null ? null : this.getResponse().getDimensions();
    },

    getHostRef: function() {
        return this.getRequest() == null ? null : this.getRequest().getHostRef();
    },

    getLocationRef: function() {
        return this.getResponse() == null ? null : this.getResponse().getLocationRef();
    },

    getLogger: function() {
        return new core.Logger();/*getContext() != null ? getContext().getLogger() : Context
                .getCurrentLogger();*/
    },

    getMatrix: function() {
        return this.getReference() == null ? null : this.getReference().getMatrixAsForm();
    },

    getMaxForwards: function() {
        return this.getRequest() == null ? null : this.getRequest().getMaxForwards();
    },

    getMetadataService: function() {
        var result = null;

        result = this.getApplication().getMetadataService();

        if (result == null) {
            result = new core.MetadataService();
        }

        return result;
    },

    getMethod: function() {
        return this.getRequest() == null ? null : this.getRequest().getMethod();
    },

    getOriginalRef: function() {
        return this.getRequest() == null ? null : this.getRequest().getOriginalRef();
    },

    getProtocol: function() {
        return this.getRequest() == null ? null : this.getRequest().getProtocol();
    },

    getQuery: function() {
        return this.getReference() == null ? null : this.getReference().getQueryAsForm();
    },

    getQueryValue: function(name) {
        var result = null;
        var query = this.getQuery();

        if (query != null) {
            result = query.getFirstValue(name);
        }

        return result;
    },

    getRanges: function() {
        return this.getRequest() == null ? null : this.getRequest().getRanges();
    },

    getReference: function() {
        return this.getRequest() == null ? null : this.getRequest().getResourceRef();
    },

    getReferrerRef: function() {
        return this.getRequest() == null ? null : this.getRequest().getReferrerRef();
    },

    getRequest: function() {
        return this.request;
    },

    getRequestAttributes: function() {
        return this.getRequest() == null ? null : this.getRequest().getAttributes();
    },

    getRequestCacheDirectives: function() {
        return this.getRequest() == null ? null : this.getRequest().getCacheDirectives();
    },

    getRequestEntity: function() {
        return this.getRequest() == null ? null : this.getRequest().getEntity();
    },

    getResponse: function() {
        return this.response;
    },

    getResponseAttributes: function() {
        return this.getResponse() == null ? null : this.getResponse().getAttributes();
    },

    getResponseCacheDirectives: function() {
        return this.getResponse() == null ? null : this.getResponse()
                .getCacheDirectives();
    },

    getResponseEntity: function() {
        return this.getResponse() == null ? null : this.getResponse().getEntity();
    },

    getRootRef: function() {
        return this.getRequest() == null ? null : this.getRequest().getRootRef();
    },

    getServerInfo: function() {
        return this.getResponse() == null ? null : this.getResponse().getServerInfo();
    },

    getStatus: function() {
        return this.getResponse() == null ? null : this.getResponse().getStatus();
    },

    getStatusService: function() {
        var result = null;

        result = this.getApplication().getStatusService();

        if (result == null) {
            result = new core.StatusService();
        }

        return result;
    },

    //public abstract Representation handle();

    init: function(context, request, response) {
        this.context = context;
        this.request = request;
        this.response = response;

        try {
            this.doInit();
        } catch (err) {
        	console.log(err);
        	console.log(err.stack);
            this.doCatch(err);
        }
    },

    isConfidential: function() {
        return this.getRequest() == null ? null : this.getRequest().isConfidential();
    },

    isLoggable: function() {
        return this.getRequest() == null ? null : this.getRequest().isLoggable();
    },

    release: function() {
        try {
            this.doRelease();
        } catch (err) {
            this.doCatch(err);
        }
    },

    setApplication: function(application) {
        this.application = application;
    },

    setRequest: function(request) {
        this.request = request;
    },

    setResponse: function(response) {
        this.response = response;
    },

    toObject: function(source/*, target*/) {
        var result = null;

        if (source != null) {
            try {
                var cs = this.getConverterService();
                result = cs.toObject(source/*, target*/, this);
            } catch (err) {
                throw new Error(err.message);
            }
        }

        return result;
    },

    toRepresentation: function(source, target) {
        var result = null;

        if (source != null) {
        	if (source instanceof representation.Representation) {
                result = source;
        	} else {
        		var cs = this.getConverterService();
        		result = cs.toRepresentation(source, target, this);
        	}
        }

        return result;
    },

    toString: function() {
        return (this.getRequest() == null ? "" : this.getRequest().toString())
                + (this.getResponse() == null ? "" : " => "
                        + this.getResponse().toString());
    }
});


var UniformResource = new commons.Class(Resource, {
});

var ServerResource = new commons.Class(UniformResource, {
    initialize: function() {
        this.annotated = true;
        this.conditional = true;
        this.existing = true;
        this.negotiated = true;
        this.variants = null;
    },

    abort: function() {
        this.getResponse().abort();
    },

	commit: function(obj, variant) {
		this.postHandleProcessing(obj);
		if (obj!=null) {
			if (obj instanceof representation.Representation) {
				this.getResponse().commit(obj);
			} else if (variant!=null) {
				this.getResponse().commit(this.toRepresentation(obj, variant));
			} else {
				throw new Error("A representation must be returned.");
			}
		}
	},

    delete: function() {
        var annotationInfo = null;
        var variant = null;
        if (arguments.length==0) {
        	annotationInfo = getAnnotation(data.Method.DELETE);
        } else if (arguments.length==1) {
        	variant = arguments[0];
        	if (variant instanceof VariantInfo) {
        		annotationInfo = variant.getAnnotationInfo();
        	}
        }

        if (annotationInfo != null) {
            this.doHandle(annotationInfo, variant);
        } else {
            this.doError(data.Status.CLIENT_ERROR_METHOD_NOT_ALLOWED);
        }
    },

    describeVariants: function() {
        var result = null;

        // The list of all variants is transmitted to the client
        // final ReferenceList refs = new ReferenceList(variants.size());
        // for (final Variant variant : variants) {
        // if (variant.getIdentifier() != null) {
        // refs.add(variant.getIdentifier());
        // }
        // }
        //
        // result = refs.getTextRepresentation();
        return result;
    },

    doCatch: function(err) {
        var level = core.Level.INFoNeO;
        try {
        } catch(err) {
        	console.log(err.stack);
        }
        var status = this.getStatusService().getStatus(err, this);

        if (status.isServerError()) {
            level = core.Level.WARNING;
        } else if (status.isConnectorError()) {
            level = core.Level.INFO;
        } else if (status.isClientError()) {
            level = core.Level.FINE;
        }

        this.getLogger().log(level, "Error caught in server resource",
                err);

        if (this.getResponse() != null) {
        	this.getResponse().setStatus(status);
        }

        this.commit();
    },

    doConditionalHandle: function() {
        var result = null;

        if (this.getConditions().hasSome()) {
            var resultInfo = null;

            if (this.existing) {
                if (this.isNegotiated()) {
                    preferredVariant = this.getPreferredVariant(this.getVariants(data.Method.GET));

                    if (preferredVariant == null
                            && this.getConnegService().isStrict()) {
                    	this.doError(data.Status.CLIENT_ERROR_NOT_ACCEPTABLE);
                    } else {
                        resultInfo = this.doGetInfo(preferredVariant);
                    }
                } else {
                    resultInfo = this.doGetInfo();
                }

                if (resultInfo == null) {
                    if ((this.getStatus() == null)
                            || (this.getStatus().isSuccess() && !data.Status.SUCCESS_NO_CONTENT
                                    .equals(this.getStatus()))) {
                    	this.doError(data.Status.CLIENT_ERROR_NOT_FOUND);
                    } else {
                        // Keep the current status as the developer might prefer
                        // a special status like 'method not authorized'.
                    }
                } else {
                    var status = this.getConditions().getStatus(this.getMethod(),
                            resultInfo);

                    if (status != null) {
                        if (status.isError()) {
                        	this.doError(status);
                        } else {
                        	this.setStatus(status);
                        }
                    }
                }
            } else {
                var status = this.getConditions().getStatus(this.getMethod(),
                        resultInfo);

                if (status != null) {
                    if (status.isError()) {
                    	this.doError(status);
                    } else {
                    	this.setStatus(status);
                    }
                }
            }

            if ((data.Method.GET.equals(getMethod()) || data.Method.HEAD
                    .equals(this.getMethod()))
                    && resultInfo instanceof representation.Representation) {
                result = resultInfo;
            } else if ((this.getStatus() != null) && this.getStatus().isSuccess()) {
                // Conditions were passed successfully, continue the normal
                // processing.
                if (this.isNegotiated()) {
                    // Reset the list of variants, as the method differs.
                	this.getVariants().clear();
                    result = this.doNegotiatedHandle();
                } else {
                    result = this.doHandle();
                }
            }
        } else {
            if (this.isNegotiated()) {
                result = this.doNegotiatedHandle();
            } else {
                result = this.doHandle();
            }
        }

        return result;
    },

    doError: function(errorStatus) {
        this.setStatus(errorStatus);
        this.commit();
    },

    doGetInfo: function(variant) {
        if (variant != null) {
            if (variant instanceof VariantInfo) {
                doHandle(variant.getAnnotationInfo(),
                        variant);
            } else if (variant instanceof RepresentationInfo) {
            	//TODO :asynchronous
                result = variant;
            } else {
                getInfo(variant);
            }
        } else {
            var annotationInfo = this.getAnnotation(data.Method.GET);

            if (annotationInfo != null) {
                this.doHandle(annotationInfo, null);
            } else {
                this.getInfo();
            }
        }

        return result;
    },

    doHandle: function() {
    	if (arguments.length==0) {
    		this._doHandleNoParam.apply(this, arguments);
    	} else if (arguments.length==1) {
    		this._doHandleOneParam.apply(this, arguments);
    	} else if (arguments.length==2) {
    		this._doHandleTwoParams.apply(this, arguments);
    	} else if (arguments.length==3) {
    		this._doHandleThreeParams.apply(this, arguments);
    	}
    },

    _doHandleNoParam: function() {
        var method = this.getMethod();

        if (method == null) {
            this.setStatus(data.Status.CLIENT_ERROR_BAD_REQUEST, "No method specified");
        } else {
        	var currentThis = this;
            if (method.equals(data.Method.PUT)) {
                this.put(this.getRequestEntity());
            } else if (this.isExisting()) {
                if (method.equals(data.Method.GET)) {
                    this.get();
                } else if (method.equals(data.Method.POST)) {
                    this.post(this.getRequestEntity());
                } else if (method.equals(data.Method.DELETE)) {
                    this.delete();
                } else if (method.equals(data.Method.HEAD)) {
                    this.head();
                } else if (method.equals(data.Method.OPTIONS)) {
                    this.options();
                } else {
                    this.doHandle(method, this.getQuery(), this.getRequestEntity());
                }
            } else {
            	this.doError(data.Status.CLIENT_ERROR_NOT_FOUND);
            }
        }
    },

    _doHandleTwoParams: function(annotationInfo, variant) {
        var result = null;
        var parameterNames = introspect(annotationInfo.getJavaScriptMethod());

    	var currentThis = this;

        // Invoke the annotated method and get the resulting object.
        var resultObject = null;
        try {
            if (parameterNames.length > 0) {
                var parameters = [];
                var parameter = null;

                for (var i=0; i<parameterNames.length; i++) {
                	var parameterName = parameterNames[i];
                    if (parameterName=="variant") {
                        parameters.add(variant);
                    } else if (parameterName=="representation") {
                        if (this.getRequestEntity() != null
                                && this.getRequestEntity().isAvailable()
                                && this.getRequestEntity().getSize() != 0) {
                            parameters.push(this.getRequestEntity());
                        }
                    } else {
                        if (this.getRequestEntity() != null
                                && this.getRequestEntity().isAvailable()
                                && this.getRequestEntity().getSize() != 0) {
                            // Assume there is content to be read.
                            // NB: it does not handle the case where the size is
                            // unknown, but there is no content.
                            parameter = this.toObject(this.getRequestEntity(),
                                    parameterType);

                            if (parameter == null) {
                                throw new Err(
                                        data.Status.CLIENT_ERROR_UNSUPPORTED_MEDIA_TYPE);
                            }
                        } else {
                            parameter = null;
                        }

                        parameters.push(parameter);
                    }
                }

                resultObject = annotationInfo.getJavaScriptMethod().call(this,
                        parameters);
            } else {
                resultObject = annotationInfo.getJavaScriptMethod().apply(this, commit);
            }
        } catch (err) {
        	console.log(err.stack);
            throw new Error(err);
        }
    },

    _doHandleThreeParams: function(method, query, entity) {
        var result = null;

        if (this.getAnnotation(method) != null) {
            // We know the method is supported, let's check the entity.
            var annotationInfo = this.getAnnotation(method, query, entity);

            if (annotationInfo != null) {
                this.doHandle(annotationInfo, null);
            } else {
                // The request entity is not supported.
                this.doError(Status.CLIENT_ERROR_UNSUPPORTED_MEDIA_TYPE);
            }
        } else {
        	this.doError(Status.CLIENT_ERROR_METHOD_NOT_ALLOWED);
        }
    },

    _doHandleOneParam: function(variant, end) {
        var result = null;
        var method = this.getMethod();

        if (method == null) {
            this.setStatus(data.Status.CLIENT_ERROR_BAD_REQUEST, "No method specified");
        } else {
            if (method.equals(data.Method.PUT)) {
                result = this.put(this.getRequestEntity(), variant);
            } else if (this.isExisting()) {
                if (method.equals(data.Method.GET)) {
                    if (variant instanceof representation.Representation) {
                        variant;
                    } else {
                        this.get(variant);
                    }
                } else if (method.equals(data.Method.POST)) {
                    this.post(this.getRequestEntity(), variant);
                } else if (method.equals(data.Method.DELETE)) {
                    this.delete(variant);
                } else if (method.equals(data.Method.HEAD)) {
                    if (variant instanceof representation.Representation) {
                        this.commit(variant);
                    } else {
                        result = this.head(variant);
                    }
                } else if (method.equals(data.Method.OPTIONS)) {
                    if (variant instanceof representation.Representation) {
                        this.commit(variant);
                    } else {
                        this.options(variant);
                    }
                } else if (variant instanceof VariantInfo) {
                    doHandle(variant.getAnnotationInfo(), variant);
                } else {
                	this.doError(data.Status.CLIENT_ERROR_METHOD_NOT_ALLOWED);
                }
            } else {
            	this.doError(Status.CLIENT_ERROR_NOT_FOUND);
            }
        }
    },

    doNegotiatedHandle: function() {
        var result = null;

        if ((this.getVariants() != null) && (!this.getVariants().isEmpty())) {
            var preferredVariant = this.getPreferredVariant(this.getVariants());

            if (preferredVariant == null) {
                this.response.setEntity(this.describeVariants());

                // No variant was found matching the client preferences
            	this.doError(data.Status.CLIENT_ERROR_NOT_ACCEPTABLE);
            } else {
                // Update the variant dimensions used for content negotiation
            	this.updateDimensions();
                this.doHandle(preferredVariant);
            }
        } else {
            // No variant declared for this method.
            this.doHandle();
        }

        return result;
    },

    get: function() {
        var annotationInfo = null;
        var variant = null;
        if (arguments.length==0) {
        	annotationInfo = this.getAnnotation(data.Method.GET);
        } else if (arguments.length==1) {
        	variant = arguments[0];
        	if (variant instanceof VariantInfo) {
        		annotationInfo = variant.getAnnotationInfo();
        	}
        }

        if (annotationInfo != null) {
            this.doHandle(annotationInfo, variant);
        } else {
            this.doError(data.Status.CLIENT_ERROR_METHOD_NOT_ALLOWED);
        }
    },

    getAnnotation: function(method, query, entity) {
    	if (query==null) {
    		query = this.getQuery();
    	}
        if (this.isAnnotated()) {
            return AnnotationUtils.getInstance().getAnnotation(
                    this.getAnnotations(), method, query, entity,
                    this.getMetadataService(), this.getConverterService());
        }

        return null;
    },

    getAnnotations: function() {
    	/*console.log("getAnnotations - annotations = "+AnnotationUtils.getInstance().getAnnotations(
                this.getClass()));*/
        return this.isAnnotated() ? AnnotationUtils.getInstance().getAnnotations(
                this.getClass()) : null;
    },

    getAttribute: function(name) {
        var value = this.getResponseAttributes().get(name);
        return (value == null) ? null : value.toString();
    },

    getInfo: function() {
   		this.get.call(this, arguments);
    },

    /*getOnSent: function() {
        return this.getResponse().getOnSent();
    },*/

    getPreferredVariant: function(variants) {
        var result = null;

        // If variants were found, select the best matching one
        if ((variants != null) && (!variants.isEmpty())) {
            result = this.getConnegService().getPreferredVariant(variants,
                    this.getRequest(), this.getMetadataService());
        }

        return result;
    },

    getVariants: function() {
    	var method = null;
    	if (arguments.length==0) {
    		method = this.getMethod();
    	} else {
    		method = arguments[0];
    	}

        var result = this.variants;

        if (result == null) {
            result = [];

            // Add annotation-based variants in priority
            if (this.isAnnotated() && this.hasAnnotations()) {
                var annoVariants = null;
                method = (data.Method.HEAD.equals(method)) ? data.Method.GET : method;

                var annotations = this.getAnnotations();
                for (var i=0; i<annotations.length; i++) {
                	var annotationInfo = annotations[i];
                    if (annotationInfo.isCompatible(method, this.getQuery(),
                    		this.getRequestEntity(), this.getMetadataService(),
                    		this.getConverterService())) {
                        annoVariants = annotationInfo.getResponseVariants(
                        		this.getMetadataService(), this.getConverterService());

                        if (annoVariants != null) {
                            // Compute an affinity score between this annotation
                            // and the input entity.
                            var score = 0.5;
                            if ((this.getRequest().getEntity() != null)
                                    && this.getRequest().getEntity().isAvailable()) {
                                var emt = this.getRequest().getEntity()
                                        .getMediaType();
                                var amts = this.getMetadataService()
                                        .getAllMediaTypes(
                                                annotationInfo.getInput());
                                if (amts != null) {
                                    for (var j=0; j<amts.length; j++) {
                                    	var amt = amts[j];
                                        if (amt.equals(emt)) {
                                            score = 1.0;
                                        } else if (amt.includes(emt)) {
                                            score = Math.max(0.8, score);
                                        } else if (amt.isCompatible(emt)) {
                                            score = Math.max(0.6, score);
                                        }
                                    }
                                }
                            }

                            for (var j=0; j<annoVariants.length; j++) {
                            	var v = annoVariants[j];
                                var vi = new VariantInfo(v,
                                        annotationInfo);
                                vi.setInputScore(score);
                                result.push(vi);
                            }
                        }
                        //var vi = new VariantInfo(null/*v*/,
                        //        annotationInfo);
                        //vi.setInputScore(1.0/*score*/);
                        //result.push(vi);
                    }
                }
            }

            this.variants = result;
        }

        return result;
    },

    postHandleProcessing: function(result) {
        if (result!=null && !this.getResponse().isEntityAvailable()) {
        	// If the user manually set the entity, keep it
        	this.getResponse().setEntity(result);
        }

        if (data.Status.CLIENT_ERROR_METHOD_NOT_ALLOWED.equals(this.getStatus())) {
        	this.updateAllowedMethods();
        } else if (data.Method.GET.equals(this.getMethod())
        		&& data.Status.SUCCESS_OK.equals(this.getStatus())
        		&& (this.getResponseEntity() == null || !this.getResponseEntity()
        				.isAvailable())) {
        	this.getLogger()
                .fine("A response with a 200 (Ok) status should have an entity. Changing the status to 204 (No content).");
        	this.setStatus(data.Status.SUCCESS_NO_CONTENT);
        }
    },
    
    handle: function() {
        // If the resource is not available after initialization and if this a
        // retrieval method, then return a "not found" response.
        if (!this.isExisting() && this.getMethod().isSafe()) {
            this.doError(data.Status.CLIENT_ERROR_NOT_FOUND);
        } else {
            try {
                if (this.isConditional()) {
                    this.doConditionalHandle();
                } else if (this.isNegotiated()) {
                    this.doNegotiatedHandle();
                } else {
                    this.doHandle();
                }
            } catch (err) {
            	this.doCatch(err);
            }
        }
    },

    hasAnnotations: function() {
        return (this.getAnnotations() != null) && (!this.getAnnotations().isEmpty());
    },

    head: function() {
    	if (arguments.length==0) {
    		this.get();
    	} else if (arguments.length==1) {
    		var variant = arguments[0];
            this.get(variant);
    	}
    },

    isAnnotated: function() {
        return this.annotated;
    },

    isAutoCommitting: function() {
        return this.getResponse().isAutoCommitting();
    },

    isCommitted: function() {
        return this.getResponse().isCommitted();
    },

    isConditional: function() {
        return this.conditional;
    },

    isExisting: function() {
        return this.existing;
    },

    isInRole: function(roleName) {
        return this.getClientInfo().getRoles().contains(
        		this.getApplication().getRole(roleName));
    },

    isNegotiated: function() {
        return this.negotiated;
    },

    options: function() {
        var annotationInfo = null;
        var variant = null;
        if (arguments.length==0) {
        	annotationInfo = getAnnotation(data.Method.OPTIONS);
        } else if (arguments.length==1) {
        	variant = arguments[0];
        	if (variant instanceof VariantInfo) {
        		annotationInfo = variant.getAnnotationInfo();
        	}
        }

        // Updates the list of allowed methods
        this.updateAllowedMethods();

        if (annotationInfo != null) {
            this.doHandle(annotationInfo, variant);
        } else {
        	this.doError(data.Status.CLIENT_ERROR_METHOD_NOT_ALLOWED);
        }
    },

    post: function(entity, variant) {
        if (variant==null) {
            this.doHandle(data.Method.POST, this.getQuery(), entity);
        } else {
        	if (variant instanceof VariantInfo) {
        		this.doHandle(variant.getAnnotationInfo(),
        				variant);
        	} else {
        		this.doError(data.Status.CLIENT_ERROR_METHOD_NOT_ALLOWED);
        	}
        }
    },

    put: function(representation, variant) {
        if (variant==null) {
            this.doHandle(data.Method.PUT, this.getQuery(), entity);
        } else {
        	if (variant instanceof VariantInfo) {
        		this.doHandle(variant.getAnnotationInfo(),
        				variant);
        	} else {
        		this.doError(data.Status.CLIENT_ERROR_METHOD_NOT_ALLOWED);
        	}
        }
    },

    redirectPermanent: function(target) {
        if (this.getResponse() != null) {
        	this.getResponse().redirectPermanent(target);
        }
    },

    redirectSeeOther: function(target) {
        if (this.getResponse() != null) {
        	this.getResponse().redirectSeeOther(target);
        }
    },

    redirectTemporary: function(target) {
        if (this.getResponse() != null) {
        	this.getResponse().redirectTemporary(target);
        }
    },

    setAllowedMethods: function(allowedMethods) {
        if (this.getResponse() != null) {
        	this.getResponse().setAllowedMethods(allowedMethods);
        }
    },

    setAnnotated: function(annotated) {
        this.annotated = annotated;
    },

    setAttribute: function(name, value) {
    	this.getResponseAttributes()[name] = value;
    },

    setAutoCommitting: function(autoCommitting) {
    	this.getResponse().setAutoCommitting(autoCommitting);
    },

    setChallengeRequests: function(requests) {
        if (this.getResponse() != null) {
        	this.getResponse().setChallengeRequests(requests);
        }
    },

    setCommitted: function(committed) {
    	this.getResponse().setCommitted(committed);
    },

    setConditional: function(conditional) {
        this.conditional = conditional;
    },

    setCookieSettings: function(cookieSettings) {
        if (this.getResponse() != null) {
        	this.getResponse().setCookieSettings(cookieSettings);
        }
    },

    setDimensions: function(dimensions) {
        if (this.getResponse() != null) {
        	this.getResponse().setDimensions(dimensions);
        }
    },

    setExisting: function(exists) {
        this.existing = exists;
    },

    setLocationRef: function(location) {
        if (this.getResponse() != null) {
            this.getResponse().setLocationRef(location);
        }
    },

    setNegotiated: function(negotiateContent) {
        this.negotiated = negotiateContent;
    },

    setOnSent: function(onSentCallback) {
    	this.getResponse().setOnSent(onSentCallback);
    },

    setProxyChallengeRequests: function(requests) {
        if (this.getResponse() != null) {
        	this.getResponse().setProxyChallengeRequests(requests);
        }
    },

    setServerInfo: function(serverInfo) {
        if (this.getResponse() != null) {
        	this.getResponse().setServerInfo(serverInfo);
        }
    },

    setStatus: function() {
        if (this.getResponse() != null) {
            this.getResponse().setStatus.apply(this.getResponse(), arguments);
        }
    },

    updateAllowedMethods: function() {
        this.getAllowedMethods().clear();
        var annotations = this.getAnnotations();

        if (annotations != null) {
            for (var i=0; i<annotations.length;i++) {
            	var annotationInfo = annotations[i];
                if (!this.getAllowedMethods().contains(
                        annotationInfo.getRestletMethod())) {
                    this.getAllowedMethods().add(annotationInfo.getRestletMethod());
                }
            }
        }
    },

    updateDimensions: function() {
        this.getDimensions().add(data.Dimension.CHARACTER_SET);
        this.getDimensions().add(data.Dimension.ENCODING);
        this.getDimensions().add(data.Dimension.LANGUAGE);
        this.getDimensions().add(data.Dimension.MEDIA_TYPE);
    }
});

ServerResource.extend({
	createSubServerResource: function() {
		var subServerResource = new commons.Class(ServerResource, {
			initialize: function() {
				this.callSuperCstr();
			}
		});
		subServerResource._getInternalMethodName = function(method) {
	    	var prefix = "handle"+method.toLowerCase().firstUpper();
	    	var index = 0;
	    	for (var elt in this.prototype) {
	    		if (typeof this.prototype[elt] == "function" && elt.startsWith(prefix)) {
	    			var methodIndex = parseInt(elt.replace(prefix, ""));
	    			if (methodIndex>=index) {
	    				index = methodIndex +1;
	    			}
	    		}
	    	}
	    	return prefix+index;
	    };
		subServerResource.addMethod = function(method, parameters, fn) {
	    	if (typeof method == "string") {
	    		method = data.Method.valueOf(method.toUpperCase());
	    	}
	    	if (typeof parameters == "string") {
	    		parameters = { extension: parameters };
	    	}
	    	parameters["method"] = method;
	    	fn["metadata"] = parameters;
	    	this.prototype[this._getInternalMethodName(method.getName())] = fn;
	    };
	    return subServerResource;
	}
});

var ClientResource = new commons.Class(UniformResource, {
	initialize: function(url) {
		this.request = new core.Request(null, url);
	},
    addQueryParameter: function() {
        return this.getReference().addQueryParameter.apply(this.getReference(), arguments);
    },
	getRequestAttributes: function() {
		if (this.request!=null) {
			return this.request.getAttributes();
		} else {
			return null;
		}
	},
	getResponse: function() {
		return this.response;
	},
	setResponse: function(response) {
		this.response = response;
	},
	getResponseAttributes: function() {
		if (this.response!=null) {
			return this.response.getAttributes();
		} else {
			return null;
		}
	},
	createClientInfo: function(mediaType) {
		var clientInfo = null;
		if (mediaType!=null) {
			clientInfo = new data.ClientInfo(mediaType);
		} else {
			clientInfo = new data.ClientInfo();
		}
		return clientInfo;
	},
	"get": function(callback, mediaType) {
		var clientInfo = this.createClientInfo(mediaType);
		this.handle(data.Method.GET, null, clientInfo, callback);
	},
	"post": function(representation, callback, mediaType) {
		var clientInfo = this.createClientInfo(mediaType);
		this.handle(data.Method.POST, representation, clientInfo, callback);
	},
	"put": function(representation, callback, mediaType) {
		var clientInfo = this.createClientInfo(mediaType);
		this.handle(data.Method.PUT, representation, clientInfo, callback);
	},
	"delete": function(callback, mediaType) {
		var clientInfo = this.createClientInfo(mediaType);
		this.handle(data.Method.DELETE, null, clientInfo, callback);
	},
	createRequest: function() {
		return this.request;
	},
	createResponse: function(request) {
		return new core.Response(request);
	},
	getNext: function() {
		var result = this.next;

		if (result == null) {
            result = this.createNext();

            if (result != null) {
                this.setNext(result);
                this.nextCreated = true;
            }
        }
		return result;
	},
	setNext: function(next) {
		this.next = next;
	},
	createNext: function() {
        /*var result = null;

        if ((result == null) && (this.getContext() != null)) {
            // Try using directly the client dispatcher
            result = this.getContext().getClientDispatcher();
        }

        if (result == null) {
            var rProtocol = this.getProtocol();
            var rReference = this.getReference();
            var protocol = (rProtocol != null) ? rProtocol
                    : (rReference != null) ? rReference.getSchemeProtocol()
                            : null;

            if (protocol != null) {
                result = new Client(protocol);
            }
        }

        return result;*/
		return new core.Client(new core.Context(),/*protocol*/[data.Protocol.HTTP]);
	},
	handle: function(method, entity, clientInfo, callback) {
        var request = this.createRequest(this.getRequest());
        request.setMethod(method);
        request.setEntity(entity);
        request.setClientInfo(clientInfo);

        this.handleRequest(request, callback);
	},
	handleRequest: function(request, callback) {
        //var response = this.createResponse(request);
        var next = this.getNext();

        if (next != null) {
            // Effectively handle the call
        	this.handleNext(request, callback, next);
        } else {
        	//console
            /*getLogger()
                    .warning(
                            "Unable to process the call for a client resource. No next Restlet has been provided.");*/
        }
	},
	handleNext: function(request, callback, next) {
		var currentThis = this;
		next.handle(request, function(response) {
			currentThis.setResponse(response);
			callback(response.getEntity());
		});
	}
});

module.exports = {
	VariantInfo: VariantInfo,
	Resource: Resource,
	UniformResource: UniformResource,
	ServerResource: ServerResource,
	ClientResource: ClientResource
};