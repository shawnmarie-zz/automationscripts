var commons = require("./commons.js");
var http = require("http");
var iconv = require("iconv-lite");

module.exports = {};

//Utils entities

var CharacterEntity = new commons.Class({
	initialize: function(numericValue, name) {
		this.numericValue = numericValue;
		this.name = name;
	},

	getName: function() {
		return this.name;
	},

	getNumericValue: function() {
		return this.numericValue;
	}
});

var CharacterEntitySolver = new commons.Class({
	initialize: function() {
		this.toName = new Array(10000);
		this.toValue = {};
	},

	add: function(value, name) {
		this.toName[value] = name;
		this.toValue[name] = value;
	},

	getName: function(value) {
		return this.toName[value];
	},

	getValue: function(name) {
		return this.toValue[name];
	}
});

var StringUtils = new commons.Class();
StringUtils.extend({
    getAsciiBytes: function(string) {
        if (string != null) {
            try {
                var buf = iconv.encode(string, "US-ASCII");
                return buf.toString();
            } catch (err) {
            	console.log(err.stack);
                // Should not happen.
                return null;
            }
        }
        return null;
    },

    getLatin1Bytes: function(string) {
        if (string != null) {
            try {
                var buf = iconv.encode(string, "ISO-8859-1");
                return buf.toString();
            } catch (err) {
            	console.log(err.stack);
                // Should not happen.
                return null;
            }
        }
        return null;
    },

    htmlEscape: function(str) {
        if (str == null) {
            return null;
        }
        var len = str.length;
        var sb = new commons.StringBuilder(/*len * 1.5*/);
        for (var i = 0; i < len; i++) {
            var cCode = str.charCodeAt(i);
            var c = str.charAt(i);
            var entityName = StringUtils.html40Entities.getName(cCode);
            if (entityName == null) {
                if (cCode > 127) {
                    // Escape non ASCII characters.
                    sb.append("&#").append(cCode.toString(10)).append(';');
                } else {
                    // ASCII characters are not escaped.
                    sb.append(c);
                }
            } else {
                sb.append('&').append(entityName).append(';');
            }
        }
        return sb.toString();
    },

    htmlUnescape: function(str) {
        if (str == null) {
            return null;
        }
        var len = str.length;
        var sb = new commons.StringBuilder(len);
        for (var i = 0; i < len; i++) {
            var c = str.charAt(i);
            if (c == '&') {
                var nextIndex = i + 1;
                var semicolonIndex = -1;
                var ampersandIndex = -1;
                var stop = false;
                for (var j = nextIndex; !stop && j < len; j++) {
                	var ch = str.charAt(j);
                    if (';' == ch) {
                        semicolonIndex = j;
                        stop = true;
                    } else if ('&' == ch) {
                        ampersandIndex = j;
                        stop = true;
                    }
                }
                if (semicolonIndex != -1) {
                    // Entity found
                    if (nextIndex != semicolonIndex) {
                    	var entityValue = -1;
                    	var entityName = str.substring(nextIndex,
                                semicolonIndex);
                        if (entityName.charAt(0) == '#') {
                            // Numeric value
                            if (entityName.length > 1) {
                            	var hexChar = entityName.charAt(1);
                                try {
                                    if (hexChar == 'X') {
                                        entityValue = parseInt(
                                                entityName.substring(2), 16);
                                    } else if (hexChar == 'x') {
                                        entityValue = parseInt(
                                                entityName.substring(2), 16);
                                    } else {
                                        entityValue = parseInt(
                                                entityName.substring(1), 10);
                                    }
                                    if(!Character.isValidCodePoint(entityValue)){
                                        // Invalid Unicode character
                                        entityValue = -1;
                                    }
                                } catch (err) {
                                    entityValue = -1;
                                }
                            }
                        } else {
                            var val = StringUtils.html40Entities.getValue(entityName);
                            if (val != null) {
                                entityValue = val.intValue();
                            }
                        }
                        if (entityValue == -1) {
                            sb.append('&').append(entityName).append(';');
                        } else {
                            sb.append(entityValue);
                        }
                    } else {
                        sb.append("&;");
                    }
                    i = semicolonIndex;
                } else if (stop) {
                    // found a "&" character
                    sb.append(str, i, ampersandIndex).append('&');
                    i = ampersandIndex;
                } else {
                    // End of the string reached, no more entities to parse.
                    sb.append(str, i, len);
                    i = len;
                }
            } else {
                sb.append(c);
            }
        }
        return sb.toString();
    },

    strip: function(source, delimiter, start, end) {
    	if (start==null) {
    		start = true;
    	}
    	if (end==null) {
    		end = true;
    	}
        var beginIndex = 0;
        var endIndex = source.length;
        var stripping = true;

        // Strip beginning
        while (stripping && (beginIndex < endIndex)) {
            if (source.charAt(beginIndex) == delimiter) {
                beginIndex++;
            } else {
                stripping = false;
            }
        }

        // Strip end
        stripping = true;
        while (stripping && (beginIndex < endIndex - 1)) {
            if (source.charAt(endIndex - 1) == delimiter) {
                endIndex--;
            } else {
                stripping = false;
            }
        }

        return source.substring(beginIndex, endIndex);
    }
});

(function() {
	StringUtils.xml10 = [];
	StringUtils.xml10.push(new CharacterEntity(34, "quot"));
	StringUtils.xml10.push(new CharacterEntity(38, "amp"));
	StringUtils.xml10.push(new CharacterEntity(62, "gt"));
	StringUtils.xml10.push(new CharacterEntity(60, "lt"));
	StringUtils.htmlLat1 = [];
	StringUtils.htmlLat1.push(new CharacterEntity(160, "nbsp"));
	StringUtils.htmlLat1.push(new CharacterEntity(161, "iexcl"));
	StringUtils.htmlLat1.push(new CharacterEntity(162, "cent"));
	StringUtils.htmlLat1.push(new CharacterEntity(163, "pound"));
	StringUtils.htmlLat1.push(new CharacterEntity(164, "curren"));
	StringUtils.htmlLat1.push(new CharacterEntity(165, "yen"));
	StringUtils.htmlLat1.push(new CharacterEntity(166, "brvbar"));
	StringUtils.htmlLat1.push(new CharacterEntity(167, "sect"));
	StringUtils.htmlLat1.push(new CharacterEntity(168, "uml"));
	StringUtils.htmlLat1.push(new CharacterEntity(169, "copy"));
	StringUtils.htmlLat1.push(new CharacterEntity(170, "ordf"));
	StringUtils.htmlLat1.push(new CharacterEntity(171, "laquo"));
	StringUtils.htmlLat1.push(new CharacterEntity(172, "not"));
	StringUtils.htmlLat1.push(new CharacterEntity(173, "shy"));
	StringUtils.htmlLat1.push(new CharacterEntity(174, "reg"));
	StringUtils.htmlLat1.push(new CharacterEntity(175, "macr"));
	StringUtils.htmlLat1.push(new CharacterEntity(176, "deg"));
	StringUtils.htmlLat1.push(new CharacterEntity(177, "plusmn"));
	StringUtils.htmlLat1.push(new CharacterEntity(178, "sup2"));
	StringUtils.htmlLat1.push(new CharacterEntity(179, "sup3"));
	StringUtils.htmlLat1.push(new CharacterEntity(180, "acute"));
	StringUtils.htmlLat1.push(new CharacterEntity(181, "micro"));
	StringUtils.htmlLat1.push(new CharacterEntity(182, "para"));
	StringUtils.htmlLat1.push(new CharacterEntity(183, "middot"));
	StringUtils.htmlLat1.push(new CharacterEntity(184, "cedil"));
	StringUtils.htmlLat1.push(new CharacterEntity(185, "sup1"));
	StringUtils.htmlLat1.push(new CharacterEntity(186, "ordm"));
	StringUtils.htmlLat1.push(new CharacterEntity(187, "raquo"));
	StringUtils.htmlLat1.push(new CharacterEntity(188, "frac14"));
	StringUtils.htmlLat1.push(new CharacterEntity(189, "frac12"));
	StringUtils.htmlLat1.push(new CharacterEntity(190, "frac34"));
	StringUtils.htmlLat1.push(new CharacterEntity(191, "iquest"));
	StringUtils.htmlLat1.push(new CharacterEntity(192, "Agrave"));
	StringUtils.htmlLat1.push(new CharacterEntity(193, "Aacute"));
	StringUtils.htmlLat1.push(new CharacterEntity(194, "Acirc"));
	StringUtils.htmlLat1.push(new CharacterEntity(195, "Atilde"));
	StringUtils.htmlLat1.push(new CharacterEntity(196, "Auml"));
	StringUtils.htmlLat1.push(new CharacterEntity(197, "Aring"));
	StringUtils.htmlLat1.push(new CharacterEntity(198, "AElig"));
	StringUtils.htmlLat1.push(new CharacterEntity(199, "Ccedil"));
	StringUtils.htmlLat1.push(new CharacterEntity(200, "Egrave"));
	StringUtils.htmlLat1.push(new CharacterEntity(201, "Eacute"));
	StringUtils.htmlLat1.push(new CharacterEntity(202, "Ecirc"));
	StringUtils.htmlLat1.push(new CharacterEntity(203, "Euml"));
	StringUtils.htmlLat1.push(new CharacterEntity(204, "Igrave"));
	StringUtils.htmlLat1.push(new CharacterEntity(205, "Iacute"));
	StringUtils.htmlLat1.push(new CharacterEntity(206, "Icirc"));
	StringUtils.htmlLat1.push(new CharacterEntity(207, "Iuml"));
	StringUtils.htmlLat1.push(new CharacterEntity(208, "ETH"));
	StringUtils.htmlLat1.push(new CharacterEntity(209, "Ntilde"));
	StringUtils.htmlLat1.push(new CharacterEntity(210, "Ograve"));
	StringUtils.htmlLat1.push(new CharacterEntity(211, "Oacute"));
	StringUtils.htmlLat1.push(new CharacterEntity(212, "Ocirc"));
	StringUtils.htmlLat1.push(new CharacterEntity(213, "Otilde"));
	StringUtils.htmlLat1.push(new CharacterEntity(214, "Ouml"));
	StringUtils.htmlLat1.push(new CharacterEntity(215, "times"));
	StringUtils.htmlLat1.push(new CharacterEntity(216, "Oslash"));
	StringUtils.htmlLat1.push(new CharacterEntity(217, "Ugrave"));
	StringUtils.htmlLat1.push(new CharacterEntity(218, "Uacute"));
	StringUtils.htmlLat1.push(new CharacterEntity(219, "Ucirc"));
	StringUtils.htmlLat1.push(new CharacterEntity(220, "Uuml"));
	StringUtils.htmlLat1.push(new CharacterEntity(221, "Yacute"));
	StringUtils.htmlLat1.push(new CharacterEntity(222, "THORN"));
	StringUtils.htmlLat1.push(new CharacterEntity(223, "szlig"));
	StringUtils.htmlLat1.push(new CharacterEntity(224, "agrave"));
	StringUtils.htmlLat1.push(new CharacterEntity(225, "aacute"));
	StringUtils.htmlLat1.push(new CharacterEntity(226, "acirc"));
	StringUtils.htmlLat1.push(new CharacterEntity(227, "atilde"));
	StringUtils.htmlLat1.push(new CharacterEntity(228, "auml"));
	StringUtils.htmlLat1.push(new CharacterEntity(229, "aring"));
	StringUtils.htmlLat1.push(new CharacterEntity(230, "aelig"));
	StringUtils.htmlLat1.push(new CharacterEntity(231, "ccedil"));
	StringUtils.htmlLat1.push(new CharacterEntity(232, "egrave"));
	StringUtils.htmlLat1.push(new CharacterEntity(233, "eacute"));
	StringUtils.htmlLat1.push(new CharacterEntity(234, "ecirc"));
	StringUtils.htmlLat1.push(new CharacterEntity(235, "euml"));
	StringUtils.htmlLat1.push(new CharacterEntity(236, "igrave"));
	StringUtils.htmlLat1.push(new CharacterEntity(237, "iacute"));
	StringUtils.htmlLat1.push(new CharacterEntity(238, "icirc"));
	StringUtils.htmlLat1.push(new CharacterEntity(239, "iuml"));
	StringUtils.htmlLat1.push(new CharacterEntity(240, "eth"));
	StringUtils.htmlLat1.push(new CharacterEntity(241, "ntilde"));
	StringUtils.htmlLat1.push(new CharacterEntity(242, "ograve"));
	StringUtils.htmlLat1.push(new CharacterEntity(243, "oacute"));
	StringUtils.htmlLat1.push(new CharacterEntity(244, "ocirc"));
	StringUtils.htmlLat1.push(new CharacterEntity(245, "otilde"));
	StringUtils.htmlLat1.push(new CharacterEntity(246, "ouml"));
	StringUtils.htmlLat1.push(new CharacterEntity(247, "divide"));
	StringUtils.htmlLat1.push(new CharacterEntity(248, "oslash"));
	StringUtils.htmlLat1.push(new CharacterEntity(249, "ugrave"));
	StringUtils.htmlLat1.push(new CharacterEntity(250, "uacute"));
	StringUtils.htmlLat1.push(new CharacterEntity(251, "ucirc"));
	StringUtils.htmlLat1.push(new CharacterEntity(252, "uuml"));
	StringUtils.htmlLat1.push(new CharacterEntity(253, "yacute"));
	StringUtils.htmlLat1.push(new CharacterEntity(254, "thorn"));
	StringUtils.htmlLat1.push(new CharacterEntity(255, "yuml"));
	StringUtils.htmlSymbol = [];
	StringUtils.htmlSymbol.push(new CharacterEntity(402, "fnof"));
	StringUtils.htmlSymbol.push(new CharacterEntity(913, "Alpha"));
	StringUtils.htmlSymbol.push(new CharacterEntity(914, "Beta"));
	StringUtils.htmlSymbol.push(new CharacterEntity(915, "Gamma"));
	StringUtils.htmlSymbol.push(new CharacterEntity(916, "Delta"));
	StringUtils.htmlSymbol.push(new CharacterEntity(917, "Epsilon"));
	StringUtils.htmlSymbol.push(new CharacterEntity(918, "Zeta"));
	StringUtils.htmlSymbol.push(new CharacterEntity(919, "Eta"));
	StringUtils.htmlSymbol.push(new CharacterEntity(920, "Theta"));
	StringUtils.htmlSymbol.push(new CharacterEntity(921, "Iota"));
	StringUtils.htmlSymbol.push(new CharacterEntity(922, "Kappa"));
	StringUtils.htmlSymbol.push(new CharacterEntity(923, "Lambda"));
	StringUtils.htmlSymbol.push(new CharacterEntity(924, "Mu"));
	StringUtils.htmlSymbol.push(new CharacterEntity(925, "Nu"));
	StringUtils.htmlSymbol.push(new CharacterEntity(926, "Xi"));
	StringUtils.htmlSymbol.push(new CharacterEntity(927, "Omicron"));
	StringUtils.htmlSymbol.push(new CharacterEntity(928, "Pi"));
	StringUtils.htmlSymbol.push(new CharacterEntity(929, "Rho"));
	StringUtils.htmlSymbol.push(new CharacterEntity(931, "Sigma"));
	StringUtils.htmlSymbol.push(new CharacterEntity(932, "Tau"));
	StringUtils.htmlSymbol.push(new CharacterEntity(933, "Upsilon"));
	StringUtils.htmlSymbol.push(new CharacterEntity(934, "Phi"));
	StringUtils.htmlSymbol.push(new CharacterEntity(935, "Chi"));
	StringUtils.htmlSymbol.push(new CharacterEntity(936, "Psi"));
	StringUtils.htmlSymbol.push(new CharacterEntity(937, "Omega"));
	StringUtils.htmlSymbol.push(new CharacterEntity(945, "alpha"));
	StringUtils.htmlSymbol.push(new CharacterEntity(946, "beta"));
	StringUtils.htmlSymbol.push(new CharacterEntity(947, "gamma"));
	StringUtils.htmlSymbol.push(new CharacterEntity(948, "delta"));
	StringUtils.htmlSymbol.push(new CharacterEntity(949, "epsilon"));
	StringUtils.htmlSymbol.push(new CharacterEntity(950, "zeta"));
	StringUtils.htmlSymbol.push(new CharacterEntity(951, "eta"));
	StringUtils.htmlSymbol.push(new CharacterEntity(952, "theta"));
	StringUtils.htmlSymbol.push(new CharacterEntity(953, "iota"));
	StringUtils.htmlSymbol.push(new CharacterEntity(954, "kappa"));
	StringUtils.htmlSymbol.push(new CharacterEntity(955, "lambda"));
	StringUtils.htmlSymbol.push(new CharacterEntity(956, "mu"));
	StringUtils.htmlSymbol.push(new CharacterEntity(957, "nu"));
	StringUtils.htmlSymbol.push(new CharacterEntity(958, "xi"));
	StringUtils.htmlSymbol.push(new CharacterEntity(959, "omicron"));
	StringUtils.htmlSymbol.push(new CharacterEntity(960, "pi"));
	StringUtils.htmlSymbol.push(new CharacterEntity(961, "rho"));
	StringUtils.htmlSymbol.push(new CharacterEntity(962, "sigmaf"));
	StringUtils.htmlSymbol.push(new CharacterEntity(963, "sigma"));
	StringUtils.htmlSymbol.push(new CharacterEntity(964, "tau"));
	StringUtils.htmlSymbol.push(new CharacterEntity(965, "upsilon"));
	StringUtils.htmlSymbol.push(new CharacterEntity(966, "phi"));
	StringUtils.htmlSymbol.push(new CharacterEntity(967, "chi"));
	StringUtils.htmlSymbol.push(new CharacterEntity(968, "psi"));
	StringUtils.htmlSymbol.push(new CharacterEntity(969, "omega"));
	StringUtils.htmlSymbol.push(new CharacterEntity(977, "thetasym"));
	StringUtils.htmlSymbol.push(new CharacterEntity(978, "upsih"));
	StringUtils.htmlSymbol.push(new CharacterEntity(982, "piv"));
	StringUtils.htmlSymbol.push(new CharacterEntity(8230, "hellip"));
	StringUtils.htmlSymbol.push(new CharacterEntity(8242, "prime"));
	StringUtils.htmlSymbol.push(new CharacterEntity(8243, "Prime"));
	StringUtils.htmlSymbol.push(new CharacterEntity(8254, "oline"));
	StringUtils.htmlSymbol.push(new CharacterEntity(8260, "frasl"));
	StringUtils.htmlSymbol.push(new CharacterEntity(8465, "image"));
	StringUtils.htmlSymbol.push(new CharacterEntity(8472, "weierp"));
	StringUtils.htmlSymbol.push(new CharacterEntity(8476, "real"));
	StringUtils.htmlSymbol.push(new CharacterEntity(8482, "trade"));
	StringUtils.htmlSymbol.push(new CharacterEntity(8501, "alefsym"));
	StringUtils.htmlSymbol.push(new CharacterEntity(8592, "larr"));
	StringUtils.htmlSymbol.push(new CharacterEntity(8593, "uarr"));
	StringUtils.htmlSymbol.push(new CharacterEntity(8594, "rarr"));
	StringUtils.htmlSymbol.push(new CharacterEntity(8595, "darr"));
	StringUtils.htmlSymbol.push(new CharacterEntity(8596, "harr"));
	StringUtils.htmlSymbol.push(new CharacterEntity(8629, "crarr"));
	StringUtils.htmlSymbol.push(new CharacterEntity(8656, "lArr"));
	StringUtils.htmlSymbol.push(new CharacterEntity(8657, "uArr"));
	StringUtils.htmlSymbol.push(new CharacterEntity(8658, "rArr"));
	StringUtils.htmlSymbol.push(new CharacterEntity(8659, "dArr"));
	StringUtils.htmlSymbol.push(new CharacterEntity(8660, "hArr"));
	StringUtils.htmlSymbol.push(new CharacterEntity(8704, "forall"));
	StringUtils.htmlSymbol.push(new CharacterEntity(8706, "part"));
	StringUtils.htmlSymbol.push(new CharacterEntity(8707, "exist"));
	StringUtils.htmlSymbol.push(new CharacterEntity(8709, "empty"));
	StringUtils.htmlSymbol.push(new CharacterEntity(8711, "nabla"));
	StringUtils.htmlSymbol.push(new CharacterEntity(8712, "isin"));
	StringUtils.htmlSymbol.push(new CharacterEntity(8713, "notin"));
	StringUtils.htmlSymbol.push(new CharacterEntity(8715, "ni"));
	StringUtils.htmlSymbol.push(new CharacterEntity(8719, "prod"));
	StringUtils.htmlSymbol.push(new CharacterEntity(8721, "sum"));
	StringUtils.htmlSymbol.push(new CharacterEntity(8722, "minus"));
	StringUtils.htmlSymbol.push(new CharacterEntity(8727, "lowast"));
	StringUtils.htmlSymbol.push(new CharacterEntity(8730, "radic"));
	StringUtils.htmlSymbol.push(new CharacterEntity(8733, "prop"));
	StringUtils.htmlSymbol.push(new CharacterEntity(8734, "infin"));
	StringUtils.htmlSymbol.push(new CharacterEntity(8736, "ang"));
	StringUtils.htmlSymbol.push(new CharacterEntity(8743, "and"));
	StringUtils.htmlSymbol.push(new CharacterEntity(8744, "or"));
	StringUtils.htmlSymbol.push(new CharacterEntity(8745, "cap"));
	StringUtils.htmlSymbol.push(new CharacterEntity(8746, "cup"));
	StringUtils.htmlSymbol.push(new CharacterEntity(8747, "int"));
	StringUtils.htmlSymbol.push(new CharacterEntity(8756, "there4"));
	StringUtils.htmlSymbol.push(new CharacterEntity(8764, "sim"));
	StringUtils.htmlSymbol.push(new CharacterEntity(8773, "cong"));
	StringUtils.htmlSymbol.push(new CharacterEntity(8776, "asymp"));
	StringUtils.htmlSymbol.push(new CharacterEntity(8800, "ne"));
	StringUtils.htmlSymbol.push(new CharacterEntity(8801, "equiv"));
	StringUtils.htmlSymbol.push(new CharacterEntity(8804, "le"));
	StringUtils.htmlSymbol.push(new CharacterEntity(8805, "ge"));
	StringUtils.htmlSymbol.push(new CharacterEntity(8834, "sub"));
	StringUtils.htmlSymbol.push(new CharacterEntity(8835, "sup"));
	StringUtils.htmlSymbol.push(new CharacterEntity(8836, "nsub"));
	StringUtils.htmlSymbol.push(new CharacterEntity(8838, "sube"));
	StringUtils.htmlSymbol.push(new CharacterEntity(8839, "supe"));
	StringUtils.htmlSymbol.push(new CharacterEntity(8853, "oplus"));
	StringUtils.htmlSymbol.push(new CharacterEntity(8855, "otimes"));
	StringUtils.htmlSymbol.push(new CharacterEntity(8869, "perp"));
	StringUtils.htmlSymbol.push(new CharacterEntity(8901, "sdot"));
	StringUtils.htmlSymbol.push(new CharacterEntity(8968, "lceil"));
	StringUtils.htmlSymbol.push(new CharacterEntity(8969, "rceil"));
	StringUtils.htmlSymbol.push(new CharacterEntity(8970, "lfloor"));
	StringUtils.htmlSymbol.push(new CharacterEntity(8971, "rfloor"));
	StringUtils.htmlSymbol.push(new CharacterEntity(9001, "lang"));
	StringUtils.htmlSymbol.push(new CharacterEntity(9002, "rang"));
	StringUtils.htmlSymbol.push(new CharacterEntity(9674, "loz"));
	StringUtils.htmlSymbol.push(new CharacterEntity(9824, "spades"));
	StringUtils.htmlSymbol.push(new CharacterEntity(9827, "clubs"));
	StringUtils.htmlSymbol.push(new CharacterEntity(9829, "hearts"));
	StringUtils.htmlSymbol.push(new CharacterEntity(9830, "diams"));
	StringUtils.htmlSpecial = [];
	StringUtils.htmlSpecial.push(new CharacterEntity(34, "quot"));
	StringUtils.htmlSpecial.push(new CharacterEntity(38, "amp"));
	StringUtils.htmlSpecial.push(new CharacterEntity(39, "apos"));
	StringUtils.htmlSpecial.push(new CharacterEntity(60, "lt"));
	StringUtils.htmlSpecial.push(new CharacterEntity(62, "gt"));
	StringUtils.htmlSpecial.push(new CharacterEntity(338, "OElig"));
	StringUtils.htmlSpecial.push(new CharacterEntity(339, "oelig"));
	StringUtils.htmlSpecial.push(new CharacterEntity(352, "Scaron"));
	StringUtils.htmlSpecial.push(new CharacterEntity(353, "scaron"));
	StringUtils.htmlSpecial.push(new CharacterEntity(376, "Yuml"));
	StringUtils.htmlSpecial.push(new CharacterEntity(710, "circ"));
	StringUtils.htmlSpecial.push(new CharacterEntity(732, "tilde"));
	StringUtils.htmlSpecial.push(new CharacterEntity(8194, "ensp"));
	StringUtils.htmlSpecial.push(new CharacterEntity(8195, "emsp"));
	StringUtils.htmlSpecial.push(new CharacterEntity(8201, "thinsp"));
	StringUtils.htmlSpecial.push(new CharacterEntity(8204, "zwnj"));
	StringUtils.htmlSpecial.push(new CharacterEntity(8205, "zwj"));
	StringUtils.htmlSpecial.push(new CharacterEntity(8206, "lrm"));
	StringUtils.htmlSpecial.push(new CharacterEntity(8207, "rlm"));
	StringUtils.htmlSpecial.push(new CharacterEntity(8211, "ndash"));
	StringUtils.htmlSpecial.push(new CharacterEntity(8212, "mdash"));
	StringUtils.htmlSpecial.push(new CharacterEntity(8216, "lsquo"));
	StringUtils.htmlSpecial.push(new CharacterEntity(8217, "rsquo"));
	StringUtils.htmlSpecial.push(new CharacterEntity(8218, "sbquo"));
	StringUtils.htmlSpecial.push(new CharacterEntity(8220, "ldquo"));
	StringUtils.htmlSpecial.push(new CharacterEntity(8221, "rdquo"));
	StringUtils.htmlSpecial.push(new CharacterEntity(8222, "bdquo"));
	StringUtils.htmlSpecial.push(new CharacterEntity(8224, "dagger"));
	StringUtils.htmlSpecial.push(new CharacterEntity(8225, "Dagger"));
	StringUtils.htmlSpecial.push(new CharacterEntity(8226, "bull"));
	StringUtils.htmlSpecial.push(new CharacterEntity(8240, "permil"));
	StringUtils.htmlSpecial.push(new CharacterEntity(8249, "lsaquo"));
	StringUtils.htmlSpecial.push(new CharacterEntity(8250, "rsaquo"));
	StringUtils.htmlSpecial.push(new CharacterEntity(8364, "euro"));
	/*var list = [];
	list.addAll(StringUtils.xml10);
	list.addAll(StringUtils.htmlLat1);
	list.addAll(StringUtils.htmlSymbol);
	list.addAll(StringUtils.htmlSpecial);*/
	StringUtils.html40Entities = new CharacterEntitySolver();
    for (var i=0; i<StringUtils.xml10.length; i++) {
    	var entity = StringUtils.xml10[i];
    	StringUtils.html40Entities.add(entity.getNumericValue(), entity.getName());
    }
    for (var i=0; i<StringUtils.htmlLat1.length; i++) {
    	var entity = StringUtils.htmlLat1[i];
    	StringUtils.html40Entities.add(entity.getNumericValue(), entity.getName());
    }
    for (var i=0; i<StringUtils.htmlSymbol.length; i++) {
    	var entity = StringUtils.htmlSymbol[i];
    	StringUtils.html40Entities.add(entity.getNumericValue(), entity.getName());
    }
    for (var i=0; i<StringUtils.htmlSpecial.length; i++) {
    	var entity = StringUtils.htmlSpecial[i];
    	StringUtils.html40Entities.add(entity.getNumericValue(), entity.getName());
    }
})();


var FormReader = new commons.Class({
    /*
	 * public FormReader(Representation representation) throws IOException {
	 * this(representation, true); }
	 * 
	 * public FormReader(Representation representation, boolean decode) throws
	 * IOException { this.decode = decode; this.stream =
	 * representation.getStream(); this.separator = '&';
	 * 
	 * if (representation.getCharacterSet() != null) { this.characterSet =
	 * representation.getCharacterSet(); } else { this.characterSet =
	 * CharacterSet.UTF_8; } }
	 */

    /*
	 * public FormReader(String parametersString, char separator) {
	 * this(parametersString, null, separator, false); }
	 * 
	 * public FormReader(String parametersString, CharacterSet characterSet,
	 * char separator) { this(parametersString, characterSet, separator, true); }
	 */

    initialize: function(parametersString, characterSet, separator, decode) {
    	this.currentIndex = 0;
        this.decode = decode;
        this.stream = parametersString;
        // [ifndef gwt] instruction
        // this.stream = new ByteArrayInputStream(parametersString.getBytes());
        // [ifdef gwt] instruction uncomment
        // this.stream = new
        // org.restlet.engine.io.StringInputStream(parametersString);

        this.characterSet = characterSet;
        this.separator = separator;
    },

    addParameters: function(parameters) {
        var readNext = true;
        var param = null;

        if (this.stream != null) {
            // Let's read all form parameters
            try {
                while (readNext) {
                    param = this.readNextParameter();

                    if (param != null) {
                        // Add parsed parameter to the form
                        parameters.add(param);
                    } else {
                        // Last parameter parsed
                        readNext = false;
                    }
                }
            } catch (err) {
            	console.log(err.stack);
                /*
				 * Context.getCurrentLogger() .log(Level.WARNING, "Unable to
				 * parse a form parameter. Skipping the remaining parameters.",
				 * ioe);
				 */
            }

            try {
                // this.stream.close();
            } catch (err) {
                /*
				 * Context.getCurrentLogger().log(Level.WARNING, "Unable to
				 * close the form input stream", ioe);
				 */
            	console.log(err.stack);
            }
        }
    },

    read: function() {
        var result = new data.Form();

        if (this.stream != null) {
            var param = this.readNextParameter();

            while (param != null) {
                result.add(param);
                param = this.readNextParameter();
            }

            // this.stream.close();
        }

        return result;
    },

    readFirstParameter: function(name) {
        var result = null;

        if (this.stream != null) {
            var param = this.readNextParameter();

            while ((param != null) && (result == null)) {
                if (param.getName()==name) {
                    result = param;
                }

                param = this.readNextParameter();
            }

            // this.stream.close();
        }

        return result;
    },

    readNextParameter: function() {
        var result = null;

        if (this.stream != null) {
            try {
                var readingName = true;
                var readingValue = false;
                var nameBuffer = new commons.StringBuilder();
                var valueBuffer = new commons.StringBuilder();
                var nextChar = 0;

                while ((result == null) && (this.currentIndex <= this.stream.length)) {
                	if (this.currentIndex < this.stream.length) {
                		nextChar = this.stream[this.currentIndex];
                	} else {
                		nextChar = '';
                	}
                    this.currentIndex++;

                    if (readingName) {
                        if (nextChar == '=') {
                            if (nameBuffer.length() > 0) {
                                readingName = false;
                                readingValue = true;
                            } else {
                                /*
								 * throw new IOException( "Empty parameter name
								 * detected. Please check your form data");
								 */
                            }
                        } else if ((nextChar == this.separator)
                                || (this.currentIndex == this.stream.length+1)) {
                            if (nameBuffer.length() > 0) {
                                result = FormUtils.create(nameBuffer, null,
                                        this.decode, this.characterSet);
                            } else if (this.currentIndex == this.stream.length+1) {
                                // Do nothing return null preference
                            } else {
                                /*
								 * Context.getCurrentLogger()
								 * .fine("Empty parameter name detected. Please
								 * check your form data");
								 */
                            }
                        } else {
                            nameBuffer.append(nextChar);
                        }
                    } else if (readingValue) {
                        if ((nextChar == this.separator) || (this.currentIndex == this.stream.length+1)) {
                            result = FormUtils.create(nameBuffer, valueBuffer,
                                    this.decode, this.characterSet);
                        } else {
                            valueBuffer.append(nextChar);
                        }
                    }
                }
            } catch (err) {
            	console.log(err.stack);
                /*
				 * throw new IOException( "Unsupported encoding. Please contact
				 * the administrator");
				 */
            }
        }

        return result;
    },

    readParameter: function(name) {
        var result = null;

        if (this.stream != null) {
            var param = this.readNextParameter();

            while (param != null) {
                if (param.getName()==name) {
                    if (result != null) {
                        var values = null;

                        if (typeof result == "Array") {
                            // Multiple values already found for this parameter
                            values = result;
                        } else {
                            // Second value found for this parameter
                            // Create a list of values
                            values = [];
                            values.add(result);
                            result = values;
                        }

                        if (param.getValue() == null) {
                            values.add(util.Series.EMPTY_VALUE);
                        } else {
                            values.add(param.getValue());
                        }
                    } else {
                        if (param.getValue() == null) {
                            result = util.Series.EMPTY_VALUE;
                        } else {
                            result = param.getValue();
                        }
                    }
                }

                param = this.readNextParameter();
            }

            // this.stream.close();
        }

        return result;
    },

    readParameters: function(parameters) {
        if (this.stream != null) {
            var param = this.readNextParameter();
            var currentValue = null;

            while (param != null) {
                if (parameters.containsKey(param.getName())) {
                    currentValue = parameters.get(param.getName());

                    if (currentValue != null) {
                        List<Object> values = null;

                        if (typeof currentValue == "Array") {
                            // Multiple values already found for this parameter
                            values = currentValue;
                        } else {
                            // Second value found for this parameter
                            // Create a list of values
                            values = [];
                            values.add(currentValue);
                            parameters.put(param.getName(), values);
                        }

                        if (param.getValue() == null) {
                            values.add(util.Series.EMPTY_VALUE);
                        } else {
                            values.add(param.getValue());
                        }
                    } else {
                        if (param.getValue() == null) {
                            parameters.put(param.getName(), util.Series.EMPTY_VALUE);
                        } else {
                            parameters.put(param.getName(), param.getValue());
                        }
                    }
                }

                param = this.readNextParameter();
            }

            // this.stream.close();
        }
    }
});

var FormUtils = new commons.Class({});

FormUtils.extend({
    create: function(name, value,
            decode, characterSet) {
        var result = null;

        if (name != null) {
            var nameStr;
            if (decode) {
                nameStr = data.Reference.decode(name.toString(), characterSet);
            } else {
                nameStr = name.toString();
            }
            if (value != null) {
                var valueStr;
                if (decode) {
                    valueStr = data.Reference.decode(value.toString(), characterSet);
                } else {
                    valueStr = value.toString();
                }
                result = new data.Parameter(nameStr, valueStr);
            } else {
                result = new data.Parameter(nameStr, null);
            }
        }
        return result;
    },

    /*public static Parameter getFirstParameter(Representation post, String name)
            throws IOException {
        if (!post.isAvailable()) {
            throw new IllegalStateException(
                    "The Web form cannot be parsed as no fresh content is available. If this entity has been already read once, caching of the entity is required");
        }

        return new FormReader(post).readFirstParameter(name);
    },

    public static Parameter getFirstParameter(String query, String name,
            CharacterSet characterSet, char separator, boolean decode)
            throws IOException {
        return new FormReader(query, characterSet, separator, decode)
                .readFirstParameter(name);
    },

    public static Object getParameter(Representation form, String name)
            throws IOException {
        if (!form.isAvailable()) {
            throw new IllegalStateException(
                    "The Web form cannot be parsed as no fresh content is available. If this entity has been already read once, caching of the entity is required");
        }

        return new FormReader(form).readParameter(name);
    },

    public static Object getParameter(String query, String name,
            CharacterSet characterSet, char separator, boolean decode)
            throws IOException {
        return new FormReader(query, characterSet, separator, decode)
                .readParameter(name);
    },

    public static void getParameters(Representation post,
            Map<String, Object> parameters) throws IOException {
        if (!post.isAvailable()) {
            throw new IllegalStateException(
                    "The Web form cannot be parsed as no fresh content is available. If this entity has been already read once, caching of the entity is required");
        }

        new FormReader(post).readParameters(parameters);
    }

    public static void getParameters(String parametersString,
            Map<String, Object> parameters, CharacterSet characterSet,
            char separator, boolean decode) throws IOException {
        new FormReader(parametersString, characterSet, separator, decode)
                .readParameters(parameters);
    }

    public static boolean isParameterFound(Parameter searchedParam,
            MediaType mediaRange) {
        boolean result = false;

        for (Iterator<Parameter> iter = mediaRange.getParameters().iterator(); !result
                && iter.hasNext();) {
            result = searchedParam.equals(iter.next());
        }

        return result;
    }*/

    /*public static void parse(Form form, Representation post, boolean decode) {
        if (post != null) {
            if (post.isAvailable()) {
                FormReader fr = null;

                try {
                    fr = new FormReader(post, decode);
                } catch (IOException ioe) {
                    Context.getCurrentLogger().log(Level.WARNING,
                            "Unable to create a form reader. Parsing aborted.",
                            ioe);
                }

                if (fr != null) {
                    fr.addParameters(form);
                }
            } else {
                Context.getCurrentLogger()
                        .log(Level.FINE,
                                "The form wasn't changed as the given representation isn't available.");
            }
        }
    }*/

    parse: function(form, parametersString, characterSet, decode, separator) {
        if ((parametersString != null) && parametersString != "") {
            var fr = new FormReader(parametersString, characterSet, separator,
                    decode);
            fr.addParameters(form);
        }
    }
});
module.exports["FormUtils"] = FormUtils;

// Level

var Level = new commons.Class();

Level.extend({
	SEVERE: "severe",
	WARNING: "warning",
	INFO: "info",
	FINE: "fine"
});
module.exports["Level"] = Level;

var representation = require("./restlet-representation.js");
var util = require("./restlet-util.js");
var data = require("./restlet-data.js");
var resource = require("./restlet-resource.js");

//Root entities

var Restlet = new commons.Class({
	initialize: function(context) {
        this.context = context;
        this.started = false;
        //this.name = this.toString();
        this.description = null;
        this.author = null;
        this.owner = null;

        if (Engine.getInstance() == null) {
            /*Context.getCurrentLogger()
                    .severe("Unable to fully initialize the Restlet. No Restlet engine available.");*/
            throw new Error(
                    "Unable to fully initialize the Restlet. No Restlet engine available.");
        }

        Restlet.fireContextChanged(this, context);
    },

    finalize: function() {
        if (this.isStarted()) {
        	this.stop();
        }
    },

    getApplication: function() {
        return this.application;
    },

    setApplication: function(application) {
        this.application = application;
    },

    getAuthor: function() {
        return this.author;
    },

    getContext: function() {
        return this.context;
    },

    getDescription: function() {
        return this.description;
    },
    
    getLogger: function() {
        var result = null;
        var context = this.getContext();

        /*if (context == null) {
            context = Context.getCurrent();
        }*/

        if (context != null) {
            result = context.getLogger();
        }

        if (result == null) {
            result = Engine.getLogger(this, "org.restlet");
        }

        return result;
    },

    getName: function() {
        return this.name;
    },

    getOwner: function() {
        return this.owner;
    },

    setAuthor: function(author) {
        this.author = author;
    },

    setContext: function(context) {
        this.context = context;
        Restlet.fireContextChanged(this, context);
    },

    setDescription: function(description) {
        this.description = description;
    },

    setName: function(name) {
        this.name = name;
    },

    setOwner: function(owner) {
        this.owner = owner;
    },
    
    /*setProtocols: function(protocols) {
		this.protocols = protocols;
	},*/

	isStarted: function() {
        return this.started;
    },

    isStopped: function() {
        return !this.started;
    },

    start: function() {
        this.started = true;
    },

    stop: function() {
        this.started = false;
    },

    handle: function(request, response) {
    	if (response==null) {
    		response = new Response(request);
    	}
    	
        if (this.isStopped()) {
            try {
                this.start();
            } catch (err) {
                // Occurred while starting the Restlet
                this.getContext().getLogger().log(Level.WARNING, Restlet.UNABLE_TO_START, e);
                response.setStatus(data.Status.SERVER_ERROR_INTERNAL);
            }

            if (!this.isStarted()) {
                // No exception raised but the Restlet somehow couldn't be
                // started
                this.getContext().getLogger().log(Level.WARNING, Restlet.UNABLE_TO_START);
                response.setStatus(data.Status.SERVER_ERROR_INTERNAL);
            }
        }
    },

    createFinder: function(resourceClass) {
        var result = null;

        if (this.getFinderClass() != null) {
            result = Finder.createFinder(resourceClass,
                    this.getFinderClass(), this.getContext(), this.getLogger());
        } else if ((this.getApplication() != null) && (this.getApplication() != this)) {
            result = this.getApplication().createFinder(resourceClass);
        } else {
            result = Finder.createFinder(resourceClass,
                    Finder, this.getContext(),
                    this.getLogger());
        }

        return result;
    },

    getFinderClass: function() {
        return this.finderClass;
    },

    setFinderClass: function(finderClass) {
        this.finderClass = finderClass;
    }
});

Restlet.extend({
	/** Error message. */
	UNABLE_TO_START: "Unable to start the Restlet",

	fireContextChanged: function(restlet, context) {
		if (context != null) {
			/*if (context instanceof ChildContext) {
				var childContext = context;

				if (childContext.getChild() == null) {
					childContext.setChild(restlet);
				}
			} else if (!(restlet instanceof Component)
					&& (context instanceof ComponentContext)) {
				//context.getLogger()
                //    .severe("For security reasons, don't pass the component context to child Restlets anymore. Use the Context#createChildContext() method instead. "
                //            + restlet.getClass());
			}*/
		}
	},
	
	create: function(fn) {
		var restlet = new Restlet();
		restlet.handle = fn;
		return restlet;
	}
});

var Context = new commons.Class({
	initialize: function() {
    	var logger = null;
    	if (arguments.length==0) {
    		//logger = Engine.getLogger("org.restlet");
    		logger = new Logger("org.restlet");
    	} else if (arguments.length==1 && typeof arguments[0] == "string") {
    		var loggerName = arguments[0];
    		//logger = Engine.getLogger(loggerName);
    		logger = new Logger(loggerName);
    	} else {
    		logger = arguments[0];
    	}
        this.attributes = {};
        this.logger = logger;
        this.parameters = new util.Series();
        this.clientDispatcher = null;

        //this.defaultEnroler = null;
        this.serverDispatcher = null;
        //this.defaultVerifier = null;
    },

    createChildContext: function() {
        return new ChildContext(this);
    },

    getAttributes: function() {
        return this.attributes;
    },

    getClientDispatcher: function() {
        return this.clientDispatcher;
    },

    /*public org.restlet.security.Enroler getDefaultEnroler() {
        return defaultEnroler;
    }*/

    /*public org.restlet.security.Verifier getDefaultVerifier() {
        return this.defaultVerifier;
    }*/

    getLogger: function() {
        return this.logger;
    },

    getParameters: function() {
        return this.parameters;
    },

    getServerDispatcher: function() {
        return this.serverDispatcher;
    },

    setAttributes: function(attributes) {
        if (attributes != getAttributes()) {
            this.getAttributes().clear();

            if (attributes != null) {
            	this.getAttributes().putAll(attributes);
            }
        }
    },

    setClientDispatcher: function(clientDispatcher) {
        this.clientDispatcher = clientDispatcher;
    },

    /*public void setDefaultEnroler(org.restlet.security.Enroler enroler) {
        this.defaultEnroler = enroler;
    }*/

    /*public void setDefaultVerifier(org.restlet.security.Verifier verifier) {
        this.defaultVerifier = verifier;
    }*/

    /*public void setLogger(Logger logger) {
        this.logger = logger;
    }

    public void setLogger(String loggerName) {
        setLogger(Engine.getLogger(loggerName));
    }*/

    setParameters: function(parameters) {
        if (parameters != getParameters()) {
            getParameters().clear();

            if (parameters != null) {
                getParameters().addAll(parameters);
            }
        }
    },

    setServerDispatcher: function(serverDispatcher) {
        this.serverDispatcher = serverDispatcher;
    }
});

Context.extend({
	getCurrentLogger: function() {
		return new Logger("org.restlet");
	}
});


var Logger = new commons.Class({
	initialize: function(loggerName) {
		this.loggerName = loggerName;
	},
	log: function(level, message, err) {
		//console.log("blah - err = "+err);
		console.log("["+level+"] "+message);
		if (err!=null) {
			console.log(err/*.stack*/);
		}
	},
	
	warning: function(message, err) {
		this.log(Level.WARNING, message, err);
		console.log(err.stack);
	},
	
	fine: function(message, err) {
		this.log(Level.FINE, message, err);
	},

	info: function(message, err) {
		this.log(Level.INFO, message, err);
	}
});


var Message = new commons.Class({
	initialize: function(entity) {
    	this.attributes = null;
    	this.cacheDirectives = null;
    	this.date = null;
    	this.entity = entity;
    	this.entityText = null;
    	this.recipientsInfo = null;
	},

	getAttributes: function() {
		if (this.attributes==null) {
			this.attributes = {};
		}
		return this.attributes;
	}, 

	getCacheDirectives: function() {
		if (this.cacheDirectives==null) {
			this.cacheDirectives = [];
		}
		return this.cacheDirectives;
	}, 

	getDate: function() {
		return this.date;
	},

	getEntity: function() {
		return this.entity;
	},

	getEntityAsText: function() {
        if (this.entityText == null) {
            this.entityText = (this.getEntity() == null) ? null : this.getEntity()
                        .getText();
        }
        return this.entityText;
    },

    getRecipientsInfo: function() {
		if (this.recipientsInfo==null) {
			this.recipientsInfo = [];
		}
		return this.recipientsInfo;
	},

	getWarnings: function() {
		if (this.warnings==null) {
			this.warnings = [];
		}
		return this.warnings;
	},

    isConfidential: function() {
    	return false;
    },

    isEntityAvailable: function() {
        return (this.getEntity() != null) && this.getEntity().isAvailable();
    },

    release: function() {
        if (this.getEntity() != null) {
        	this.getEntity().release();
        }
    },

	setAttributes: function(attributes) {
		this.attributes = attributes;
	},

	setCacheDirectives: function(cacheDirectives) {
		this.cacheDirectives = cacheDirectives;
	}, 

	setDate: function(date) {
		this.date = date;
	},

	setEntity: function(entity) {
		if (arguments.length==1) {
			var entity = arguments[0];
			this.entity = entity;
		} else if (arguments.length==2) {
			var value = arguments[0];
			var mediaType = arguments[1];
			this.entity = new representation.StringRepresentation(value, mediaType);
		}
	},

	setRecipientsInfo: function(recipientsInfo) {
		this.recipientsInfo = recipientsInfo;
	}, 

	setWarnings: function(warnings) {
		this.warnings = warnings;
	}
});

var Request = new commons.Class(Message, {
	//initialize: function(method, resourceRef, url) {
	initialize: function(method, resourceRef, entity) {
		this.callSuperCstr(entity);
		this.method = method;
		this.clientInfo = new data.ClientInfo();
		if (typeof resourceRef == "string") {
			this.resourceRef = new data.Reference(resourceRef);
		} else if (resourceRef instanceof data.Reference) {
			this.resourceRef = resourceRef;
		}
		this.ranges = [];
		this.conditions = new data.Conditions();
		this.cookies = new util.Series();
		this.loggable = true;
	},
	
    abort: function() {
        return false;
    },

    commit: function(response) {
    },

    getChallengeResponse: function() {
        return this.challengeResponse;
    },

    getClientInfo: function() {
        if (this.clientInfo==null) {
        	this.clientInfo = new data.ClientInfo();
        }
        return this.clientInfo;
    },

    getConditions: function() {
        if (this.conditions==null) {
        	this.conditions = new data.Conditions();
        }
        return this.conditions;
    },

    getCookies: function() {
        if (this.cookies==null) {
        	this.cookies = new util.Series();
        }
        return this.cookies;
    },

    getHostRef: function() {
        return this.hostRef;
    },

    getMaxForwards: function() {
        return this.maxForwards;
    },

    getMethod: function() {
        return this.method;
    },

    getOriginalRef: function() {
        return this.originalRef;
    },

    getProtocol: function() {
        var result = this.protocol;

        if ((result == null) && (this.getResourceRef() != null)) {
            // Attempt to guess the protocol to use
            // from the target reference scheme
            result = this.getResourceRef().getSchemeProtocol();
            // Fallback: look at base reference scheme
            if (result == null) {
                result = (this.getResourceRef().getBaseRef() != null) ? this.getResourceRef()
                        .getBaseRef().getSchemeProtocol() : null;
            }
        }

        return result;
    },

    getProxyChallengeResponse: function() {
        return this.proxyChallengeResponse;
    },

    getRanges: function() {
        if (this.ranges==null) {
        	this.ranges = [];
        }
        return this.ranges;
    },

    getReferrerRef: function() {
        return this.referrerRef;
    },

    getResourceRef: function() {
        return this.resourceRef;
    },

    getRootRef: function() {
        return this.rootRef;
    },

    isConfidential: function() {
        return (this.getProtocol() == null) ? false : this.getProtocol().isConfidential();
    },

    isEntityAvailable: function() {
        var result = (data.Method.GET.equals(this.getMethod())
                || data.Method.HEAD.equals(this.getMethod()) || data.Method.DELETE
                .equals(this.getMethod()));
        if (result) {
            return false;
        }

        //return super.isEntityAvailable();
        return (this.getEntity() != null) && this.getEntity().isAvailable();

    },

    isExpectingResponse: function() {
        return (this.getMethod() == null) ? false : this.getMethod().isReplying();
    },

    isLoggable: function() {
        return this.loggable;
    },

    setChallengeResponse: function(challengeResponse) {
        this.challengeResponse = challengeResponse;
    },

    setClientInfo: function(clientInfo) {
        this.clientInfo = clientInfo;
    },

    setConditions: function(conditions) {
        this.conditions = conditions;
    },

    setCookies: function(cookies) {
    	this.cookies = cookies;
    },

    _setHostRef: function(hostRef) {
        this.hostRef = hostRef;
    },

    setHostRef: function(host) {
    	if (typeof host == "string") {
    		this._setHostRef(new data.Reference(host));
    	} else {
    		this._setHostRef(host);
    	}
    },

    setLoggable: function(loggable) {
        this.loggable = loggable;
    },

    setMaxForwards: function(maxForwards) {
        this.maxForwards = maxForwards;
    },

    setMethod: function(method) {
        this.method = method;
    },

    setOriginalRef: function(originalRef) {
        this.originalRef = originalRef;
    },

    setProtocol: function(protocol) {
        this.protocol = protocol;
    },

    setProxyChallengeResponse: function(challengeResponse) {
        this.proxyChallengeResponse = challengeResponse;
    },

    setRanges: function(ranges) {
    	this.ranges = ranges;
    },

    _setReferrerRef: function(referrerRef) {
        this.referrerRef = referrerRef;

        // A referrer reference must not include a fragment.
        if ((this.referrerRef != null)
                && (this.referrerRef.getFragment() != null)) {
            this.referrerRef.setFragment(null);
        }
    },

    setReferrerRef: function(referrer) {
    	if (typeof referrer == "string") {
    		this._setReferrerRef(new data.Reference(referrer));
    	} else {
    		this._setReferrerRef(referrer);
    	}
    },

    _setResourceRef: function(resourceRef) {
        this.resourceRef = resourceRef;
    },

    setResourceRef: function(resource) {
    	if (typeof resource == "string") {
    		if (this.getResourceRef() != null) {
    			// Allow usage of URIs relative to the current base reference
    			this._setResourceRef(new data.Reference(this.getResourceRef().getBaseRef(),
    								resource));
    		} else {
    			this._setResourceRef(new data.Reference(resource));
    		}
    	} else {
    		this._setResourceRef(resource);
    	}
    },

    setRootRef: function(rootRef) {
        this.rootRef = rootRef;
    },

    toString: function() {
        return ((this.getMethod() == null) ? "" : this.getMethod().toString())
                + " "
                + ((this.getResourceRef() == null) ? "" : this.getResourceRef()
                        .toString())
                + " "
                + ((this.getProtocol() == null) ? ""
                        : (this.getProtocol().getName() + ((this.getProtocol()
                                .getVersion() == null) ? "" : "/"
                                + this.getProtocol().getVersion())));
    }
});


var Response = new commons.Class(Message, {
	initialize: function(request) {
		this.callSuperCstr();
        this.age = 0;
        this.allowedMethods = null;
        this.autoCommitting = true;
        this.challengeRequests = null;
        this.cookieSettings = null;
        this.committed = false;
        this.dimensions = null;
        this.locationRef = null;
        this.proxyChallengeRequests = null;
        this.request = request;
        this.retryAfter = null;
        this.serverInfo = new data.ServerInfo();
        this.status = data.Status.SUCCESS_OK;
	},
	
    abort: function() {
        this.getRequest().abort();
    },

    /*commit: function() {
        this.getRequest().commit(this);
    },*/

    getAge: function() {
        return this.age;
    },

    getAllowedMethods: function() {
        if (this.allowedMethods==null) {
        	this.allowedMethods = [];
        }
        return this.allowedMethods;
    },

    functiongetAuthenticationInfo: function() {
        return this.authenticationInfo;
    },

    getChallengeRequests: function() {
        if (this.challengeRequests==null) {
        	this.challengeRequests = [];
        }
        return this.challengeRequests;
    },

    getCookieSettings: function() {
        if (this.cookieSettings==null) {
        	this.cookieSettings = new Series();
        }
        return this.cookieSettings;
    },

    getDimensions: function() {
        if (this.dimensions==null) {
            this.dimensions = [];
        }
        return this.dimensions;
    },

    getLocationRef: function() {
        return this.locationRef;
    },

    getProxyChallengeRequests: function() {
    	if (this.proxyChallengeRequests==null) {
    		this.proxyChallengeRequests = [];
    	}
    	return this.proxyChallengeRequests;
    },

    getRequest: function() {
        return this.request;
    },

    getRetryAfter: function() {
        return this.retryAfter;
    },

    getServerInfo: function() {
    	if (this.serverInfo==null) {
    		this.serverInfo = new data.ServerInfo();
    	}
        return this.serverInfo;
    },

    getStatus: function() {
        return this.status;
    },

    isAutoCommitting: function() {
        return this.autoCommitting;
    },

    isCommitted: function() {
        return this.committed;
    },

    isConfidential: function() {
        return this.getRequest().isConfidential();
    },

    isFinal: function() {
        return !this.getStatus().isInformational();
    },

    isProvisional: function() {
        return this.getStatus().isInformational();
    },

    redirectPermanent: function(target) {
        this.setLocationRef(target);
        this.setStatus(data.Status.REDIRECTION_PERMANENT);
        this.commit();
    },

    redirectSeeOther: function(target) {
    	this.setLocationRef(target);
    	this.setStatus(data.Status.REDIRECTION_SEE_OTHER);
        this.commit();
    },

    redirectTemporary: function(target) {
    	this.setLocationRef(target);
    	this.setStatus(data.Status.REDIRECTION_TEMPORARY);
        this.commit();
    },

    setAge: function(age) {
        this.age = age;
    },

	setAllowedMethods: function(allowedMethods) {
		this.allowedMethods = allowedMethods;
    },

    setAuthenticationInfo: function(authenticationInfo) {
        this.authenticationInfo = authenticationInfo;
    },

    setAutoCommitting: function(autoCommitting) {
        this.autoCommitting = autoCommitting;
    },

    setChallengeRequests: function(challengeRequests) {
    	this.challengeRequests = challengeRequests;
    },

    setCommitted: function(committed) {
        this.committed = committed;
    },

    setCookieSettings: function(cookieSettings) {
    	this.cookieSettings = cookieSettings;
    },

    setDimensions: function(dimensions) {
    	this.dimensions = dimensions;
    },

    _setLocationRef: function(locationRef) {
        this.locationRef = locationRef;
    },

    setLocationRef: function(location) {
    	if (typeof location == "string") {
    		var baseRef = null;

    		if (this.getRequest().getResourceRef() != null) {
    			if (this.getRequest().getResourceRef().getBaseRef() != null) {
    				baseRef = this.getRequest().getResourceRef().getBaseRef();
    			} else {
    				baseRef = this.getRequest().getResourceRef();
    			}
    		}

    		this._setLocationRef(new data.Reference(baseRef, location).getTargetRef());
    	} else {
    		this._setLocationRef(location);
    	}
    },

	setProxyChallengeRequests: function(proxyChallengeRequests) {
		this.proxyChallengeRequests = proxyChallengeRequests;
    },

    setRequest: function(request) {
        this.request = request;
    },

    setRetryAfter: function(retryAfter) {
        this.retryAfter = retryAfter;
    },

    setServerInfo: function(serverInfo) {
        this.serverInfo = serverInfo;
    },

    _setStatus: function(status) {
        this.status = status;
    },

    setStatus: function(status, description) {
    	if (arguments.length==1) {
    		var status = arguments[0];
            this._setStatus(status);
    	} else if (arguments.length==2 && arguments[0] instanceof data.Status && typeof arguments[1] == "string") {
    		var status = arguments[0];
    		var description = arguments[1];
            this._setStatus(new data.Status(status, description));
    	} else if (arguments.length==2 && arguments[0] instanceof data.Status && arguments[1] instanceof Error) {
    		var status = arguments[0];
    		var error = arguments[1];
    		this._setStatus(new data.Status(status, error));
    	} else if (arguments.length==3 && arguments[0] instanceof data.Status
    			&& arguments[1] instanceof Error && typeof arguments[2] == "string") {
    		var status = arguments[0];
    		var error = arguments[1];
    		var message = arguments[2];
    		this._setStatus(new data.Status(status, error, message));
    	}
    },
    
    /*setFirstOutboundFilter: function(firstOutboundFilter) {
    	this.firstOutboundFilter = firstOutboundFilter;
    },*/
    
    commit: function() {
    	if (arguments.length==1) {
    		var representation = arguments[0];
    		this.setEntity(representation);
    	}

    	if (this.commitCallback!=null) {
    		this.commitCallback();
    	}
    },

    setCommitCallback: function(fn) {
    	this.commitCallback = fn;
    },

    toString: function() {
        return ((this.getRequest() == null) ? "?" : this.getRequest().getProtocol())
                					+ " - " + this.getStatus();
    }
});

var Connector = new commons.Class(Restlet, {
	initialize: function(context, protocols) {
		this.context = context;
		if (typeof protocols != "undefined" && protocols!=null) {
			this.protocols = protocols;
		} else {
			this.protocols = [];
		}
	},
	getProtocols: function() {
		return this.protocols;
	},
	setProtocols: function(protocols) {
		this.protocols = protocols;
	}
});

var ChildContext = new commons.Class(Context, {
    initialize: function(parentContext) {
        this.child = null;
        this.parentContext = parentContext;
        /*this.setClientDispatcher(new ChildClientDispatcher(this));
        this.setServerDispatcher((parentContext != null) ? this.getParentContext()
                .getServerDispatcher() : null);*/
    },

    getChild: function() {
        return this.child;
    },

    getParentContext: function() {
        return this.parentContext;
    },

    setChild: function(child) {
        this.child = child;
        /*setLogger(LogUtils.getLoggerName(this.parentContext.getLogger()
                .getName(), child));*/
    }
});

var Finder = new commons.Class(Restlet, {
    initialize: function(context, targetClass) {
        this.callSuperCstr(context);
        this.targetClass = targetClass;
    },

    create: function(request, response) {
        var result = null;

        if (this.getTargetClass() != null) {
            try {
                // Invoke the default constructor
                result = new this.targetClass();
                if (this.getApplication()!=null) {
                	result.setApplication(this.getApplication());
                }
            } catch (err) {
                this.getLogger()
                        .log(Level.WARNING,
                                "Exception while instantiating the target server resource.",
                                err);
            }
        }

        return result;
    },

    find: function(request, response) {
        return this.create(request, response);
    },

    getTargetClass: function() {
        return this.targetClass;
    },

    handle: function(request, response) {
        this.callSuper("handle", request, response);

        if (this.isStarted()) {
            var targetResource = this.find(request, response);

            if (targetResource == null) {
                // If the current status is a success but we couldn't
                // find the target resource for the request's URI,
                // then we set the response status to 404 (Not Found).
                if (this.getLogger().isLoggable(Level.WARNING)) {
                    this.getLogger().warning(
                            "No target resource was defined for this finder: "
                                    + this.toString());
                }

                response.setStatus(data.Status.CLIENT_ERROR_NOT_FOUND);
                response.commit();
            } else {
                targetResource.init(this.getContext(), request, response);

                if ((response == null) || response.getStatus().isSuccess()) {
                    targetResource.handle();
                } else {
                    // Probably during the instantiation of the target
                    // server resource, or earlier the status was
                    // changed from the default one. Don't go further.
                }

                targetResource.release();
            }
        }
    },

    setTargetClass: function(targetClass) {
        this.targetClass = targetClass;
    },

    toString: function() {
        return this.getTargetClass() == null ? "Finder with no target class"
                : "Finder for " + this.getTargetClass()/*.getSimpleName()*/;
    }
});

Finder.extend({
	createFinder: function(targetClass, finderClass, context, logger) {
	    var result = null;

	    if (finderClass != null) {
	        try {
                result = new finderClass(context, targetClass);
	        } catch (err) {
	        	console.log(err.stack);
	            if (logger != null) {
	                logger.log(Level.WARNING,
	                        "Exception while instantiating the finder.", err);
	            }
	        }
	    } else {
	        result = new Finder(context, targetClass);
	    }

	    return result;
	}
});


//Headers

var HeaderConstants = new commons.Class({});

HeaderConstants.extend({
	EXPECT_CONTINUE: "100-continue",
    // --- Cache directives ---
	CACHE_NO_CACHE: "no-cache",
	CACHE_NO_STORE: "no-store",
	CACHE_MAX_AGE: "max-age",
	CACHE_MAX_STALE: "max-stale",
	CACHE_MIN_FRESH: "min-fresh",
	CACHE_NO_TRANSFORM: "no-transform",
	CACHE_ONLY_IF_CACHED: "only-if-cached",
	CACHE_PUBLIC: "public",
	CACHE_PRIVATE: "private",
	CACHE_MUST_REVALIDATE: "must-revalidate",
	CACHE_PROXY_MUST_REVALIDATE: "proxy-revalidate",
	CACHE_SHARED_MAX_AGE: "s-maxage",
	// --- Header names ---
	HEADER_ACCEPT: "Accept",
	HEADER_ACCEPT_CHARSET: "Accept-Charset",
	HEADER_ACCEPT_ENCODING: "Accept-Encoding",
	HEADER_ACCEPT_LANGUAGE: "Accept-Language",
	HEADER_ACCEPT_RANGES: "Accept-Ranges",
	HEADER_AGE: "Age",
	HEADER_ALLOW: "Allow",
	HEADER_AUTHENTICATION_INFO: "Authentication-Info",
	HEADER_AUTHORIZATION: "Authorization",
	HEADER_CACHE_CONTROL: "Cache-Control",
	HEADER_CONNECTION: "Connection",
	HEADER_CONTENT_DISPOSITION: "Content-Disposition",
	HEADER_CONTENT_ENCODING: "Content-Encoding",
	HEADER_CONTENT_LANGUAGE: "Content-Language",
	HEADER_CONTENT_LENGTH: "Content-Length",
	HEADER_CONTENT_LOCATION: "Content-Location",
	HEADER_CONTENT_MD5: "Content-MD5",
	HEADER_CONTENT_RANGE: "Content-Range",
	HEADER_CONTENT_TYPE: "Content-Type",
	HEADER_COOKIE: "Cookie",
	HEADER_DATE: "Date",
	HEADER_ETAG: "ETag",
	HEADER_EXPECT: "Expect",
	HEADER_EXPIRES: "Expires",
	HEADER_FROM: "From",
	HEADER_HOST: "Host",
	HEADER_IF_MATCH: "If-Match",
	HEADER_IF_MODIFIED_SINCE: "If-Modified-Since",
	HEADER_IF_NONE_MATCH: "If-None-Match",
	HEADER_IF_RANGE: "If-Range",
	HEADER_IF_UNMODIFIED_SINCE: "If-Unmodified-Since",
	HEADER_LAST_MODIFIED: "Last-Modified",
	HEADER_LOCATION: "Location",
	HEADER_MAX_FORWARDS: "Max-Forwards",
	HEADER_PRAGMA: "Pragma",
	HEADER_PROXY_AUTHENTICATE: "Proxy-Authenticate",
	HEADER_PROXY_AUTHORIZATION: "Proxy-Authorization",
	HEADER_RANGE: "Range",
	HEADER_REFERRER: "Referer",
	HEADER_RETRY_AFTER: "Retry-After",
	HEADER_SERVER: "Server",
	HEADER_SET_COOKIE: "Set-Cookie",
	HEADER_SET_COOKIE2: "Set-Cookie2",
	HEADER_SLUG: "Slug",
	HEADER_TRAILER: "Trailer",
	HEADER_TRANSFER_ENCODING: "Transfer-Encoding",
	HEADER_TRANSFER_EXTENSION: "TE",
	HEADER_UPGRADE: "Upgrade",
	HEADER_USER_AGENT: "User-Agent",
	HEADER_VARY: "Vary",
	HEADER_VIA: "Via",
	HEADER_WARNING: "Warning",
	HEADER_WWW_AUTHENTICATE: "WWW-Authenticate",
	HEADER_X_FORWARDED_FOR: "X-Forwarded-For",
	HEADER_X_HTTP_METHOD_OVERRIDE: "X-HTTP-Method-Override",
    // --- Attribute names ---
	ATTRIBUTE_HEADERS: "org.restlet.http.headers",
	ATTRIBUTE_VERSION: "org.restlet.http.version",
	ATTRIBUTE_HTTPS_CLIENT_CERTIFICATES: "org.restlet.https.clientCertificates",
	ATTRIBUTE_HTTPS_CIPHER_SUITE: "org.restlet.https.cipherSuite",
	ATTRIBUTE_HTTPS_KEY_SIZE: "org.restlet.https.keySize",
	ATTRIBUTE_HTTPS_SSL_SESSION_ID: "org.restlet.https.sslSessionId"
});

var Header = new commons.Class({
    initialize: function(name, value) {
        this.name = name;
        this.value = value;
    },

    equals: function(obj) {
        // if obj == this no need to go further
        var result = (obj == this);

        if (!result) {
            result = obj instanceof Header;

            // if obj isn't a header or is null don't evaluate further
            if (result) {
                var that = obj;
                result = (((that.getName() == null) && (this.getName() == null)) || ((this.getName() != null) && this.getName()
                        .equals(that.getName())));

                // if names are both null or equal continue
                if (result) {
                    result = (((that.getValue() == null) && (this.getValue() == null)) || ((this.getValue() != null) && this.getValue()
                            .equals(that.getValue())));
                }
            }
        }

        return result;
    },

    getName: function() {
        return name;
    },

    getValue: function() {
        return value;
    },

    setName: function(name) {
        this.name = name;
    },

    setValue: function(value) {
        this.value = value;
    },

    toString: function() {
        return "[" + this.getName() + ": " + this.getValue() + "]";
    }
});

var ContentType = new commons.Class({
	initialize: function(value) {
		var index = -1;
		if ((index = value.indexOf(";"))!=-1) {
			this.mediaType = new data.MediaType(value.substring(0,index));
			this.characterSet = new data.CharacterSet(value.substring(index+1));
		} else {
			this.mediaType = new data.MediaType(value);
		}
	},
	getMediaType: function() {
		return this.mediaType;
	},
	getCharacterSet: function() {
		return this.characterSet;
	} 
});

var HeaderReaderUtils = new commons.Class({});

HeaderReaderUtils.extend({
	
});

var HeaderWriterUtils = new commons.Class({});

HeaderWriterUtils.extend({
	
});

var HeaderUtils = new commons.Class({});

HeaderUtils.extend({
	addEntityHeaders: function(entity, headers) {
        if (entity == null || !entity.isAvailable()) {
        	HeaderUtils.addHeader(HeaderConstants.HEADER_CONTENT_LENGTH, "0", headers);
        } else if (entity.getAvailableSize() != representation.Representation.UNKNOWN_SIZE) {
        	HeaderUtils.addHeader(HeaderConstants.HEADER_CONTENT_LENGTH,
                    entity.getAvailableSize().toString(), headers);
        }

        if (entity != null) {
        	HeaderUtils.addHeader(HeaderConstants.HEADER_CONTENT_ENCODING,
        			EncodingWriter.write(entity.getEncodings()), headers);
        	HeaderUtils.addHeader(HeaderConstants.HEADER_CONTENT_LANGUAGE,
        			LanguageWriter.write(entity.getLanguages()), headers);

            if (entity.getLocationRef() != null) {
            	HeaderUtils.addHeader(HeaderConstants.HEADER_CONTENT_LOCATION, entity
                        .getLocationRef().getTargetRef().toString(), headers);
            }

            if (entity.getRange() != null) {
            	HeaderUtils.addHeader(HeaderConstants.HEADER_CONTENT_RANGE,
            			RangeWriter.write(entity.getRange(), entity.getSize()),
                        headers);
            }

            if (entity.getMediaType() != null) {
                var contentType = entity.getMediaType().toString();
 
                // Specify the character set parameter if required
                if ((entity.getMediaType().getParameters()
                        .getFirstValue("charset") == null)
                        && (entity.getCharacterSet() != null)) {
                    contentType = contentType + "; charset="
                            + entity.getCharacterSet().getName();
                }

                HeaderUtils.addHeader(HeaderConstants.HEADER_CONTENT_TYPE, contentType,
                        headers);
            }

            if (entity.getExpirationDate() != null) {
            	HeaderUtils.addHeader(HeaderConstants.HEADER_EXPIRES,
            			DateWriter.write(entity.getExpirationDate()), headers);
            }

            if (entity.getModificationDate() != null) {
            	HeaderUtils.addHeader(HeaderConstants.HEADER_LAST_MODIFIED,
            			DateWriter.write(entity.getModificationDate()), headers);
            }

            if (entity.getTag() != null) {
            	HeaderUtils.addHeader(HeaderConstants.HEADER_ETAG,
            			TagWriter.write(entity.getTag()), headers);
            }

            if (entity.getDisposition() != null
                    && !Disposition.TYPE_NONE.equals(entity.getDisposition()
                            .getType())) {
            	HeaderUtils.addHeader(HeaderConstants.HEADER_CONTENT_DISPOSITION,
            			DispositionWriter.writeObject(entity.getDisposition()),
                        headers);
            }
        }
	},
	addExtensionHeaders: function(existingHeaders, additionalHeaders) {
        if (additionalHeaders != null) {
        	var elements = additionalHeaders.getElements();
            for (var cpt=0;cpt<elements.length;cpt++) {
            	var param = elements[cpt];
                if (param.getName().equalsIgnoreCase(
                        HeaderConstants.HEADER_ACCEPT)
                        || param.getName().equalsIgnoreCase(
                                HeaderConstants.HEADER_ACCEPT_CHARSET)
                        || param.getName().equalsIgnoreCase(
                                HeaderConstants.HEADER_ACCEPT_ENCODING)
                        || param.getName().equalsIgnoreCase(
                                HeaderConstants.HEADER_ACCEPT_LANGUAGE)
                        || param.getName().equalsIgnoreCase(
                                HeaderConstants.HEADER_ACCEPT_RANGES)
                        || param.getName().equalsIgnoreCase(
                                HeaderConstants.HEADER_AGE)
                        || param.getName().equalsIgnoreCase(
                                HeaderConstants.HEADER_ALLOW)
                        || param.getName().equalsIgnoreCase(
                                HeaderConstants.HEADER_AUTHENTICATION_INFO)
                        || param.getName().equalsIgnoreCase(
                                HeaderConstants.HEADER_AUTHORIZATION)
                        || param.getName().equalsIgnoreCase(
                                HeaderConstants.HEADER_CACHE_CONTROL)
                        || param.getName().equalsIgnoreCase(
                                HeaderConstants.HEADER_CONNECTION)
                        || param.getName().equalsIgnoreCase(
                                HeaderConstants.HEADER_CONTENT_DISPOSITION)
                        || param.getName().equalsIgnoreCase(
                                HeaderConstants.HEADER_CONTENT_ENCODING)
                        || param.getName().equalsIgnoreCase(
                                HeaderConstants.HEADER_CONTENT_LANGUAGE)
                        || param.getName().equalsIgnoreCase(
                                HeaderConstants.HEADER_CONTENT_LENGTH)
                        || param.getName().equalsIgnoreCase(
                                HeaderConstants.HEADER_CONTENT_LOCATION)
                        || param.getName().equalsIgnoreCase(
                                HeaderConstants.HEADER_CONTENT_MD5)
                        || param.getName().equalsIgnoreCase(
                                HeaderConstants.HEADER_CONTENT_RANGE)
                        || param.getName().equalsIgnoreCase(
                                HeaderConstants.HEADER_CONTENT_TYPE)
                        || param.getName().equalsIgnoreCase(
                                HeaderConstants.HEADER_COOKIE)
                        || param.getName().equalsIgnoreCase(
                                HeaderConstants.HEADER_DATE)
                        || param.getName().equalsIgnoreCase(
                                HeaderConstants.HEADER_ETAG)
                        || param.getName().equalsIgnoreCase(
                                HeaderConstants.HEADER_EXPECT)
                        || param.getName().equalsIgnoreCase(
                                HeaderConstants.HEADER_EXPIRES)
                        || param.getName().equalsIgnoreCase(
                                HeaderConstants.HEADER_FROM)
                        || param.getName().equalsIgnoreCase(
                                HeaderConstants.HEADER_HOST)
                        || param.getName().equalsIgnoreCase(
                                HeaderConstants.HEADER_IF_MATCH)
                        || param.getName().equalsIgnoreCase(
                                HeaderConstants.HEADER_IF_MODIFIED_SINCE)
                        || param.getName().equalsIgnoreCase(
                                HeaderConstants.HEADER_IF_NONE_MATCH)
                        || param.getName().equalsIgnoreCase(
                                HeaderConstants.HEADER_IF_RANGE)
                        || param.getName().equalsIgnoreCase(
                                HeaderConstants.HEADER_IF_UNMODIFIED_SINCE)
                        || param.getName().equalsIgnoreCase(
                                HeaderConstants.HEADER_LAST_MODIFIED)
                        || param.getName().equalsIgnoreCase(
                                HeaderConstants.HEADER_LOCATION)
                        || param.getName().equalsIgnoreCase(
                                HeaderConstants.HEADER_MAX_FORWARDS)
                        || param.getName().equalsIgnoreCase(
                                HeaderConstants.HEADER_PROXY_AUTHENTICATE)
                        || param.getName().equalsIgnoreCase(
                                HeaderConstants.HEADER_PROXY_AUTHORIZATION)
                        || param.getName().equalsIgnoreCase(
                                HeaderConstants.HEADER_RANGE)
                        || param.getName().equalsIgnoreCase(
                                HeaderConstants.HEADER_REFERRER)
                        || param.getName().equalsIgnoreCase(
                                HeaderConstants.HEADER_RETRY_AFTER)
                        || param.getName().equalsIgnoreCase(
                                HeaderConstants.HEADER_SERVER)
                        || param.getName().equalsIgnoreCase(
                                HeaderConstants.HEADER_SET_COOKIE)
                        || param.getName().equalsIgnoreCase(
                                HeaderConstants.HEADER_SET_COOKIE2)
                        || param.getName().equalsIgnoreCase(
                                HeaderConstants.HEADER_USER_AGENT)
                        || param.getName().equalsIgnoreCase(
                                HeaderConstants.HEADER_VARY)
                        || param.getName().equalsIgnoreCase(
                                HeaderConstants.HEADER_VIA)
                        || param.getName().equalsIgnoreCase(
                                HeaderConstants.HEADER_WARNING)
                        || param.getName().equalsIgnoreCase(
                                HeaderConstants.HEADER_WWW_AUTHENTICATE)) {
                    // Standard headers that can't be overridden
                    Context.getCurrentLogger()
                            .warning(
                                    "Addition of the standard header \""
                                            + param.getName()
                                            + "\" is not allowed. Please use the equivalent property in the Restlet API.");
                } else if (param.getName().equalsIgnoreCase(
                        HeaderConstants.HEADER_PRAGMA)
                        || param.getName().equalsIgnoreCase(
                                HeaderConstants.HEADER_TRAILER)
                        || param.getName().equalsIgnoreCase(
                                HeaderConstants.HEADER_TRANSFER_ENCODING)
                        || param.getName().equalsIgnoreCase(
                                HeaderConstants.HEADER_TRANSFER_EXTENSION)
                        || param.getName().equalsIgnoreCase(
                                HeaderConstants.HEADER_UPGRADE)) {
                    // Standard headers that shouldn't be overridden
                    Context.getCurrentLogger()
                            .info("Addition of the standard header \""
                                    + param.getName()
                                    + "\" is discouraged as a future version of the Restlet API will directly support it.");
                    existingHeaders.push(param);
                } else {
                    existingHeaders.push(param);
                }
            }
        }
	},
	addGeneralHeaders: function(message, headers) {
		HeaderUtils.addHeader(HeaderConstants.HEADER_CACHE_CONTROL,
				CacheDirectiveWriter.write(message.getCacheDirectives()),
                headers);
        if (message.getDate() == null) {
            message.setDate(new Date());
        }
        HeaderUtils.addHeader(HeaderConstants.HEADER_DATE,
        		DateWriter.write(message.getDate()), headers);
        HeaderUtils.addHeader(HeaderConstants.HEADER_VIA,
        		RecipientInfoWriter.write(message.getRecipientsInfo()), headers);
        HeaderUtils.addHeader(HeaderConstants.HEADER_WARNING,
        		WarningWriter.write(message.getWarnings()), headers);
	},
	addHeader: function(headerName, headerValue, headers) {
        if ((headerName != null) && (headerValue != null)
                && (headerValue.length > 0)) {
            try {
                headers.add(new data.Parameter(headerName, headerValue));
            } catch (err) {
                Context.getCurrentLogger().log(Level.WARNING,
                        "Unable to format the " + headerName + " header", err);
            }
        }
	},
	addNotModifiedEntityHeaders: function(entity, headers) {
        if (entity != null) {
            if (entity.getTag() != null) {
                HeaderUtils.addHeader(HeaderConstants.HEADER_ETAG,
                		TagWriter.write(entity.getTag()), headers);
            }

            if (entity.getLocationRef() != null) {
                HeaderUtils.addHeader(HeaderConstants.HEADER_CONTENT_LOCATION,
                        entity.getLocationRef().getTargetRef().toString(),
                        headers);
            }
        }
	},
	addRequestHeaders: function(request, headers) {
        var clientInfo = request.getClientInfo();
        
        if (!clientInfo.getAcceptedMediaTypes().isEmpty()) {
        	HeaderUtils.addHeader(HeaderConstants.HEADER_ACCEPT,
        			PreferenceWriter.write(clientInfo.getAcceptedMediaTypes()),
                    headers);
        } else {
        	HeaderUtils.addHeader(HeaderConstants.HEADER_ACCEPT, data.MediaType.ALL.getName(),
                    headers);
        }

        if (!clientInfo.getAcceptedCharacterSets().isEmpty()) {
        	HeaderUtils.addHeader(HeaderConstants.HEADER_ACCEPT_CHARSET,
        			PreferenceWriter.write(clientInfo
                            .getAcceptedCharacterSets()), headers);
        }

        if (!clientInfo.getAcceptedEncodings().isEmpty()) {
        	HeaderUtils.addHeader(HeaderConstants.HEADER_ACCEPT_ENCODING,
        			PreferenceWriter.write(clientInfo.getAcceptedEncodings()),
                    headers);
        }

        if (!clientInfo.getAcceptedLanguages().isEmpty()) {
        	HeaderUtils.addHeader(HeaderConstants.HEADER_ACCEPT_LANGUAGE,
        			PreferenceWriter.write(clientInfo.getAcceptedLanguages()),
                    headers);
        }

        if (clientInfo.getFrom() != null) {
        	HeaderUtils.addHeader(HeaderConstants.HEADER_FROM, request.getClientInfo()
                    .getFrom(), headers);
        }

        // Manually add the host name and port when it is potentially
        // different from the one specified in the target resource reference.
        /*var hostRef = (request.getResourceRef().getBaseRef() != null) ? request
                .getResourceRef().getBaseRef() : request.getResourceRef();
                
        console.log("hostRef = "+hostRef);

        if (hostRef.getHostDomain() != null) {
            var host = hostRef.getHostDomain();
            var hostRefPortValue = hostRef.getHostPort();

            if ((hostRefPortValue != -1)
                    && (hostRefPortValue != request.getProtocol()
                            .getDefaultPort())) {
                host = host + ':' + hostRefPortValue;
            }

            HeaderUtils.addHeader(HeaderConstants.HEADER_HOST, host, headers);
        }*/

        var conditions = request.getConditions();
        HeaderUtils.addHeader(HeaderConstants.HEADER_IF_MATCH,
        		TagWriter.write(conditions.getMatch()), headers);
        HeaderUtils.addHeader(HeaderConstants.HEADER_IF_NONE_MATCH,
        		TagWriter.write(conditions.getNoneMatch()), headers);

        if (conditions.getModifiedSince() != null) {
        	HeaderUtils.addHeader(HeaderConstants.HEADER_IF_MODIFIED_SINCE,
        			DateWriter.write(conditions.getModifiedSince()), headers);
        }

        if (conditions.getRangeTag() != null
                && conditions.getRangeDate() != null) {
            Context.getCurrentLogger()
                    .log(Level.WARNING,
                            "Unable to format the HTTP If-Range header due to the presence of both entity tag and modification date.");
        } else if (conditions.getRangeTag() != null) {
        	HeaderUtils.addHeader(HeaderConstants.HEADER_IF_RANGE,
        			TagWriter.write(conditions.getRangeTag()), headers);
        } else if (conditions.getRangeDate() != null) {
        	HeaderUtils.addHeader(HeaderConstants.HEADER_IF_RANGE,
        			DateWriter.write(conditions.getRangeDate()), headers);
        }

        if (conditions.getUnmodifiedSince() != null) {
        	HeaderUtils.addHeader(HeaderConstants.HEADER_IF_UNMODIFIED_SINCE,
        			DateWriter.write(conditions.getUnmodifiedSince()), headers);
        }

        if (request.getMaxForwards() > -1) {
        	HeaderUtils.addHeader(HeaderConstants.HEADER_MAX_FORWARDS,
                    request.getMaxForwards().toString(), headers);
        }

        if (!request.getRanges().isEmpty()) {
        	HeaderUtils.addHeader(HeaderConstants.HEADER_RANGE,
        			RangeWriter.write(request.getRanges()), headers);
        }

        if (request.getReferrerRef() != null) {
        	HeaderUtils.addHeader(HeaderConstants.HEADER_REFERRER, request.getReferrerRef()
                    .toString(), headers);
        }

        if (request.getClientInfo().getAgent() != null) {
        	HeaderUtils.addHeader(HeaderConstants.HEADER_USER_AGENT, request
                    .getClientInfo().getAgent(), headers);
        } else {
        	HeaderUtils.addHeader(HeaderConstants.HEADER_USER_AGENT, Engine.VERSION_HEADER,
                    headers);
        }

        // ----------------------------------
        // 3) Add supported extension headers
        // ----------------------------------

        if (request.getCookies().size() > 0) {
        	HeaderUtils.addHeader(HeaderConstants.HEADER_COOKIE,
        			CookieWriter.writeCollection(request.getCookies()), headers);
        }

        // -------------------------------------
        // 4) Add user-defined extension headers
        // -------------------------------------
        var additionalHeaders = request
                .getAttributes()[HeaderConstants.ATTRIBUTE_HEADERS];
        HeaderUtils.addExtensionHeaders(headers, additionalHeaders);

        // ---------------------------------------
        // 5) Add authorization headers at the end
        // ---------------------------------------

        // Add the security headers. NOTE: This must stay at the end because
        // the AWS challenge scheme requires access to all HTTP headers
        /*ChallengeResponse challengeResponse = request.getChallengeResponse();
        if (challengeResponse != null) {
            this.addHeader(
                    HeaderConstants.HEADER_AUTHORIZATION,
                    AuthenticatorUtils
                            .formatResponse(challengeResponse, request, headers),
                    headers);
        }

        ChallengeResponse proxyChallengeResponse = request
                .getProxyChallengeResponse();
        if (proxyChallengeResponse != null) {
            addHeader(HeaderConstants.HEADER_PROXY_AUTHORIZATION,
                    AuthenticatorUtils
                            .formatResponse(proxyChallengeResponse, request,
                                    headers), headers);
        }*/
	},
	addResponseHeaders: function(response, headers) {
        if (response.getServerInfo().isAcceptingRanges()) {
        	HeaderUtils.addHeader(HeaderConstants.HEADER_ACCEPT_RANGES, "bytes", headers);
        }

        if (response.getAge() > 0) {
        	HeaderUtils.addHeader(HeaderConstants.HEADER_AGE,
                    	response.getAge().toString(), headers);
        }

        if (response.getStatus().equals(data.Status.CLIENT_ERROR_METHOD_NOT_ALLOWED)
                || data.Method.OPTIONS.equals(response.getRequest().getMethod())) {
        	HeaderUtils.addHeader(HeaderConstants.HEADER_ALLOW,
        			MethodWriter.write(response.getAllowedMethods()), headers);
        }

        /*if (response.getLocationRef() != null) {
            // The location header must contain an absolute URI.
        	HeaderUtils.addHeader(HeaderConstants.HEADER_LOCATION, response
                    .getLocationRef().getTargetRef().toString(), headers);
        }*/

        //TODO:
        /*if (response.getProxyChallengeRequests() != null) {
            for (ChallengeRequest challengeRequest : response
                    .getProxyChallengeRequests()) {
                addHeader(HeaderConstants.HEADER_PROXY_AUTHENTICATE,
                        org.restlet.engine.security.AuthenticatorUtils
                                .formatRequest(challengeRequest, response,
                                        headers), headers);
            }
        }*/

        if (response.getRetryAfter() != null) {
        	HeaderUtils.addHeader(HeaderConstants.HEADER_RETRY_AFTER,
        			DateWriter.write(response.getRetryAfter()), headers);
        }

        if ((response.getServerInfo() != null)
                && (response.getServerInfo().getAgent() != null)) {
        	HeaderUtils.addHeader(HeaderConstants.HEADER_SERVER, response.getServerInfo()
                    .getAgent(), headers);
        } else {
        	HeaderUtils.addHeader(HeaderConstants.HEADER_SERVER, Engine.VERSION_HEADER,
                    headers);
        }

        // Send the Vary header only to none-MSIE user agents as MSIE seems
        // to support partially and badly this header (cf issue 261).
        if (!((response.getRequest().getClientInfo().getAgent() != null) && response
                .getRequest().getClientInfo().getAgent().contains("MSIE"))) {
            // Add the Vary header if content negotiation was used
        	HeaderUtils.addHeader(HeaderConstants.HEADER_VARY,
        			DimensionWriter.write(response.getDimensions()), headers);
        }

        // Set the security data
        //TODO:
        /*if (response.getChallengeRequests() != null) {
            for (ChallengeRequest challengeRequest : response
                    .getChallengeRequests()) {
                addHeader(HeaderConstants.HEADER_WWW_AUTHENTICATE,
                        org.restlet.engine.security.AuthenticatorUtils
                                .formatRequest(challengeRequest, response,
                                        headers), headers);
            }
        }*/

        // ----------------------------------
        // 3) Add supported extension headers
        // ----------------------------------

        // Add the Authentication-Info header
        /*if (response.getAuthenticationInfo() != null) {
        	HeaderUtils.addHeader(HeaderConstants.HEADER_AUTHENTICATION_INFO,
                    org.restlet.engine.security.AuthenticatorUtils
                            .formatAuthenticationInfo(response
                                    .getAuthenticationInfo()), headers);
        }*/

        // Cookies settings should be written in a single header, but Web
        // browsers does not seem to support it.
        //TODO:
        /*for (CookieSetting cookieSetting : response.getCookieSettings()) {
        	HeaderUtils.addHeader(HeaderConstants.HEADER_SET_COOKIE,
                    CookieSettingWriter.write(cookieSetting), headers);
        }*/

        // -------------------------------------
        // 4) Add user-defined extension headers
        // -------------------------------------

        var additionalHeaders = response
                .getAttributes()[HeaderConstants.ATTRIBUTE_HEADERS];
        HeaderUtils.addExtensionHeaders(headers, additionalHeaders);
	},
	extractEntityHeaders: function(headers, representation) {
	    var result = (representation == null) ? new EmptyRepresentation()
	            : representation;
	    var entityHeaderFound = false;
	
	    if (headers != null) {
	        for (var cpt = 0; cpt<headers.length; cpt++) {
	        	var header = headers[cpt];
	            if (header.getName().equalsIgnoreCase(
	                    HeaderConstants.HEADER_CONTENT_TYPE)) {
	                var contentType = new ContentType(header.getValue());
	                result.setMediaType(contentType.getMediaType());
	
	                if ((result.getCharacterSet() == null)
	                        || (contentType.getCharacterSet() != null)) {
	                    result.setCharacterSet(contentType.getCharacterSet());
	                }
	
	                entityHeaderFound = true;
	            } else if (header.getName().equalsIgnoreCase(
	                    HeaderConstants.HEADER_CONTENT_LENGTH)) {
	                entityHeaderFound = true;
	            } else if (header.getName().equalsIgnoreCase(
	                    HeaderConstants.HEADER_EXPIRES)) {
	                result.setExpirationDate(HeaderReader.readDate(
	                        header.getValue(), false));
	                entityHeaderFound = true;
	            } else if (header.getName().equalsIgnoreCase(
	                    HeaderConstants.HEADER_CONTENT_ENCODING)) {
	                new EncodingReader(header.getValue()).addValues(result
	                        .getEncodings());
	                entityHeaderFound = true;
	            } else if (header.getName().equalsIgnoreCase(
	                    HeaderConstants.HEADER_CONTENT_LANGUAGE)) {
	                new LanguageReader(header.getValue()).addValues(result
	                        .getLanguages());
	                entityHeaderFound = true;
	            } else if (header.getName().equalsIgnoreCase(
	                    HeaderConstants.HEADER_LAST_MODIFIED)) {
	                result.setModificationDate(HeaderReader.readDate(
	                        header.getValue(), false));
	                entityHeaderFound = true;
	            } else if (header.getName().equalsIgnoreCase(
	                    HeaderConstants.HEADER_ETAG)) {
	                result.setTag(data.Tag.parse(header.getValue()));
	                entityHeaderFound = true;
	            } else if (header.getName().equalsIgnoreCase(
	                    HeaderConstants.HEADER_CONTENT_LOCATION)) {
	                result.setLocationRef(header.getValue());
	                entityHeaderFound = true;
	            } else if (header.getName().equalsIgnoreCase(
	                    HeaderConstants.HEADER_CONTENT_DISPOSITION)) {
	                /*try {
	                    result.setDisposition(new DispositionReader(header
	                            .getValue()).readValue());
	                    entityHeaderFound = true;
	                } catch (IOException ioe) {
	                    Context.getCurrentLogger().log(
	                            Level.WARNING,
	                            "Error during Content-Disposition header parsing. Header: "
	                                    + header.getValue(), ioe);
	                }*/
	            } else if (header.getName().equalsIgnoreCase(
	                    HeaderConstants.HEADER_CONTENT_RANGE)) {
	                /*org.restlet.engine.header.RangeReader.update(
	                        header.getValue(), result);*/
	                entityHeaderFound = true;
	            } else if (header.getName().equalsIgnoreCase(
	                    HeaderConstants.HEADER_CONTENT_MD5)) {
	                /*result.setDigest(new org.restlet.data.Digest(
	                        org.restlet.data.Digest.ALGORITHM_MD5,
	                        org.restlet.engine.util.Base64.decode(header
	                                .getValue())));*/
	                entityHeaderFound = true;
	            }
	        }
	    }
	
	    // If no representation was initially expected and no entity header
	    // is found, then do not return any representation
	    if ((representation == null) && !entityHeaderFound) {
	        result = null;
	    }
	
	    return result;
	},
	copyResponseTransportHeaders: function(headers, response) {
		if (headers != null) {
            for (var cpt=0; cpt<headers.length; cpt++) {
            	var header = headers[cpt]; 
                if (header.getName().equalsIgnoreCase(
                        HeaderConstants.HEADER_LOCATION)) {
                    response.setLocationRef(header.getValue());
                } else if (header.getName().equalsIgnoreCase(
                        HeaderConstants.HEADER_AGE)) {
                    try {
                        response.setAge(parseInt(header.getValue()));
                    } catch (err) {
                        Context.getCurrentLogger().log(
                                Level.WARNING,
                                "Error during Age header parsing. Header: "
                                        + header.getValue(), err);
                    }
                } else if (header.getName().equalsIgnoreCase(
                        HeaderConstants.HEADER_DATE)) {
                    var date = DateUtils.parse(header.getValue());

                    if (date == null) {
                        date = new Date();
                    }

                    response.setDate(date);
                /*} else if (header.getName().equalsIgnoreCase(
                        HeaderConstants.HEADER_RETRY_AFTER)) {
                    Date retryAfter = DateUtils.parse(header.getValue());

                    if (retryAfter == null) {
                        // The date might be expressed as a number of seconds
                        try {
                            int retryAfterSecs = Integer.parseInt(header
                                    .getValue());
                            java.util.Calendar calendar = java.util.Calendar
                                    .getInstance();
                            calendar.add(java.util.Calendar.SECOND,
                                    retryAfterSecs);
                            retryAfter = calendar.getTime();
                        } catch (NumberFormatException nfe) {
                            Context.getCurrentLogger().log(
                                    Level.WARNING,
                                    "Error during Retry-After header parsing. Header: "
                                            + header.getValue(), nfe);
                        }
                    }

                    response.setRetryAfter(retryAfter);
                } else if ((header.getName()
                        .equalsIgnoreCase(HeaderConstants.HEADER_SET_COOKIE))
                        || (header.getName()
                                .equalsIgnoreCase(HeaderConstants.HEADER_SET_COOKIE2))) {
                    try {
                        CookieSettingReader cr = new CookieSettingReader(
                                header.getValue());
                        response.getCookieSettings().add(cr.readValue());
                    } catch (Exception e) {
                        Context.getCurrentLogger().log(
                                Level.WARNING,
                                "Error during cookie setting parsing. Header: "
                                        + header.getValue(), e);
                    }
                } else if (header.getName().equalsIgnoreCase(
                        HeaderConstants.HEADER_WWW_AUTHENTICATE)) {
                    List<ChallengeRequest> crs = org.restlet.engine.security.AuthenticatorUtils
                            .parseRequest(response, header.getValue(), headers);
                    response.getChallengeRequests().addAll(crs);
                } else if (header.getName().equalsIgnoreCase(
                        HeaderConstants.HEADER_PROXY_AUTHENTICATE)) {
                    List<ChallengeRequest> crs = org.restlet.engine.security.AuthenticatorUtils
                            .parseRequest(response, header.getValue(), headers);
                    response.getProxyChallengeRequests().addAll(crs);
                } else if (header.getName().equalsIgnoreCase(
                        HeaderConstants.HEADER_AUTHENTICATION_INFO)) {
                    AuthenticationInfo authenticationInfo = org.restlet.engine.security.AuthenticatorUtils
                            .parseAuthenticationInfo(header.getValue());
                    response.setAuthenticationInfo(authenticationInfo);
                    // [enddef]*/
                } else if (header.getName().equalsIgnoreCase(
                        HeaderConstants.HEADER_SERVER)) {
                    response.getServerInfo().setAgent(header.getValue());
                /*} else if (header.getName().equalsIgnoreCase(
                        HeaderConstants.HEADER_ALLOW)) {
                    MethodReader
                            .addValues(header, response.getAllowedMethods());*/
                } else if (header.getName().equalsIgnoreCase(
                        HeaderConstants.HEADER_VARY)) {
                    DimensionReader.addValues(header, response.getDimensions());
                /*} else if (header.getName().equalsIgnoreCase(
                        HeaderConstants.HEADER_VIA)) {
                    RecipientInfoReader.addValues(header,
                            response.getRecipientsInfo());
                } else if (header.getName().equalsIgnoreCase(
                        HeaderConstants.HEADER_WARNING)) {
                    WarningReader.addValues(header, response.getWarnings());
                } else if (header.getName().equalsIgnoreCase(
                        HeaderConstants.HEADER_CACHE_CONTROL)) {
                    CacheDirectiveReader.addValues(header,
                            response.getCacheDirectives());
                } else if (header.getName().equalsIgnoreCase(
                        HeaderConstants.HEADER_ACCEPT_RANGES)) {
                    TokenReader tr = new TokenReader(header.getValue());
                    response.getServerInfo().setAcceptingRanges(
                            tr.readValues().contains("bytes"));*/
                }
            }
        }
	},
	getContentLength: function(headers) {
        var contentLength = representation.Representation.UNKNOWN_SIZE;

        if (headers != null) {
            // Extract the content length header
            for (var cpt=0; cpt<headers.length; cpt++) {
            	var header = headers[cpt]
                if (header.getName().equalsIgnoreCase(
                        HeaderConstants.HEADER_CONTENT_LENGTH)) {
                    try {
                        contentLength = parseFloat(header.getValue());
                    } catch (err) {
                        contentLength = representation.Representation.UNKNOWN_SIZE;
                    }
                }
            }
        }

        return contentLength;
	},
	getCharacterCode: function(character) {
    	return character.charCodeAt(0);
	},
    isAlpha: function(character) {
    	if (character==-1) {
    		return false;
    	}
        return HeaderUtils.isUpperCase(character)
        			|| HeaderUtils.isLowerCase(character);
    },
    isAsciiChar: function(character) {
    	if (character==-1) {
    		return false;
    	}
    	var code = HeaderUtils.getCharacterCode(character);
        return (code >= 0) && (code <= 127);
    },
    isCarriageReturn: function(character) {
    	if (character==-1) {
    		return false;
    	}
    	var code = HeaderUtils.getCharacterCode(character);
        return (code == 13);
    },
    isChunkedEncoding: function(headers) {
        var result = false;

        if (headers != null) {
            var header = headers.getFirstValue(
                    HeaderConstants.HEADER_TRANSFER_ENCODING, true);
            result = "chunked".equalsIgnoreCase(header);
        }

        return result;
    },
    isComma: function(character) {
    	if (character==-1) {
    		return false;
    	}
        return (character == ',');
    },
    isCommentText: function(character) {
    	if (character==-1) {
    		return false;
    	}
        return HeaderUtils.isText(character) && (character != '(') && (character != ')');
    },
    isConnectionClose: function(headers) {
        var result = false;

        if (headers != null) {
            var header = headers.getFirstValue(
                    HeaderConstants.HEADER_CONNECTION, true);
            result = "close".equalsIgnoreCase(header);
        }

        return result;
    },
    isControlChar: function(character) {
    	if (character==-1) {
    		return false;
    	}
    	var code = HeaderUtils.getCharacterCode(character);
        return ((code >= 0) && (code <= 31)) || (code == 127);
    },
    isDigit: function(character) {
    	if (character==-1) {
    		return false;
    	}
        return (character >= '0') && (character <= '9');
    },
    isDoubleQuote: function(character) {
    	if (character==-1) {
    		return false;
    	}
    	var code = HeaderUtils.getCharacterCode(character);
        return (code == 34);
    },
    isHorizontalTab: function(character) {
    	if (character==-1) {
    		return false;
    	}
        return (character == 9);
    },
    isLatin1Char: function(character) {
    	if (character==-1) {
    		return false;
    	}
    	var code = HeaderUtils.getCharacterCode(character);
        return (code >= 0) && (code <= 255);
    },
    isLinearWhiteSpace: function(character) {
    	if (character==-1) {
    		return false;
    	}
        return (HeaderUtils.isCarriageReturn(character)
        		|| HeaderUtils.isSpace(character)
                || HeaderUtils.isLineFeed(character)
                || HeaderUtils.isHorizontalTab(character));
    },
    isLineFeed: function(character) {
    	if (character==-1) {
    		return false;
    	}
    	var code = HeaderUtils.getCharacterCode(character);
        return (code == 10);
    },
    isLowerCase: function(character) {
    	if (character==-1) {
    		return false;
    	}
        return (character >= 'a') && (character <= 'z');
    },
    isQuoteCharacter: function(character) {
    	if (character==-1) {
    		return false;
    	}
        return (character == '\\');
    },
    isQuotedText: function(character) {
    	if (character==-1) {
    		return false;
    	}
        return HeaderUtils.isText(character) && !HeaderUtils.isDoubleQuote(character);
    },
    isSemiColon: function(character) {
    	if (character==-1) {
    		return false;
    	}
        return (character == ';');
    },
    isSeparator: function(character) {
    	if (character==-1) {
    		return false;
    	}
        switch (character) {
        case '(':
        case ')':
        case '<':
        case '>':
        case '@':
        case ',':
        case ';':
        case ':':
        case '\\':
        case '"':
        case '/':
        case '[':
        case ']':
        case '?':
        case '=':
        case '{':
        case '}':
        case ' ':
        case '\t':
            return true;

        default:
            return false;
        }
    },
    isSpace: function(character) {
    	if (character==-1) {
    		return false;
    	}
    	var code = HeaderUtils.getCharacterCode(character);
        return (code == 32);
    },
    isText: function(character) {
    	if (character==-1) {
    		return false;
    	}
        return HeaderUtils.isLatin1Char(character)
        		&& !HeaderUtils.isControlChar(character);
    },
    isToken: function(token) {
    	if (character==-1) {
    		return false;
    	}
        for (var i = 0; i < token.length; i++) {
            if (!HeaderUtils.isTokenChar(token.charAt(i))) {
                return false;
            }
        }

        return true;
    },
    isTokenChar: function(character) {
    	if (character==-1) {
    		return false;
    	}
        return HeaderUtils.isAsciiChar(character)
        		&& !HeaderUtils.isSeparator(character);
    },
    isUpperCase: function(character) {
    	if (character==-1) {
    		return false;
    	}
        return (character >= 'A') && (character <= 'Z');
    }
});

var HeaderReader = new commons.Class({
	initialize: function(header) {
        this.header = header;
        this.index = ((header == null) || (header.length == 0)) ? -1 : 0;
        this.mark = this.index;
	},
    addValues: function(values) {
        try {
            // Skip leading spaces
        	this.skipSpaces();

            do {
                // Read the first value
                var nextValue = this.readValue();
                if (this.canAdd(nextValue, values)) {
                    // Add the value to the list
                    values.push(nextValue);
                }

                // Attempt to skip the value separator
                this.skipValueSeparator();
            } while (this.peek() != -1);
        } catch (err) {
        	console.log(err.stack);
            Context.getCurrentLogger().log(Level.INFO,
                    "Unable to read a header", err);
        }
    },
    canAdd: function(value, values) {
        if (value!=null) {
        	for (var cpt=0;cpt<values.length;cpt++) {
        		if (values[cpt]==value) {
        			return false;
        		}
        	}
        }
        return true;
    },
    createParameter: function(name, value) {
        return new Parameter(name, value);
    },
    mark: function() {
        this.mark = this.index;
    },
    peek: function() {
        var result = -1;

        if (this.index != -1) {
            result = this.header.charAt(this.index);
        }

        return result;
    },
    read: function() {
        var result = -1;

        if (this.index >= 0) {
            result = this.header.charAt(this.index++);

            if (this.index >= this.header.length) {
                this.index = -1;
            }
        }
        return result;
    },
    readComment: function() {
        var result = null;
        var next = this.read();

        // First character must be a parenthesis
        if (next == '(') {
            var buffer = new commons.StringBuilder();

            while (result == null) {
                next = this.read();

                if (HeaderUtils.isCommentText(next)) {
                    buffer.append(next);
                } else if (HeaderUtils.isQuoteCharacter(next)) {
                    // Start of a quoted pair (escape sequence)
                    buffer.append(this.read());
                } else if (next == '(') {
                    // Nested comment
                    buffer.append('(').append(this.readComment()).append(')');
                } else if (next == ')') {
                    // End of comment
                    result = buffer.toString();
                } else if (next == -1) {
                    throw new Error(
                            "Unexpected end of comment. Please check your value");
                } else {
                    throw new Error("Invalid character \"" + next
                            + "\" detected in comment. Please check your value");
                }
            }
        } else {
            throw new Error("A comment must start with a parenthesis");
        }

        return result;
    },
    readDigits: function() {
        var sb = new commons.StringBuilder();
        var next = this.read();

        while (HeaderUtils.isTokenChar(next)) {
            sb.append(next);
            next = this.read();
        }

        // Unread the last character (separator or end marker)
        this.unread();

        return sb.toString();
    },
    readNamedValue: function(resultClass) {
    	var result = null;
    	var name = this.readToken();
    	var nextChar = this.read();

    	if (name.length > 0) {
    		if (nextChar == '=') {
    			// The parameter has a value
    			result = HeaderReader.createNamedValue(resultClass, name,
    					this.readActualNamedValue());
    		} else {
    			// The parameter has not value
    			this.unread();
    			result = HeaderReader.createNamedValue(resultClass, name);
    		}
    	} else {
    		throw new Error(
    			"Parameter or extension has no name. Please check your value");
    	}

    	return result;
    },
    readParameter: function() {
        var result = null;
        var name = this.readToken();
        var nextChar = this.read();

        if (name.length > 0) {
            if (nextChar == '=') {
                // The parameter has a value
                result = this.createParameter(name, this.readParameterValue());
            } else {
                // The parameter has not value
            	this.unread();
                result = this.createParameter(name);
            }
        } else {
            throw new Error(
                    "Parameter or extension has no name. Please check your value");
        }

        return result;
    },
    readParameterValue: function() {
         var result = null;

        // Discard any leading space
        this.skipSpaces();

        // Detect if quoted string or token available
        var nextChar = this.peek();

        if (HeaderUtils.isDoubleQuote(nextChar)) {
            result = this.readQuotedString();
        } else if (HeaderUtils.isTokenChar(nextChar)) {
            result = this.readToken();
        }

        return result;
    },
    readQuotedString: function() {
        var result = null;
        var next = this.read();

        // First character must be a double quote
        if (HeaderUtils.isDoubleQuote(next)) {
            var buffer = new commons.StringBuilder();

            while (result == null) {
                next = this.read();

                if (HeaderUtils.isQuotedText(next)) {
                    buffer.append(next);
                } else if (HeaderUtils.isQuoteCharacter(next)) {
                    // Start of a quoted pair (escape sequence)
                    buffer.append(this.read());
                } else if (HeaderUtils.isDoubleQuote(next)) {
                    // End of quoted string
                    result = buffer.toString();
                } else if (next == -1) {
                    throw new Error(
                            "Unexpected end of quoted string. Please check your value");
                } else {
                    throw new Error(
                            "Invalid character \""
                                    + next
                                    + "\" detected in quoted string. Please check your value");
                }
            }
        } else {
            throw new Error(
                    "A quoted string must start with a double quote");
        }

        return result;
    },
    readRawText: function() {
        // Read value until end or space
        var sb = null;
        var next = this.read();

        while ((next != -1) && !HeaderUtils.isSpace(next) && !HeaderUtils.isComma(next)) {
            if (sb == null) {
                sb = new commons.StringBuilder();
            }

            sb.append(next);
            next = this.read();
        }

        // Unread the separator
        if (HeaderUtils.isSpace(next) || HeaderUtils.isComma(next)) {
            this.unread();
        }

        return (sb == null) ? null : sb.toString();
    },
    readRawValue: function() {
        // Skip leading spaces
    	this.skipSpaces();

        // Read value until end or comma
        var sb = null;
        var next = this.read();

        while ((next != -1) && !HeaderUtils.isComma(next)) {
            if (sb == null) {
                sb = new commons.StringBuilder();
            }

            sb.append(next);
            next = this.read();
        }

        // Remove trailing spaces
        if (sb != null) {
            for (var i = sb.length() - 1; (i >= 0)
                    && HeaderUtils.isLinearWhiteSpace(sb.charAt(i)); i--) {
                sb.deleteCharAt(i);
            }
        }

        // Unread the separator
        if (HeaderUtils.isComma(next)) {
        	this.unread();
        }

        return (sb == null) ? null : sb.toString();
    },
    readToken: function() {
        var sb = new commons.StringBuilder();
        var next = this.read();

        while (HeaderUtils.isTokenChar(next)) {
            sb.append(next);
            next = this.read();
        }
        
        // Unread the last character (separator or end marker)
        this.unread();

        return sb.toString();
    },
    /*public V readValue() throws IOException {
        return null;
    },*/
    readValues: function() {
        var result = [];
        this.addValues(result);
        return result;
    },
    reset: function() {
        this.index = this.mark;
    },
    skipParameterSeparator: function() {
        var result = false;
        // Skip leading spaces
        this.skipSpaces();
        // Check if next character is a parameter separator
        if (HeaderUtils.isSemiColon(this.read())) {
            result = true;
            // Skip trailing spaces
            this.skipSpaces();
        } else {
            // Probably reached the end of the header
        	this.unread();
        }
        return result;
    },
    skipSpaces: function() {
        var result = false;
        var next = this.peek();

        while (HeaderUtils.isLinearWhiteSpace(next) && (next != -1)) {
            result = result || HeaderUtils.isLinearWhiteSpace(next);
            this.read();
            next = this.peek();
        }

        return result;
    },
    skipValueSeparator: function() {
        var result = false;
        this.skipSpaces();
        if (HeaderUtils.isComma(this.read())) {
            result = true;
            this.skipSpaces();
        } else {
        	this.unread();
        }
        return result;
    },
	unread: function() {
        if (this.index > 0) {
            this.index--;
        }
    }
});

HeaderReader.extend({
    createNamedValue: function(resultClass, name, value) {
        try {
            return new resultClass(name, value);
        } catch (err) {
            /*Context.getCurrentLogger().log(Level.WARNING,
                    "Unable to create named value", e);*/
        	console.log(err.stack);
            return null;
        }
    },
    readDate: function(date, cookie) {
        if (cookie) {
            return DateUtils.parse(date, DateUtils.FORMAT_RFC_1036);
        }

        return DateUtils.parse(date, DateUtils.FORMAT_RFC_1123);
    },
    readHeader: function(header) {
        var result = null;

        if (header.length > 0) {
            // Detect the end of headers
            var start = 0;
            var index = 0;
            var next = header.charAt(index++);

            if (HeaderUtils.isCarriageReturn(next)) {
                next = header.charAt(index++);

                if (!HeaderUtils.isLineFeed(next)) {
                    throw new Error(
                            "Invalid end of headers. Line feed missing after the carriage return.");
                }
            } else {
                result = new Parameter();

                // Parse the header name
                while ((index < header.length) && (next != ':')) {
                    next = header.charAt(index++);
                }

                if (index == header.length) {
                    throw new Error(
                            "Unable to parse the header name. End of line reached too early.");
                }

                result.setName(header.substring(start, index - 1).toString());
                next = header.charAt(index++);

                while (HeaderUtils.isSpace(next)) {
                    // Skip any separator space between colon and header value
                    next = header.charAt(index++);
                }

                start = index - 1;

                // Parse the header value
                result.setValue(header.substring(start, header.length)
                        .toString());
            }
        }

        return result;
    }
});

var HeaderWriter = new commons.Class({
    initialize: function() {
    	this.content = [];
    },

    append: function(text) {
		this.content.push(text);
		return this;
	},
	
	toString: function() {
		return this.content.join("");
	},

    appendCollection: function(values) {
        if ((values != null) && !values.isEmpty()) {
            var first = true;

            for (var i=0; i<values.length; i++) {
            	var value = values[i];
                if (this.canWrite(value)) {
                    if (first) {
                        first = false;
                    } else {
                        this.appendValueSeparator();
                    }

                    if (typeof value == "string") {
                    	this.append(value);
                    } else {
                    	this.appendObject(value);
                    }
                }
            }
        }

        return this;
    },

	appendComment: function(content) {
        this.append("(");
        var c;

        for (var i = 0; i < content.length(); i++) {
            c = content.charAt(i);

            if (HeaderUtils.isCommentText(c)) {
                this.append(c);
            } else {
            	this.appendQuotedPair(c);
            }
        }

        return this.append(")");
    },

    appendExtension: function() {
    	if (arguments.length==1) {
    		var extension = arguments[0];
    		return this.appendExtension1(extension);
    	} else if (arguments.length==2) {
    		var name = arguments[0];
    		var value = arguments[1];
    		return this.appendExtension2(name, value);
    	}
    },
    
    appendExtension1: function(extension) {
        if (extension != null) {
            return this.appendExtension(extension.getName(), extension.getValue());
        } else {
            return this;
        }
    },

    appendExtension2: function(name, value) {
        if ((name != null) && (name.length() > 0)) {
            this.append(name);

            if ((value != null) && (value.length() > 0)) {
            	this.append("=");

                if (HeaderUtils.isToken(value)) {
                	this.append(value);
                } else {
                	this.appendQuotedString(value);
                }
            }
        }

        return this;
    },

    appendParameterSeparator: function() {
        return this.append(";");
    },

    appendProduct: function(name, version) {
        this.appendToken(name);

        if (version != null) {
            this.append("/").appendToken(version);
        }

        return this;
    },

    appendQuotedPair: function(character) {
        return this.append("\\").append(character);
    },

    appendQuotedString: function(content) {
        if ((content != null) && (content.length() > 0)) {
            this.append("\"");
            var c;

            for (var i = 0; i < content.length(); i++) {
                c = content.charAt(i);

                if (HeaderUtils.isQuotedText(c)) {
                    this.append(c);
                } else {
                    this.appendQuotedPair(c);
                }
            }

            this.append("\"");
        }

        return this;
    },

    appendSpace: function() {
        return this.append(" ");
    },

    appendToken: function(token) {
        if (HeaderUtils.isToken(token)) {
            return this.append(token);
        } else {
            throw new Error(
                    "Unexpected character found in token: " + token);
        }
    },

    appendUriEncoded: function(source, characterSet) {
        return this.append(Reference.encode(source.toString(), characterSet));
    },

    appendValueSeparator: function() {
        return this.append(", ");
    },

    canWrite: function(value) {
        return (value != null);
    }
});

var CacheDirectiveWriter = new commons.Class(HeaderWriter, {
	initialize: function() {
		this.callSuperCstr();
	},

	appendObject: function(directive) {
        this.appendExtension(directive);
        return this;
    }
});

CacheDirectiveWriter.extend({
	write: function(directives) {
		return new CacheDirectiveWriter().appendCollection(directives).toString();
	}
});

var CookieReader = new commons.Class(HeaderReader, {
    initialize: function(header) {
        this.callSuperCstr(header);
        this.globalVersion = -1;
    },

    readPair: function(readAttribute) {
        var result = null;

        var readingName = true;
        var readingValue = false;
        var nameBuffer = new StringBuilder();
        var valueBuffer = new StringBuilder();
        var nextChar = 0;

        while ((result == null) && (nextChar != -1)) {
            nextChar = this.read();

            if (readingName) {
                if ((HeaderUtils.isSpace(nextChar))
                        && (nameBuffer.length() == 0)) {
                    // Skip spaces
                } else if ((nextChar == -1) || (nextChar == ';')
                        || (nextChar == ',')) {
                    if (nameBuffer.length() > 0) {
                        // End of pair with no value
                        result = data.Parameter.create(nameBuffer, null);
                    } else if (nextChar == -1) {
                        // Do nothing return null preference
                    } else {
                        throw new Error(
                                "Empty cookie name detected. Please check your cookies");
                    }
                } else if (nextChar == '=') {
                    readingName = false;
                    readingValue = true;
                } else if (HeaderUtils.isTokenChar(nextChar)
                        || (this.globalVersion < 1)) {
                    if (readAttribute && nextChar != '$'
                            && (nameBuffer.length() == 0)) {
                        this.unread();
                        nextChar = -1;
                    } else {
                        nameBuffer.append(nextChar);
                    }
                } else {
                    throw new Error(
                            "Separator and control characters are not allowed within a token. Please check your cookie header");
                }
            } else if (readingValue) {
                if ((HeaderUtils.isSpace(nextChar))
                        && (valueBuffer.length() == 0)) {
                    // Skip spaces
                } else if ((nextChar == -1) || (nextChar == ';')) {
                    // End of pair
                    result = data.Parameter.create(nameBuffer, valueBuffer);
                } else if ((nextChar == '"') && (valueBuffer.length() == 0)) {
                    // Step back
                    this.unread();
                    valueBuffer.append(this.readQuotedString());
                } else if (HeaderUtils.isTokenChar(nextChar)
                        || (this.globalVersion < 1)) {
                    valueBuffer.append(nextChar);
                } else {
                    throw new Error(
                            "Separator and control characters are not allowed within a token. Please check your cookie header");
                }
            }
        }

        return result;
    },

    readValue: function() {
        var result = null;
        var pair = this.readPair(false);

        if (this.globalVersion == -1) {
            // Cookies version not yet detected
            if (pair.getName().equalsIgnoreCase(CookieReader.NAME_VERSION)) {
                if (pair.getValue() != null) {
                    this.globalVersion = parseInt(pair.getValue());
                } else {
                    throw new Error(
                            "Empty cookies version attribute detected. Please check your cookie header");
                }
            } else {
                // Set the default version for old Netscape cookies
                this.globalVersion = 0;
            }
        }

        while ((pair != null) && (pair.getName().charAt(0) == '$')) {
            // Unexpected special attribute
            // Silently ignore it as it may have been introduced by new
            // specifications
            pair = this.readPair(false);
        }

        if (pair != null) {
            // Set the cookie name and value
            result = new data.Cookie(this.globalVersion, pair.getName(),
                    pair.getValue());
            pair = this.readPair(true);
        }

        while ((pair != null) && (pair.getName().charAt(0) == '$')) {
            if (pair.getName().equalsIgnoreCase(CookieReader.NAME_PATH)) {
                result.setPath(pair.getValue());
            } else if (pair.getName().equalsIgnoreCase(CookieReader.NAME_DOMAIN)) {
                result.setDomain(pair.getValue());
            } else {
                // Unexpected special attribute
                // Silently ignore it as it may have been introduced by new
                // specifications
            }

            pair = this.readPair(true);
        }

        return result;
    }
});

CookieReader.extend({
	NAME_DOMAIN: "$Domain",
	NAME_PATH: "$Path",
	NAME_VERSION: "$Version",

	read: function(cookie) {
        var cr = new CookieReader(cookie);

        try {
            return cr.readValue();
        } catch (err) {
            throw new Error("Could not read the cookie");
        }
    }
});

var CookieWriter = new commons.Class(HeaderWriter, {
	initialize: function() {
		this.callSuperCstr();
	},

	appendObject: function(cookie) {
        var name = cookie.getName();
        var value = cookie.getValue();
        var version = cookie.getVersion();

        if ((name == null) || (name.length == 0)) {
            throw new Error(
                    "Can't write cookie. Invalid name detected");
        }

        this.appendValue(name, 0).append('=');

        // Append the value
        if ((value != null) && (value.length > 0)) {
        	this.appendValue(value, version);
        }

        if (version > 0) {
            // Append the path
            var path = cookie.getPath();

            if ((path != null) && (path.length > 0)) {
            	this.append("; $Path=");
            	this.appendQuotedString(path);
            }

            // Append the domain
            var domain = cookie.getDomain();

            if ((domain != null) && (domain.length > 0)) {
            	this.append("; $Domain=");
            	this.appendQuotedString(domain);
            }
        }

        return this;
    },

    appendCollection: function(cookies) {
        if ((cookies != null) && !cookies.isEmpty()) {
            var cookie;

            var elements = cookies.getElements();
            for (var i = 0; i < elements.length; i++) {
                cookie = elements[i];

                if (i == 0) {
                    if (cookie.getVersion() > 0) {
                    	this.append("$Version=\"").append(cookie.getVersion())
                                .append("\"; ");
                    }
                } else {
                	this.append("; ");
                }

                this.appendObject(cookie);
            }
        }

        return this;
    },

    appendValue: function(value, version) {
        if (version == 0) {
        	this.append(value.toString());
        } else {
        	this.appendQuotedString(value);
        }

        return this;
    }
});

CookieWriter.extend({
	getCookies: function(source, destination) {
	    var cookie;

	    for (var i=0; i<source.length; i++) {
	        cookie = source[i];

	        if (destination.containsKey(cookie.getName())) {
	            destination.put(cookie.getName(), cookie);
	        }
	    }
	},

	writeObject: function(cookie) {
	    return new CookieWriter().appendObject(cookie).toString();
	},

	writeCollection: function(cookies) {
	    return new CookieWriter().appendCollection(cookies).toString();
	}
});

var CookieSettingWriter = new commons.Class(HeaderWriter, {
	initialize: function() {
		this.callSuperCstr();
	},

    appendObject: function(cookieSetting) {
        var name = cookieSetting.getName();
        var value = cookieSetting.getValue();
        var version = cookieSetting.getVersion();

        if ((name == null) || (name.length == 0)) {
            throw new Error(
                    "Can't write cookie. Invalid name detected");
        }

        this.append(name).append('=');

        // Append the value
        if ((value != null) && (value.length > 0)) {
        	this.appendValue(value, version);
        }

        // Append the version
        if (version > 0) {
        	this.append("; Version=");
        	this.appendValue(version.toString(), version);
        }

        // Append the path
        var path = cookieSetting.getPath();

        if ((path != null) && (path.length > 0)) {
        	this.append("; Path=");

            if (version == 0) {
            	this.append(path);
            } else {
            	this.appendQuotedString(path);
            }
        }

        // Append the expiration date
        var maxAge = cookieSetting.getMaxAge();

        if (maxAge >= 0) {
            if (version == 0) {
                var currentTime = (new Date()).getTime();
                var maxTime = (maxAge * 1000);
                var expiresTime = currentTime + maxTime;
                var expires = new Date(expiresTime);

                this.append("; Expires=");
                this.appendValue(DateUtils.format(expires, DateUtils.FORMAT_RFC_1036
                        .get(0)), version);
            } else {
            	this.append("; Max-Age=");
            	this.appendValue(cookieSetting.getMaxAge().toString(),
                        version);
            }
        } else if ((maxAge == -1) && (version > 0)) {
            // Discard the cookie at the end of the user's session (RFC
            // 2965)
        	this.append("; Discard");
        } else {
            // NetScape cookies automatically expire at the end of the
            // user's session
        }

        // Append the domain
        var domain = cookieSetting.getDomain();

        if ((domain != null) && (domain.length > 0)) {
        	this.append("; Domain=");
        	this.appendValue(domain.toLowerCase(), version);
        }

        // Append the secure flag
        if (cookieSetting.isSecure()) {
        	this.append("; Secure");
        }

        // Append the secure flag
        if (cookieSetting.isAccessRestricted()) {
        	this.append("; HttpOnly");
        }

        // Append the comment
        if (version > 0) {
            var comment = cookieSetting.getComment();

            if ((comment != null) && (comment.length > 0)) {
            	this.append("; Comment=");
            	this.appendValue(comment, version);
            }
        }

        return this;
    },

    appendValue: function(value, version) {
        if (version == 0) {
        	this.append(value.toString());
        } else {
        	this.appendQuotedString(value);
        }

        return this;
    }
});

CookieSettingWriter.extend({
	write: function() {
		if (arguments[0] instanceof Array) {
			var cookieSettings = arguments[0];
			return new CookieSettingWriter().appendCollection(cookieSettings).toString();
		} else {
			var cookieSetting = arguments[0];
			return new CookieSettingWriter().appendObject(cookieSetting).toString();
		}
	}
});

var DateWriter = new commons.Class({});

DateWriter.extend({
    /*write: function(date) {
        return DateWriter.write(date, false);
    },*/
    write: function(date, cookie) {
        if (cookie) {
            return DateUtils.format(date, DateUtils.FORMAT_RFC_1036[0]);
        }
        return DateUtils.format(date);
    }
});

var DimensionReader = new commons.Class(HeaderReader, {
    initialize: function(header) {
        this.callSuperCstr(header);
    },

    readValue: function() {
        var result = null;
        var value = this.readRawValue();

        if (value != null) {
            if (value.equalsIgnoreCase(HeaderConstants.HEADER_ACCEPT)) {
                result = data.Dimension.MEDIA_TYPE;
            } else if (value
                    .equalsIgnoreCase(HeaderConstants.HEADER_ACCEPT_CHARSET)) {
                result = data.Dimension.CHARACTER_SET;
            } else if (value
                    .equalsIgnoreCase(HeaderConstants.HEADER_ACCEPT_ENCODING)) {
                result = data.Dimension.ENCODING;
            } else if (value
                    .equalsIgnoreCase(HeaderConstants.HEADER_ACCEPT_LANGUAGE)) {
                result = data.Dimension.LANGUAGE;
            } else if (value
                    .equalsIgnoreCase(HeaderConstants.HEADER_AUTHORIZATION)) {
                result = data.Dimension.AUTHORIZATION;
            } else if (value
                    .equalsIgnoreCase(HeaderConstants.HEADER_USER_AGENT)) {
                result = data.Dimension.CLIENT_AGENT;
            } else if (value.equals("*")) {
                result = data.Dimension.UNSPECIFIED;
            }
        }

        return result;
    }
});

DimensionReader.extend({
	addValues: function(header, collection) {
	    new DimensionReader(header.getValue()).addValues(collection);
	}
});



var DimensionWriter = new commons.Class(HeaderWriter, {
    initialize: function() {
        this.callSuperCstr();
    },

    appendCollection: function(dimensions) {
        if ((dimensions != null) && !dimensions.isEmpty()) {
            if (dimensions.contains(data.Dimension.CLIENT_ADDRESS)
                    || dimensions.contains(data.Dimension.TIME)
                    || dimensions.contains(data.Dimension.UNSPECIFIED)) {
                // From an HTTP point of view the representations can
                // vary in unspecified ways
                this.append("*");
            } else {
                var first = true;

                for (var i=0; i<dimensions.length; i++) {
                	var dimension = dimensions[i];
                    if (first) {
                        first = false;
                    } else {
                    	this.append(", ");
                    }

                    this.appendObject(dimension);
                }
            }
        }

        return this;
    },

    appendObject: function(dimension) {
        if (dimension == data.Dimension.CHARACTER_SET) {
            this.append(HeaderConstants.HEADER_ACCEPT_CHARSET);
        } else if (dimension == data.Dimension.CLIENT_AGENT) {
        	this.append(HeaderConstants.HEADER_USER_AGENT);
        } else if (dimension == data.Dimension.ENCODING) {
        	this.append(HeaderConstants.HEADER_ACCEPT_ENCODING);
        } else if (dimension == data.Dimension.LANGUAGE) {
        	this.append(HeaderConstants.HEADER_ACCEPT_LANGUAGE);
        } else if (dimension == data.Dimension.MEDIA_TYPE) {
        	this.append(HeaderConstants.HEADER_ACCEPT);
        } else if (dimension == data.Dimension.AUTHORIZATION) {
        	this.append(HeaderConstants.HEADER_AUTHORIZATION);
        }

        return this;
    }
});

DimensionWriter.extend({
	write: function(dimensions) {
		return new DimensionWriter().appendCollection(dimensions).toString();
	}
});


var DispositionReader = new commons.Class(HeaderReader, {
    initialize: function(header) {
        this.callSuperCstr(header);
    },

	readValue: function() {
        var result = null;
        var type = this.readToken();

        if (type.length > 0) {
            result = new Disposition();
            result.setType(type);

            if (this.skipParameterSeparator()) {
                var param = this.readParameter();

                while (param != null) {
                    result.getParameters().add(param);

                    if (this.skipParameterSeparator()) {
                        param = this.readParameter();
                    } else {
                        param = null;
                    }
                }
            }
        }

        return result;
    }
});

var DispositionWriter = new commons.Class(HeaderWriter, {
	initialize: function() {
		this.callSuperCstr();
	},

    appendObject: function(disposition) {
        if (data.Disposition.TYPE_NONE.equals(disposition.getType())
                || disposition.getType() == null) {
            return this;
        }

        this.append(disposition.getType());

        var elements = disposition.getParameters().getElements();
        for (var i=0; i<elements.length; i++) {
        	var parameter = elements[i];
        	this.append("; ");
        	this.append(parameter.getName());
        	this.append("=");

            if (HeaderUtils.isToken(parameter.getValue())) {
            	this.append(parameter.getValue());
            } else {
            	this.appendQuotedString(parameter.getValue());
            }
        }

        return this;
    }
});

DispositionWriter.extend({
	writeObject: function(disposition) {
	    return new DispositionWriter().appendObject(disposition).toString();
	}
});

var ExpectationReader = new commons.Class(HeaderReader, {
    initialize: function(header) {
        this.callSuperCstr(header);
    },

    readValue: function() {
        var result = this.readNamedValue(data.Expectation);

        while (this.skipParameterSeparator()) {
            result.getParameters().add(this.readParameter());
        }

        return result;
    }
});

ExpectationReader.extend({
	addValues: function(header, clientInfo) {
		if (header != null) {
			new ExpectationReader(header).addValues(clientInfo.getExpectations());
		}
	}
});


var MetadataWriter = new commons.Class(HeaderWriter, {
	initialize: function() {
    	this.content = [];
	},

	appendObject: function(metadata) {
        return this.append(metadata.getName());
    }
});

var EncodingReader = new commons.Class(HeaderReader, {
    initialize: function(header) {
        this.callSuperCstr(header);
        /*this.header = header;
        this.index = ((header == null) || (header.length == 0)) ? -1 : 0;
        this.mark = this.index;*/
    },
    canAdd: function(value, values) {
        return value != null && !data.Encoding.IDENTITY.getName().equals(value.getName());
    },
    readValue: function() {
        return data.Encoding.valueOf(this.readToken());
    }
});

var EncodingWriter = new commons.Class(MetadataWriter, {
    initialize: function(header) {
        this.callSuperCstr(header);
    },
    canAdd: function(value, values) {
        return value != null && !data.Encoding.IDENTITY.getName().equals(value.getName());
    },
    readValue: function() {
        return data.Encoding.valueOf(this.readToken());
    }
});

EncodingWriter.extend({
	write: function(encodings) {
        return new EncodingWriter().appendCollection(encodings).toString();
    }
});

var LanguageReader = new commons.Class(HeaderReader, {
    initialize: function(header) {
        this.callSuperCstr(header);
    },

    readValue: function() {
        return Language.valueOf(this.readRawValue());
    }
});

var LanguageWriter = new commons.Class(MetadataWriter, {
    initialize: function(header) {
        this.callSuperCstr(header);
    }
});

LanguageWriter.extend({
	write: function(languages) {
        return new LanguageWriter().appendCollection(languages).toString();
    }
});

var MethodWriter = new commons.Class(HeaderWriter, {
	initialize: function() {
		this.callSuperCstr();
	},

    appendObject: function(method) {
        this.appendToken(method.getName());
    }
});

MethodWriter.extend({
	write: function(methods) {
		return new MethodWriter().appendCollection(methods).toString();
	}
});



var PreferenceReader = new commons.Class(HeaderReader, {
    initialize: function(type, header) {
        this.callSuperCstr(header);
        this.type = type;
    },

    createPreference: function(metadata, parameters) {
        var result;

        if (parameters == null) {
            result = new data.Preference();

            switch (this.type) {
            case PreferenceReader.TYPE_CHARACTER_SET:
                result.setMetadata(data.CharacterSet.valueOf(metadata.toString()));
                break;

            case PreferenceReader.TYPE_ENCODING:
                result.setMetadata(data.Encoding.valueOf(metadata.toString()));
                break;

            case PreferenceReader.TYPE_LANGUAGE:
                result.setMetadata(data.Language.valueOf(metadata.toString()));
                break;

            case PreferenceReader.TYPE_MEDIA_TYPE:
                result.setMetadata(data.MediaType.valueOf(metadata.toString()));
                break;
            }
        } else {
            var mediaParams = this.extractMediaParams(parameters);
            var quality = this.extractQuality(parameters);
            result = new data.Preference(null, quality, parameters);

            switch (this.type) {
            case PreferenceReader.TYPE_CHARACTER_SET:
                result.setMetadata(new data.CharacterSet(metadata.toString()));
                break;

            case PreferenceReader.TYPE_ENCODING:
                result.setMetadata(new data.Encoding(metadata.toString()));
                break;

            case PreferenceReader.TYPE_LANGUAGE:
                result.setMetadata(new data.Language(metadata.toString()));
                break;

            case PreferenceReader.TYPE_MEDIA_TYPE:
                result.setMetadata(new data.MediaType(metadata.toString(),
                        mediaParams));
                break;
            }
        }

        return result;
    },

    extractMediaParams: function(parameters) {
        var result = null;
        var qualityFound = false;
        var param = null;

        if (parameters != null) {
            result = new util.Series();
            
            var elements = parameters.getElements();
            for (var i=0; !qualityFound && i<elements.length; i++) {
                param = elements[i];

                if (param.getName().equals("q")) {
                    qualityFound = true;
                } else {
                    elements.remove(i);
                    result.add(param);
                }
            }
        }

        return result;
    },

    extractQuality: function(parameters) {
        var result = 1;
        var found = false;

        if (parameters != null) {
            var param = null;

            var elements = parameters.getElements();
            for (var i=0; !found && i<elements.length; i++) {
                param = elements[i];
                if (param.getName().equals("q")) {
                    result = PreferenceReader.readQuality(param.getValue());
                    found = true;

                    //TODO
                    // Remove the quality parameter as we will directly store it
                    // in the Preference object
                    elements.remove(i);
                }
            }
        }

        return result;
    },

    readValue: function() {
        var result = null;

        var readingMetadata = true;
        var readingParamName = false;
        var readingParamValue = false;

        var metadataBuffer = new commons.StringBuilder();
        var paramNameBuffer = null;
        var paramValueBuffer = null;

        var parameters = null;
        var next = 0;

        while (result == null) {
            next = this.read();

            if (readingMetadata) {
                if ((next == -1) ||  HeaderUtils.isComma(next)) {
                    if (metadataBuffer.length() > 0) {
                        // End of metadata section
                        // No parameters detected
                        result = this.createPreference(metadataBuffer, null);
                    } else {
                        // Ignore empty metadata name
                        break;
                    }
                } else if (next == ';') {
                    if (metadataBuffer.length() > 0) {
                        // End of metadata section
                        // Parameters detected
                        readingMetadata = false;
                        readingParamName = true;
                        paramNameBuffer = new commons.StringBuilder();
                        parameters = new util.Series();
                    } else {
                        throw new Error("Empty metadata name detected.");
                    }
                } else if (HeaderUtils.isSpace(next)) {
                    // Ignore spaces
                } else if (HeaderUtils.isText(next)) {
                    metadataBuffer.append(next);
                } else {
                    throw new Error("Unexpected character \""
                            + next + "\" detected.");
                }
            } else if (readingParamName) {
                if (next == '=') {
                    if (paramNameBuffer.length() > 0) {
                        // End of parameter name section
                        readingParamName = false;
                        readingParamValue = true;
                        paramValueBuffer = new commons.StringBuilder();
                    } else {
                        throw new Error("Empty parameter name detected.");
                    }
                } else if ((next == -1) || HeaderUtils.isComma(next)) {
                    if (paramNameBuffer.length() > 0) {
                        // End of parameters section
                        parameters.add(data.Parameter.create(paramNameBuffer, null));
                        result = this.createPreference(metadataBuffer, parameters);
                    } else {
                        throw new Error("Empty parameter name detected.");
                    }
                } else if (next == ';') {
                    // End of parameter
                    parameters.add(data.Parameter.create(paramNameBuffer, null));
                    paramNameBuffer = new commons.StringBuilder();
                    readingParamName = true;
                    readingParamValue = false;
                } else if (HeaderUtils.isSpace(next) && (paramNameBuffer.length() == 0)) {
                    // Ignore white spaces
                } else if (HeaderUtils.isTokenChar(next)) {
                    paramNameBuffer.append(next);
                } else {
                    throw new Error("Unexpected character \""
                            + next + "\" detected.");
                }
            } else if (readingParamValue) {
                if ((next == -1) || HeaderUtils.isComma(next) || HeaderUtils.isSpace(next)) {
                    if (paramValueBuffer.length() > 0) {
                        // End of parameters section
                        parameters.add(data.Parameter.create(paramNameBuffer,
                                paramValueBuffer));
                        result = this.createPreference(metadataBuffer, parameters);
                    } else {
                        throw new Error("Empty parameter value detected");
                    }
                } else if (next == ';') {
                    // End of parameter
                    parameters.add(data.Parameter.create(paramNameBuffer,
                            paramValueBuffer));
                    paramNameBuffer = new commons.StringBuilder();
                    readingParamName = true;
                    readingParamValue = false;
                } else if ((next == '"') && (paramValueBuffer.length() == 0)) {
                    // Parse the quoted string
                    var done = false;
                    var quotedPair = false;

                    while ((!done) && (next != -1)) {
                        next = this.read();

                        if (quotedPair) {
                            // End of quoted pair (escape sequence)
                            if (HeaderUtils.isText(next)) {
                                paramValueBuffer.append(next);
                                quotedPair = false;
                            } else {
                                throw new Error(
                                        "Invalid character detected in quoted string. Please check your value");
                            }
                        } else if (HeaderUtils.isDoubleQuote(next)) {
                            // End of quoted string
                            done = true;
                        } else if (next == '\\') {
                            // Begin of quoted pair (escape sequence)
                            quotedPair = true;
                        } else if (HeaderUtils.isText(next)) {
                            paramValueBuffer.append(next);
                        } else {
                            throw new Error(
                                    "Invalid character detected in quoted string. Please check your value");
                        }
                    }
                } else if (HeaderUtils.isTokenChar(next)) {
                    paramValueBuffer.append(next);
                } else {
                    throw new Error("Unexpected character \""
                            + next + "\" detected.");
                }
            }
        }

        if (HeaderUtils.isComma(next)) {
            // Unread character which isn't part of the value
        	this.unread();
        }

        return result;
    }
});

PreferenceReader.extend({
	TYPE_CHARACTER_SET: 1,
	TYPE_ENCODING: 2,
	TYPE_LANGUAGE: 3,
	TYPE_MEDIA_TYPE: 4,

	addCharacterSets: function(acceptCharsetHeader, clientInfo) {
		if (acceptCharsetHeader != null) {
			// Implementation according to
			// http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.2
			if (acceptCharsetHeader.length() == 0) {
				clientInfo.getAcceptedCharacterSets().add(
						new data.Preference(data.CharacterSet.ISO_8859_1));
			} else {
				var pr = new PreferenceReader(
						PreferenceReader.TYPE_CHARACTER_SET,
						acceptCharsetHeader);
				pr.addValues(clientInfo.getAcceptedCharacterSets());
			}
		} else {
			clientInfo.getAcceptedCharacterSets().add(
					new data.Preference(data.CharacterSet.ALL));
		}
	},

	addEncodings: function(acceptEncodingHeader, clientInfo) {
	    if (acceptEncodingHeader != null) {
	        var pr = new PreferenceReader(
	                PreferenceReader.TYPE_ENCODING, acceptEncodingHeader);
	        pr.addValues(clientInfo.getAcceptedEncodings());
	    } else {
	        clientInfo.getAcceptedEncodings().add(
	                new data.Preference(data.Encoding.IDENTITY));
	    }
	},
	
	addLanguages: function(acceptLanguageHeader, clientInfo) {
	    if (acceptLanguageHeader != null) {
	        var pr = new PreferenceReader(
	                PreferenceReader.TYPE_LANGUAGE, acceptLanguageHeader);
	        pr.addValues(clientInfo.getAcceptedLanguages());
	    } else {
	        clientInfo.getAcceptedLanguages().add(new data.Preference(data.Language.ALL));
	    }
	},

	addMediaTypes: function(acceptMediaTypeHeader, clientInfo) {
	    if (acceptMediaTypeHeader != null) {
	        var pr = new PreferenceReader(
	                PreferenceReader.TYPE_MEDIA_TYPE, acceptMediaTypeHeader);
	        pr.addValues(clientInfo.getAcceptedMediaTypes());
	    } else {
	        clientInfo.getAcceptedMediaTypes().add(
	                new data.Preference(data.MediaType.ALL));
	    }
	},
	
	readQuality: function(quality) {
	    try {
	        var result = parseFloat(quality);
	
	        if (PreferenceWriter.isValidQuality(result)) {
	            return result;
	        }
	
	        throw new Error(
	                "Invalid quality value detected. Value must be between 0 and 1.");
	    } catch (err) {
	        throw new Error(
	                "Invalid quality value detected. Value must be between 0 and 1.");
	    }
	}
});

var PreferenceWriter = new commons.Class(HeaderWriter, {
	initialize: function() {
		this.callSuperCstr();
	},

	appendObject: function(pref) {
        this.append(pref.getMetadata().getName());

        if (pref.getQuality() < 1) {
            this.append(";q=");
            this.appendQuality(pref.getQuality());
        }

        if (pref.getParameters() != null) {
            var param;

            var params = pref.getParameters();
            for (var i=0; i<params.length; i++) {
                param = params[i];

                if (param.getName() != null) {
                    this.append(';').append(param.getName());

                    if ((param.getValue() != null)
                            && (param.getValue().length() > 0)) {
                        this.append('=').append(param.getValue());
                    }
                }
            }
        }

        return this;
    },

    appendQuality: function(quality) {
        if (!HeaderUtils.isValidQuality(quality)) {
            throw new Error(
                    "Invalid quality value detected. Value must be between 0 and 1.");
        }

        //TODO: implement number format for JS
        /*java.text.NumberFormat formatter = java.text.NumberFormat
                .getNumberInstance(java.util.Locale.US);
        formatter.setMaximumFractionDigits(2);
        append(formatter.format(quality));*/

        return this;
    }
});

PreferenceWriter.extend({
    isValidQuality: function(quality) {
        return (quality >= 0) && (quality <= 1);
    },

    write: function(prefs) {
        return new PreferenceWriter().appendCollection(prefs).toString();
    }
});

var ProductWriter = new commons.Class({});

ProductWriter.extend({
    write: function(products) {
        var builder = new commons.StringBuilder();

        for (var i=0; i<products.length; i++) {
            var product = products[i];

            if ((product.getName() == null)
                    || (product.getName().length == 0)) {
                throw new Error("Product name cannot be null.");
            }

            builder.append(product.getName());

            if (product.getVersion() != null) {
                builder.append("/").append(product.getVersion());
            }

            if (product.getComment() != null) {
                builder.append(" (").append(product.getComment()).append(")");
            }

            if (i!=products.length-1) {
                builder.append(" ");
            }
        }

        return builder.toString();
    }
});

var RangeReader = new commons.Class({
});

RangeReader.extend({
    update: function(value, representation) {
        var prefix = "bytes ";
        if (value != null && value.startsWith(prefix)) {
            value = value.substring(prefix.length());

            var index = value.indexOf("-");
            var index1 = value.indexOf("/");

            if (index != -1) {
                var startIndex = (index == 0) ? data.Range.INDEX_LAST : parseInt(value.substring(0, index));
                var endIndex = parseInt(value.substring(index + 1, index1));

                representation.setRange(new data.Range(startIndex, endIndex - startIndex + 1));
            }

            var strLength = value.substring(index1 + 1, value.length);
            if (!("*".equals(strLength))) {
                representation.setSize(parseInt(strLength));
            }
        }
    },

    read: function(rangeHeader) {
        var result = [];
        var prefix = "bytes=";
        if (rangeHeader != null && rangeHeader.startsWith(prefix)) {
            rangeHeader = rangeHeader.substring(prefix.length());

            var array = rangeHeader.split(",");
            for (var i = 0; i <array.length; i++) {
                var value = array[i].trim();
                var index = 0;
                var length = 0;
                if (value.startsWith("-")) {
                    index = data.Range.INDEX_LAST;
                    length = parseInt(value.substring(1));
                } else if (value.endsWith("-")) {
                    index = parseInt(value.substring(0, value.length - 1));
                    length = data.Range.SIZE_MAX;
                } else {
                    var tab = value.split("-");
                    if (tab.length == 2) {
                        index = parseInt(tab[0]);
                        length = parseInt(tab[1]) - index + 1;
                    }
                }
                result.push(new data.Range(index, length));
            }
        }

        return result;
    }
});

var RangeWriter = new commons.Class(HeaderWriter, {
	initialize: function() {
		this.callSuperCstr();
	},

    appendCollection: function(ranges) {
        if (ranges == null || ranges.isEmpty()) {
            return this;
        }

        this.append("bytes=");

        for (var i = 0; i < ranges.length; i++) {
            if (i > 0) {
            	this.append(", ");
            }

            this.appendObject(ranges[i]);
        }

        return this;
    },

    appendObject: function(range) {
        if (range.getIndex() >= Range.INDEX_FIRST) {
            this.append(range.getIndex());
            this.append("-");

            if (range.getSize() != Range.SIZE_MAX) {
            	this.append(range.getIndex() + range.getSize() - 1);
            }
        } else if (range.getIndex() == Range.INDEX_LAST) {
        	this.append("-");

            if (range.getSize() != Range.SIZE_MAX) {
            	this.append(range.getSize());
            }
        }

        return this;
    }
});

RangeWriter.extend({
    write: function(param, size) {
    	if (param instanceof Array) {
    		var ranges = param;
            return new RangeWriter().appendCollection(ranges).toString();
    	} else {
    		var range = param;
            var b = new commons.StringBuilder("bytes ");

            if (range.getIndex() >= Range.INDEX_FIRST) {
                b.append(range.getIndex());
                b.append("-");
                if (range.getSize() != Range.SIZE_MAX) {
                    b.append(range.getIndex() + range.getSize() - 1);
                } else {
                    if (size != Representation.UNKNOWN_SIZE) {
                        b.append(size - 1);
                    } else {
                        throw new Error(
                                "The entity has an unknown size, can't determine the last byte position.");
                    }
                }
            } else if (range.getIndex() == Range.INDEX_LAST) {
                if (range.getSize() != Range.SIZE_MAX) {
                    if (size != Representation.UNKNOWN_SIZE) {
                        if (range.getSize() <= size) {
                            b.append(size - range.getSize());
                            b.append("-");
                            b.append(size - 1);
                        } else {
                            throw new Error(
                                    "The size of the range ("
                                            + range.getSize()
                                            + ") is higher than the size of the entity ("
                                            + size + ").");
                        }
                    } else {
                        throw new Error(
                                "The entity has an unknown size, can't determine the last byte position.");
                    }
                } else {
                    // This is not a valid range.
                    throw new Error(
                            "The range provides no index and no size, it is invalid.");
                }
            }

            if (size != Representation.UNKNOWN_SIZE) {
                b.append("/").append(size);
            } else {
                b.append("/*");
            }

            return b.toString();
    	}
    }
});

var RecipientInfoReader = new commons.Class(HeaderReader, {
    initialize: function(header) {
        this.callSuperCstr(header);
    },

    readValue: function() {
        var result = new data.RecipientInfo();
        var protocolToken = this.readToken();

        if (this.peek() == '/') {
        	this.read();
            result.setProtocol(new data.Protocol(protocolToken, protocolToken, null,
                    -1, this.readToken()));
        } else {
            result.setProtocol(new data.Protocol("HTTP", "HTTP", null, -1,
                    protocolToken));
        }

        // Move to the next text
        if (this.skipSpaces()) {
            result.setName(this.readRawText());

            // Move to the next text
            if (this.skipSpaces()) {
                result.setComment(this.readComment());
            }
        }

        return result;
    }
});

RecipientInfoReader.extend({
	addValues: function(header, collection) {
		new RecipientInfoReader(header.getValue()).addValues(collection);
	}
});

var RecipientInfoWriter = new commons.Class(HeaderWriter, {
	initialize: function() {
		this.callSuperCstr();
	},

    appendObject: function(recipientInfo) {
        if (recipientInfo.getProtocol() != null) {
            this.appendToken(recipientInfo.getProtocol().getName());
            this.append('/');
            this.appendToken(recipientInfo.getProtocol().getVersion());
            this.appendSpace();

            if (recipientInfo.getName() != null) {
            	this.append(recipientInfo.getName());

                if (recipientInfo.getComment() != null) {
                	this.appendSpace();
                	this.appendComment(recipientInfo.getComment());
                }
            } else {
                throw new Error(
                        "The name (host or pseudonym) of a recipient can't be null");
            }
        } else {
            throw new Error(
                    "The protocol of a recipient can't be null");
        }

        return this;
    }
});

RecipientInfoWriter.extend({
    write: function(recipientsInfo) {
        return new RecipientInfoWriter().appendCollection(recipientsInfo).toString();
    }
});

var TagWriter = new commons.Class(HeaderWriter, {
    initialize: function(header) {
        this.callSuperCstr(header);
    },

    appendObject: function(tag) {
        return this.append(tag.format());
    }
});

TagWriter.extend({
	write: function(param) {
		if (param instanceof Array) {
			return new TagWriter().appendCollection(param).toString();
		} else {
			return new TagWriter().appendObject(param).toString();
		}
	}
});

var WarningReader = new commons.Class(HeaderReader, {
    initialize: function(header) {
        this.callSuperCstr(header);
    },

    readValue: function() {
        var result = new Warning();

        var code = this.readToken();
        this.skipSpaces();
        var agent = this.readRawText();
        this.skipSpaces();
        var text = this.readQuotedString();
        // The date is not mandatory
        this.skipSpaces();
        var date = null;
        if (this.peek() != -1) {
            date = this.readQuotedString();
        }

        if ((code == null) || (agent == null) || (text == null)) {
            throw new Error("Warning header malformed.");
        }

        result.setStatus(data.Status.valueOf(parseInt(code)));
        result.setAgent(agent);
        result.setText(text);
        if (date != null) {
            result.setDate(DateUtils.parse(date));
        }

        return result;
    }
});

WarningReader.extend({
	addValues: function(header, collection) {
		new WarningReader(header.getValue()).addValues(collection);
	}
});


var WarningWriter = new commons.Class(HeaderWriter, {
    initialize: function() {
        this.callSuperCstr();
    },

    appendObject: function(warning) {
        var agent = warning.getAgent();
        var text = warning.getText();

        if (warning.getStatus() == null) {
            throw new Error(
                    "Can't write warning. Invalid status code detected");
        }

        if ((agent == null) || (agent.length == 0)) {
            throw new Error(
                    "Can't write warning. Invalid agent detected");
        }

        if ((text == null) || (text.length == 0)) {
            throw new Error(
                    "Can't write warning. Invalid text detected");
        }

        this.append(warning.getStatus().getCode().toString());
        this.append(" ");
        this.append(agent);
        this.append(" ");
        this.appendQuotedString(text);

        if (warning.getDate() != null) {
        	this.appendQuotedString(DateUtils.format(warning.getDate()));
        }

        return this;
    }
});

WarningWriter.extend({
	write: function(warnings) {
		return new WarningWriter().appendCollection(warnings).toString();
	}
});



var DateUtils = new commons.Class({});

DateUtils.extend({
    FORMAT_ASC_TIME: ["EEE MMM dd HH:mm:ss yyyy"],
    FORMAT_RFC_1036: ["EEEE, dd-MMM-yy HH:mm:ss zzz"],
    FORMAT_RFC_1123: ["EEE, dd MMM yyyy HH:mm:ss zzz"],
    FORMAT_RFC_3339: ["yyyy-MM-dd'T'HH:mm:ssz"],
    FORMAT_RFC_822: [
            "EEE, dd MMM yy HH:mm:ss z", "EEE, dd MMM yy HH:mm z",
            "dd MMM yy HH:mm:ss z", "dd MMM yy HH:mm z"],
    after: function(baseDate, afterDate) {
        if ((baseDate == null) || (afterDate == null)) {
            throw new Error(
                    "Can't compare the dates, at least one of them is null");
        }

        var baseTime = baseDate.getTime() / 1000;
        var afterTime = afterDate.getTime() / 1000;
        return baseTime < afterTime;
    },
    before: function(baseDate, beforeDate) {
        if ((baseDate == null) || (beforeDate == null)) {
            throw new Error(
                    "Can't compare the dates, at least one of them is null");
        }

        var baseTime = baseDate.getTime() / 1000;
        var beforeTime = beforeDate.getTime() / 1000;
        return beforeTime < baseTime;
    },
    equals: function(baseDate, otherDate) {
        if ((baseDate == null) || (otherDate == null)) {
            throw new Error(
                    "Can't compare the dates, at least one of them is null");
        }

        var baseTime = baseDate.getTime() / 1000;
        var otherTime = otherDate.getTime() / 1000;
        return otherTime == baseTime;
    },
    /*format: function(date) {
        return DateUtils.format(date, DateUtils.FORMAT_RFC_1123[0]);
    },*/
    format: function(date, format) {
        if (date == null) {
            throw new Error("Date is null");
        }
        if (format==null) {
        	format = DateUtils.FORMAT_RFC_1123[0];
        }

        var formatter = new commons.DateFormat(format);
        return formatter.format(date, format);
    },
    /*parse: function(date) {
        return DateUtils.parse(date, DateUtils.FORMAT_RFC_1123);
    },*/
    parse: function(date, formats) {
        var result = null;

        if (date == null) {
            throw new Error("Date is null");
        }
        if (formats==null) {
        	formats = DateUtils.FORMAT_RFC_1123;
        }

        var format = null;
        var formatsSize = formats.length;

        for (var i = 0; (result == null) && (i < formatsSize); i++) {
            format = formats[i];
            var parser = new commons.DateFormat(format);
            try {
            	result = parser.parse(date);
            } catch(err) { }
        }

        return result;
    }
});

var Call = new commons.Class({
	initialize: function() {
		this.hostDomain = null;
        this.hostPort = -1;
        this.clientAddress = null;
        this.clientPort = -1;
        this.confidential = false;
        this.method = null;
        this.protocol = null;
        this.reasonPhrase = "";
	    this.requestHeaders = new util.Series();
        this.requestUri = null;
		this.responseHeaders = new util.Series();
        this.serverAddress = null;
        this.serverPort = -1;
        this.statusCode = 200;
        this.version = null;

		return this.clientAddress;
	},
	getClientAddress: function() {
		return this.clientAddress;
	},
	setClientAddress: function(clientAddress) {
		this.clientAddress = clientAddress;
	},
	getClientPort: function() {
		return this.clientPort;
	},
	setClientPort: function(clientPort) {
		this.clientPort = clientPort;
	},
	isConfidential: function() {
		return this.confidential;
	},
	setConfidential: function(confidential) {
		this.confidential = confidential;
	},
	getHostDomain: function() {
		return this.hostDomain;
	},
	setHostDomain: function(hostDomain) {
		this.hostDomain = hostDomain;
	},
	getHostPort: function() {
		return this.hostPort;
	},
	setHostPort: function(hostPort) {
		this.hostPort = hostPort;
	},
	getMethod: function() {
		return this.method;
	},
	setMethod: function(method) {
		this.method = method;
	},
	getProtocol: function() {
        if (this.protocol == null) {
            this.protocol = this.isConfidential() ? data.Protocol.HTTPS : data.Protocol.HTTP;
        }
		return this.protocol;
	},
	setProtocol: function(protocol) {
		this.protocol = protocol;
	},
    getReasonPhrase: function() {
		return this.reasonPhrase;
	},
	setReasonPhrase: function(reasonPhrase) {
		this.reasonPhrase = reasonPhrase;
	},
	getRequestHeaders: function() {
		return this.requestHeaders;
	},
	setRequestHeaders: function(requestHeaders) {
		this.requestHeaders = requestHeaders;
	},
	getRequestUri: function() {
		return this.requestUri;
	},
	setRequestUri: function(requestUri) {
		this.requestUri = requestUri;
	},
	getResponseHeaders: function() {
		return this.responseHeaders;
	},
	setResponseHeaders: function(responseHeaders) {
		this.responseHeaders = responseHeaders;
	},
	getServerAddress: function() {
		return this.serverAddress;
	},
	setServerAddress: function(serverAddress) {
		this.serverAddress = serverAddress;
	},
	getServerPort: function() {
		return this.serverPort;
	},
	setServerPort: function(serverPort) {
		this.serverPort = serverPort;
	},
	getStatusCode: function() {
		return this.statusCode;
	},
	setStatusCode: function(statusCode) {
		this.statusCode = statusCode;
	},
	getVersion: function() {
		return this.version;
	},
	setVersion: function(version) {
		this.version = version;
	}
});


var Adapter = new commons.Class({
    initialize: function(context) {
        this.context = context;
    },

    getContext: function() {
        return this.context;
    },

    getLogger: function() {
        var result = (this.getContext() != null) ? this.getContext().getLogger()
                : null;
        return (result != null) ? result : Context.getCurrentLogger();
    }
});


HttpRequest = new commons.Class(Request, {
    initialize: function(context, httpCall) {
        this.context = context;
        this.clientAdded = false;
        this.conditionAdded = false;
        this.cookiesAdded = false;
        this.entityAdded = false;
        this.referrerAdded = false;
        this.securityAdded = false;
        this.proxySecurityAdded = false;
        this.recipientsInfoAdded = false;
        this.warningsAdded = false;
        this.httpCall = httpCall;

        // Set the properties
        this.setMethod(data.Method.valueOf(httpCall.getMethod()));

        // Set the host reference
        var sb = new commons.StringBuilder();
        sb.append(httpCall.getProtocol().getSchemeName()).append("://");
        sb.append(httpCall.getHostDomain());
        if ((httpCall.getHostPort() != -1)
                && (httpCall.getHostPort() != httpCall.getProtocol()
                        .getDefaultPort())) {
            sb.append(':').append(httpCall.getHostPort());
        }
        this.setHostRef(sb.toString());

        // Set the resource reference
        if (httpCall.getRequestUri() != null) {
            this.setResourceRef(new data.Reference(this.getHostRef(), httpCall.getRequestUri()));

            if (this.getResourceRef().isRelative()) {
                // Take care of the "/" between the host part and the segments.
                if (!httpCall.getRequestUri().startsWith("/")) {
                    this.setResourceRef(new data.Reference(this.getHostRef().toString() + "/"
                            + httpCall.getRequestUri()));
                } else {
                	this.setResourceRef(new data.Reference(this.getHostRef().toString()
                            + httpCall.getRequestUri()));
                }
            }

            this.setOriginalRef(this.getResourceRef().getTargetRef());
        }

        // Set the request date
        var dateHeader = httpCall.getRequestHeaders().getFirstValue(
                HeaderConstants.HEADER_DATE);
        var date = null;
        if (dateHeader != null) {
            date = DateUtils.parse(dateHeader);
        }

        if (date == null) {
            date = new Date();
        }

        this.setDate(date);
    },

    abort: function() {
        return this.getHttpCall().abort();
    },

    getCacheDirectives: function() {
        var result = this.callSuper("getCacheDirectives");
        if (!this.cacheDirectivesAdded) {
        	var headerList = this.getHttpCall().getRequestHeaders().subList(
                    			HeaderConstants.HEADER_CACHE_CONTROL);
            for (var i=0; i<headerList.length; i++) {
            	var header = headerList[i];
                CacheDirectiveReader.addValues(header, result);
            }

            this.cacheDirectivesAdded = true;
        }

        return result;
    },

    /*public ChallengeResponse getChallengeResponse() {
        var result = super.getChallengeResponse();

        if (!this.securityAdded) {
            // Extract the header value
            var authorization = this.getHttpCall().getRequestHeaders().getValues(
                    HeaderConstants.HEADER_AUTHORIZATION);

            // Set the challenge response
            result = AuthenticatorUtils.parseResponse(this, authorization,
                    this.getHttpCall().getRequestHeaders());
            this.setChallengeResponse(result);
            this.securityAdded = true;
        }

        return result;
    },*/

    getClientInfo: function() {
    	var result = this.callSuper("getClientInfo");

        if (!this.clientAdded) {
            // Extract the header values
            var acceptMediaType = this.getHttpCall().getRequestHeaders()
                    .getValues(HeaderConstants.HEADER_ACCEPT);
            var acceptCharset = this.getHttpCall().getRequestHeaders().getValues(
            		HeaderConstants.HEADER_ACCEPT_CHARSET);
            var acceptEncoding = this.getHttpCall().getRequestHeaders()
                    .getValues(HeaderConstants.HEADER_ACCEPT_ENCODING);
            var acceptLanguage = this.getHttpCall().getRequestHeaders()
                    .getValues(HeaderConstants.HEADER_ACCEPT_LANGUAGE);
            var expect = this.getHttpCall().getRequestHeaders().getValues(
            		HeaderConstants.HEADER_EXPECT);

            // Parse the headers and update the call preferences

            // Parse the Accept* headers. If an error occurs during the parsing
            // of each header, the error is traced and we keep on with the other
            // headers.
            try {
            	PreferenceReader.addCharacterSets(acceptCharset, result);
            } catch (err) {
            	console.log(err.stack);
                //this.context.getLogger().log(Level.INFO, err.message);
            }

            try {
            	PreferenceReader.addEncodings(acceptEncoding, result);
            } catch (err) {
            	console.log(err.stack);
                //this.context.getLogger().log(Level.INFO, err.message);
            }

            try {
            	PreferenceReader.addLanguages(acceptLanguage, result);
            } catch (err) {
            	console.log(err.stack);
                //this.context.getLogger().log(Level.INFO, err.message);
            }

            try {
            	PreferenceReader.addMediaTypes(acceptMediaType, result);
            } catch (err) {
            	console.log(err.stack);
                //this.context.getLogger().log(Level.INFO, err.message);
            }

            try {
            	ExpectationReader.addValues(expect, result);
            } catch (err) {
            	console.log(err.stack);
                //this.context.getLogger().log(Level.INFO, err.message);
            }

            // Set other properties
            result.setAgent(this.getHttpCall().getRequestHeaders().getValues(
            		HeaderConstants.HEADER_USER_AGENT));
            result.setFrom(this.getHttpCall().getRequestHeaders().getFirstValue(
            		HeaderConstants.HEADER_FROM));
            result.setAddress(this.getHttpCall().getClientAddress());
            result.setPort(this.getHttpCall().getClientPort());

            /*if (this.getHttpCall().getUserPrincipal() != null) {
                result.getPrincipals().add(this.getHttpCall().getUserPrincipal());
            }*/

            if (this.context != null) {
                // Special handling for the non standard but common
                // "X-Forwarded-For" header.
                var useForwardedForHeader = this.context.getParameters()
                                .getFirstValue("useForwardedForHeader", "false").toBoolean();
                if (useForwardedForHeader) {
                    // Lookup the "X-Forwarded-For" header supported by popular
                    // proxies and caches.
                    var header = this.getHttpCall().getRequestHeaders()
                            .getValues(HeaderConstants.HEADER_X_FORWARDED_FOR);
                    if (header != null) {
                        var addresses = header.split(",");
                        for (var i = 0; i < addresses.length; i++) {
                            var address = addresses[i].trim();
                            result.getForwardedAddresses().add(address);
                        }
                    }
                }
            }

            this.clientAdded = true;
        }

        return result;
    },

    getConditions: function() {
        var result = this.callSuper("getConditions");

        if (!this.conditionAdded) {
            // Extract the header values
            var ifMatchHeader = this.getHttpCall().getRequestHeaders().getValues(
                    HeaderConstants.HEADER_IF_MATCH);
            var ifNoneMatchHeader = this.getHttpCall().getRequestHeaders()
                    .getValues(HeaderConstants.HEADER_IF_NONE_MATCH);
            var ifModifiedSince = null;
            var ifUnmodifiedSince = null;
            var ifRangeHeader = this.getHttpCall().getRequestHeaders()
                    .getFirstValue(HeaderConstants.HEADER_IF_RANGE);

            var requestHeaders = this.getHttpCall().getRequestHeaders();
            for (var i=0; i<requestHeaders.length; i++) {
            	var header = requestHeaders[i];
                if (header.getName().equalsIgnoreCase(
                        HeaderConstants.HEADER_IF_MODIFIED_SINCE)) {
                    ifModifiedSince = HeaderReader.readDate(header.getValue(), false);
                } else if (header.getName().equalsIgnoreCase(
                        HeaderConstants.HEADER_IF_UNMODIFIED_SINCE)) {
                    ifUnmodifiedSince = HeaderReader.readDate(
                            header.getValue(), false);
                }
            }

            // Set the If-Modified-Since date
            if ((ifModifiedSince != null) && (ifModifiedSince.getTime() != -1)) {
                result.setModifiedSince(ifModifiedSince);
            }

            // Set the If-Unmodified-Since date
            if ((ifUnmodifiedSince != null)
                    && (ifUnmodifiedSince.getTime() != -1)) {
                result.setUnmodifiedSince(ifUnmodifiedSince);
            }

            // Set the If-Match tags
            var match = null;
            var current = null;
            if (ifMatchHeader != null) {
                try {
                    var hr = new HeaderReader(ifMatchHeader);
                    var value = hr.readRawValue();

                    while (value != null) {
                        current = data.Tag.parse(value);

                        // Is it the first tag?
                        if (match == null) {
                            match = [];
                            result.setMatch(match);
                        }

                        // Add the new tag
                        match.add(current);

                        // Read the next token
                        value = hr.readRawValue();
                    }
                } catch (err) {
                    this.context.getLogger().log(
                            Level.INFO,
                            "Unable to process the if-match header: "
                                    + ifMatchHeader);
                }
            }

            // Set the If-None-Match tags
            var noneMatch = null;
            if (ifNoneMatchHeader != null) {
                try {
                    var hr = new HeaderReader(
                            ifNoneMatchHeader);
                    var value = hr.readRawValue();

                    while (value != null) {
                        current = data.Tag.parse(value);

                        // Is it the first tag?
                        if (noneMatch == null) {
                            noneMatch = [];
                            result.setNoneMatch(noneMatch);
                        }

                        noneMatch.add(current);

                        // Read the next token
                        value = hr.readRawValue();
                    }
                } catch (err) {
                    this.context.getLogger().log(
                            Level.INFO,
                            "Unable to process the if-none-match header: "
                                    + ifNoneMatchHeader);
                }
            }

            if (ifRangeHeader != null && ifRangeHeader.length() > 0) {
                var tag = data.Tag.parse(ifRangeHeader);

                if (tag != null) {
                    result.setRangeTag(tag);
                } else {
                    var date = HeaderReader.readDate(ifRangeHeader, false);
                    result.setRangeDate(date);
                }
            }

            this.conditionAdded = true;
        }

        return result;
    },

    getCookies: function() {
        var result = this.callSuper("getCookies");

        if (!this.cookiesAdded) {
            var cookieValues = this.getHttpCall().getRequestHeaders().getValues(
                    HeaderConstants.HEADER_COOKIE);

            if (cookieValues != null) {
                new CookieReader(cookieValues).addValues(result);
            }

            this.cookiesAdded = true;
        }

        return result;
    },

    getEntity: function() {
        if (!this.entityAdded) {
            this.setEntity(this.getHttpCall().getRequestEntity());
            this.entityAdded = true;
        }

        return this.callSuper("getEntity");
    },

    getHeaders: function() {
        return this.getAttributes().get(
                HeaderConstants.ATTRIBUTE_HEADERS);
    },

    getHttpCall: function() {
        return this.httpCall;
    },

    /*public ChallengeResponse getProxyChallengeResponse() {
        ChallengeResponse result = super.getProxyChallengeResponse();

        if (!this.proxySecurityAdded) {
            // Extract the header value
            final String authorization = getHttpCall().getRequestHeaders()
                    .getValues(HeaderConstants.HEADER_PROXY_AUTHORIZATION);

            // Set the challenge response
            result = AuthenticatorUtils.parseResponse(this, authorization,
                    getHttpCall().getRequestHeaders());
            setProxyChallengeResponse(result);
            this.proxySecurityAdded = true;
        }

        return result;
    }*/

    getRanges: function() {
        var result = this.callSuper("getRanges");

        if (!this.rangesAdded) {
            // Extract the header value
            var ranges = this.getHttpCall().getRequestHeaders().getValues(
                    HeaderConstants.HEADER_RANGE);
            result.addAll(RangeReader.read(ranges));

            this.rangesAdded = true;
        }

        return result;
    },

    getRecipientsInfo: function() {
        var result = this.callSuper("getRecipientsInfo");
        if (!recipientsInfoAdded) {
        	var requestViaHeader = this.getHttpCall().getRequestHeaders().getValuesArray(HeaderConstants.HEADER_VIA);
            for (var i=0; i<requestViaHeader.length; i++) {
            	var header = requestViaHeader[i];
                new RecipientInfoReader(header).addValues(result);
            }
            this.recipientsInfoAdded = true;
        }
        return result;
    },

    getReferrerRef: function() {
        if (!this.referrerAdded) {
            var referrerValue = this.getHttpCall().getRequestHeaders()
                    .getValues(HeaderConstants.HEADER_REFERRER);
            if (referrerValue != null) {
                this.setReferrerRef(new data.Reference(referrerValue));
            }

            this.referrerAdded = true;
        }

        return this.callSuper("getReferrerRef");
    },

    getWarnings: function() {
        var result = this.callSuper("getWarnings");
        if (!this.warningsAdded) {
        	var requestWarningHeader = this.getHttpCall().getRequestHeaders().getValuesArray(HeaderConstants.HEADER_WARNING);
            for (var i=0; i<requestWarningHeader.length; i++) {
            	var header = requestWarningHeader[i];
                new WarningReader(header).addValues(result);
            }
            warningsAdded = true;
        }
        return result;
    },

    /*public void setChallengeResponse(ChallengeResponse response) {
        super.setChallengeResponse(response);
        this.securityAdded = true;
    },*/

    setEntity: function(entity) {
        this.callSuper("setEntity", entity);
        this.entityAdded = true;
    },

    /*public void setProxyChallengeResponse(ChallengeResponse response) {
        super.setProxyChallengeResponse(response);
        this.proxySecurityAdded = true;
    },*/

    setRecipientsInfo: function(recipientsInfo) {
    	this.recipientsInfo = recipientsInfo;
        this.recipientsInfoAdded = true;
    },

    setWarnings: function(warnings) {
		this.warnings = warnings;
        this.warningsAdded = true;
    }
});

HttpRequest.extend({
	addHeader: function(request, headerName, headerValue) {
		if (request instanceof HttpRequest) {
			request.getHeaders().add(new Header(headerName, headerValue));
		}
	}
});


var HttpResponse = new commons.Class(Response, {
    initialize: function(httpCall, request) {
        this.callSuperCstr(request);
    	this.request = request;
        this.serverAdded = false;
        this.httpCall = httpCall;

        // Set the properties
        this.setStatus(data.Status.SUCCESS_OK);
    },

    getHeaders: function() {
        return getAttributes().get(
                HeaderConstants.ATTRIBUTE_HEADERS);
    },

    getHttpCall: function() {
        return this.httpCall;
    },

    getServerInfo: function() {
        var result = this.callSuper("getServerInfo");

        if (!this.serverAdded) {
            result.setAddress(this.httpCall.getServerAddress());
            result.setAgent(Engine.VERSION_HEADER);
            result.setPort(this.httpCall.getServerPort());
            this.serverAdded = true;
        }

        return result;
    }
});

HttpResponse.extend({
	addHeader: function(response, headerName, headerValue) {
		if (response instanceof HttpResponse) {
			response.getHeaders().add(headerName, headerValue);
		}
	}
});

//Root entities

var Client = new commons.Class(Connector, {
	initialize: function(context, protocols, helper) {
		//TODO:
		//this.callSuper(context, protocols, helper);
		this.setContext(context);
		this.setProtocols(protocols);
		
		this.configureHelper(helper);
	},
	configureHelper: function(helper) {
		if (this.helper!=null) {
			this.helper = helper;
			return;
		}
		if (this.protocols!=null && this.protocols.length>0) {
			if (Engine.getInstance()!=null) {
				this.helper = Engine.getInstance().createHelper(this);
            } else {
                this.helper = null;
            }
        } else {
            this.helper = null;
		}
	},
	getHelper: function() {
		return this.helper;
	},
	handle: function(request, callback) {
        //this.callSuper(request, callback);

        if (this.getHelper()!=null) {
            this.getHelper().handle(request, callback);
        } else {
            /*StringBuilder sb = new StringBuilder();
            sb.append("No available client connector supports the required protocol: ");
            sb.append("'").append(request.getProtocol().getName()).append("'.");
            sb.append(" Please add the JAR of a matching connector to your classpath.");
            response.setStatus(Status.CONNECTOR_ERROR_INTERNAL, sb.toString());*/
        	//console.log("No available client connector supports the required protocol: ");
        }
    }
});

var Server = new commons.Class(Connector, {
	initialize: function(protocol, address, port, next) {
		//TODO: need to be improved
		this.context = new Context();
		this.protocol = protocol;
		this.address = address;
		this.port = port;
		this.next = next;

        if (Engine.getInstance() != null) {
            this.helper = Engine.getInstance().createHelper(this, null/*helperClass*/);
        } else {
            this.helper = null;
        }
	},
    /*public Server(Context context, List<Protocol> protocols, int port,
            Restlet next) {
        this(context, protocols, null, port, next);
    }

    public Server(Context context, List<Protocol> protocols, String address,
            int port, Restlet next) {
        this(context, protocols, address, port, next, null);
    }

    public Server(Context context, List<Protocol> protocols, String address,
            int port, Restlet next, String helperClass) {
        super(context, protocols);
        this.address = address;
        this.port = port;
        this.next = next;

        if (Engine.getInstance() != null) {
            this.helper = Engine.getInstance().createHelper(this, helperClass);
        } else {
            this.helper = null;
        }

        if (context != null && this.helper != null) {
            context.getAttributes().put("org.restlet.engine.helper",
                    this.helper);
        }
    }

    public Server(Context context, Protocol protocol) {
        this(context, protocol, (protocol == null) ? -1 : protocol
                .getDefaultPort());
    }

    public Server(Context context, Protocol protocol,
            Class<? extends ServerResource> nextClass) {
        this(context, protocol);
        setNext(createFinder(nextClass));
    }

    public Server(Context context, Protocol protocol, int port) {
        this(context, protocol, port, (Restlet) null);
    }

    public Server(Context context, Protocol protocol, int port,
            Class<? extends ServerResource> nextClass) {
        this(context, protocol, port);
        setNext(createFinder(nextClass));
    }

    public Server(Context context, Protocol protocol, int port, Restlet next) {
        this(context, protocol, null, port, next);
    }

    public Server(Context context, Protocol protocol, Restlet next) {
        this(context, protocol, null, (protocol == null) ? -1 : protocol
                .getDefaultPort(), next);
    }

    public Server(Context context, Protocol protocol, String address, int port,
            Restlet next) {
        this(context, (protocol == null) ? null : Arrays.asList(protocol),
                address, port, next);
    }

    public Server(List<Protocol> protocols, int port, Restlet next) {
        this((Context) null, protocols, port, next);
    }

    public Server(List<Protocol> protocols, String address, int port,
            Restlet next) {
        this((Context) null, protocols, address, port, next);
    }

    public Server(Protocol protocol) {
        this((Context) null, protocol, (Restlet) null);
    }

    public Server(Protocol protocol, Class<? extends ServerResource> nextClass) {
        this((Context) null, protocol);
        setNext(createFinder(nextClass));
    }

    public Server(Protocol protocol, int port) {
        this((Context) null, protocol, port, (Restlet) null);
    }

    public Server(Protocol protocol, int port,
            Class<? extends ServerResource> nextClass) {
        this(protocol, port);
        setNext(createFinder(nextClass));
    }

    public Server(Protocol protocol, int port, Restlet next) {
        this((Context) null, protocol, port, next);
    }

    public Server(Protocol protocol, Restlet next) {
        this((Context) null, protocol, next);
    }

    public Server(Protocol protocol, String address) {
        this((Context) null, protocol, address, protocol.getDefaultPort(), null);
    }

    public Server(Protocol protocol, String address,
            Class<? extends ServerResource> nextClass) {
        this(protocol, address);
        setNext(createFinder(nextClass));
    }

    public Server(Protocol protocol, String address, int port) {
        this((Context) null, protocol, address, port, null);
    }

    public Server(Protocol protocol, String address, int port, Restlet next) {
        this((Context) null, protocol, address, port, next);
    }

    public Server(Protocol protocol, String address, Restlet next) {
        this((Context) null, protocol, address, protocol.getDefaultPort(), next);
    }*/

    getActualPort: function() {
        return (this.getPort() == 0) ? this.getEphemeralPort() : getPort();
    },

    getAddress: function() {
        return this.address;
    },

    getEphemeralPort: function() {
        return this.getHelper().getAttributes().get("ephemeralPort");
    },

    getHelper: function() {
        return this.helper;
    },

    getNext: function() {
        return this.next;
    },

    getPort: function() {
        return this.port;
    },

    handle: function(request, response) {
        this.callSuper("handle", request, response);

        if (this.getNext() != null) {
            this.getNext().handle(request, response);
        }
    },

    hasNext: function() {
        return this.next != null;
    },

    isAvailable: function() {
        return this.getHelper() != null;
    },

    setAddress: function(address) {
        this.address = address;
    },

    /*public void setNext(Class<? extends ServerResource> nextClass) {
        setNext(createFinder(nextClass));
    }*/

    setNext: function(next) {
        this.next = next;
    },

    setPort: function(port) {
        this.port = port;
    },

    start: function() {
        if (this.isStopped()) {
            this.callSuper("start");

            if (this.getHelper() != null) {
            	this.getHelper().start();
            }
        }
    },

    stop: function() {
        if (this.isStarted()) {
            if (this.getHelper() != null) {
                this.getHelper().stop();
            }

            this.callSuper("stop");
        }
    }

});

 exports.Server = Server;

var Application = new commons.Class(Restlet, {
	className: "application",
    initialize: function(context) {
        this.callSuperCstr(context);

        if (Engine.getInstance() != null) {
            this.helper = new ApplicationHelper(this);
            this.helper.setContext(context);
        }

        this.outboundRoot = null;
        this.inboundRoot = null;
        this.roles = [];
        this.services = new util.ServiceList(context);
        /*this.services.add(new TunnelService(true, true));*/
        this.services.add(new StatusService());
        /*this.services.add(new DecoderService());
        this.services.add(new EncoderService(false));
        this.services.add(new RangeService());*/
        //this.services.add(new ConnectorService());
        /*this.services.add(new ConnegService());
        this.services.add(new ConverterService());
        this.services.add(new MetadataService());*/
    },

    createInboundRoot: function() {
        return null;
    },

    createOutboundRoot: function() {
        return this.getHelper().getFirstOutboundFilter();
    },

    getConnectorService: function() {
        return this.getServices().get(ConnectorService);
    },

    getConnegService: function() {
        return this.getServices().get(ConnegService);
    },

    getConverterService: function() {
        return this.getServices().get(ConverterService);
    },

    getDecoderService: function() {
        return this.getServices().get(DecoderService);
    },

    getEncoderService: function() {
        return this.getServices().get(EncoderService);
    },

    getHelper: function() {
        return this.helper;
    },

    getInboundRoot: function() {
        if (this.inboundRoot == null) {
            this.inboundRoot = this.createInboundRoot();
            if (this.inboundRoot!=null) {
            	this.inboundRoot.setApplication(this);
            }
        }

        return this.inboundRoot;
    },

    getMetadataService: function() {
        return this.getServices().get(MetadataService);
    },

    getOutboundRoot: function() {
        if (this.outboundRoot == null) {
            this.outboundRoot = this.createOutboundRoot();
            if (this.outboundRoot!=null) {
            	this.outboundRoot.setApplication(this);
            }
        }

        return this.outboundRoot;
    },

    getRangeService: function() {
        return this.getServices().get(RangeService);
    },

    getRole: function(name) {
        for (var i=0; i<this.getRoles().length; i++) {
        	var role = this.getRoles()[i];
            if (role.getName().equals(name)) {
                return role;
            }
        }

        return null;
    },

    getRoles: function() {
        return this.roles;
    },

    getServices: function() {
        return this.services;
    },

    getStatusService: function() {
        return this.getServices().get(StatusService);
    },

    getTunnelService: function() {
        return this.getServices().get(TunnelService);
    },

    handle: function(request, response) {
        this.callSuper("handle", request, response);

        if (this.getHelper() != null) {
        	this.getHelper().handle(request, response);
        }
    },

    /*public synchronized void setClientRoot(
            Class<? extends ServerResource> clientRootClass) {
        setOutboundRoot(clientRootClass);
    }*/

    /*setConnectorService: function(connectorService) {
        this.getServices().set(connectorService);
    },*/

    /*public void setConnegService(ConnegService connegService) {
        getServices().set(connegService);
    }*/

    setContext: function(context) {
        this.callSuper("setContext", context);
        this.getHelper().setContext(context);
        this.getServices().setContext(context);
    },

    /*public void setConverterService(ConverterService converterService) {
        getServices().set(converterService);
    }*/

    /*public void setDecoderService(DecoderService decoderService) {
        getServices().set(decoderService);
    }*/

    /*public void setEncoderService(EncoderService encoderService) {
        getServices().set(encoderService);
    }*/

    /*public synchronized void setInboundRoot(
            Class<? extends ServerResource> inboundRootClass) {
        setInboundRoot(createFinder(inboundRootClass));
    }*/

    setInboundRoot: function(inboundRoot) {
        this.inboundRoot = inboundRoot;

        if ((inboundRoot != null) && (inboundRoot.getContext() == null)) {
            inboundRoot.setContext(getContext());
        }
    },

    /*public void setMetadataService(MetadataService metadataService) {
        getServices().set(metadataService);
    }*/

    /*public synchronized void setOutboundRoot(
            Class<? extends ServerResource> outboundRootClass) {
        setOutboundRoot(createFinder(outboundRootClass));
    }*/

    setOutboundRoot: function(outboundRoot) {
        this.outboundRoot = outboundRoot;

        if ((outboundRoot != null) && (outboundRoot.getContext() == null)) {
            outboundRoot.setContext(getContext());
        }
    },

    /*public void setRangeService(RangeService rangeService) {
        getServices().set(rangeService);
    }*/

    setRoles: function(roles) {
        if (roles != this.getRoles()) {
        	this.getRoles().clear();

            if (roles != null) {
            	this.getRoles().addAll(roles);
            }
        }
    },

    /*public void setStatusService(StatusService statusService) {
        getServices().set(statusService);
    }*/

    /*public void setTunnelService(TunnelService tunnelService) {
        getServices().set(tunnelService);
    }*/

    start: function() {
        if (this.isStopped()) {
            if (this.getHelper() != null) {
            	this.getHelper().start();
            }

            this.getServices().start();

            if (this.getInboundRoot() != null) {
            	this.getInboundRoot().start();
            }

            if (this.getOutboundRoot() != null) {
            	this.getOutboundRoot().start();
            }

            // Must be invoked as a last step
            this.callSuper("start");
        }
    },

    stop: function() {
        if (this.isStarted()) {
            // Must be invoked as a first step
            this.callSuper("stop");

            if (this.getOutboundRoot() != null) {
            	this.getOutboundRoot().stop();
            }

            if (this.getInboundRoot() != null) {
            	this.getInboundRoot().stop();
            }

            this.getServices().stop();

            if (this.getHelper() != null) {
            	this.getHelper().stop();
            }

            // Clear the annotations cache
            //resource.AnnotationUtils.getInstance().clearCache();
        }
    }
});

Application.extend({
	create: function(fnInbound, fnOutbound) {
		var application = new Application();
		application.createInboundRoot = fnInbound;
		if (fnOutbound!=null) {
			application.createOutboundRoot = fnOutbound;
		}
		return application;
	}
});

var Component= new commons.Class(Restlet, {
	initialize: function() {
		this.callSuperCstr();
        this.hosts = [];
        this.clients = new util.ClientList(null);
        this.servers = new util.ServerList(null, this);
        /*this.realms = new CopyOnWriteArrayList<Realm>();*/
        this.services = new util.ServiceList(this.getContext());

        if (Engine.getInstance() != null) {
            this.helper = new ComponentHelper(this);
            var childContext = this.getContext().createChildContext();
            this.defaultHost = new VirtualHost(childContext);
            this.internalRouter = new InternalRouter(childContext);
            /*this.services.add(new LogService());
            getLogService().setContext(childContext);*/
            this.services.add(new StatusService());
            this.getStatusService().setContext(childContext);
            this.clients.setContext(childContext);
            this.servers.setContext(childContext);
        }
	},

	getClients: function() {
		return this.clients;
	},

	getDefaultHost: function() {
		return this.defaultHost;
	},

	getHelper: function() {
		return this.helper;
	},

	getHosts: function() {
		return this.hosts;
	},

	getInternalRouter: function() {
		return this.internalRouter;
	},

	/*getLogService: function() {
		return getServices().get(LogService.class);
	},*/

/*public Realm getRealm(String name) {
    if (name != null) {
        for (Realm realm : getRealms()) {
            if (name.equals(realm.getName())) {
                return realm;
            }
        }
    }

    return null;
}

public List<Realm> getRealms() {
    return realms;
}*/

	getServers: function() {
		return this.servers;
	},

	getServices: function() {
		return this.services;
	},

	getStatusService: function() {
		//return this.getServices().get(StatusService.class);
		return this.getServices()[0];
	},

	handle: function(request, response) {
		this.callSuper("handle", request, response);

		if (this.getHelper() != null) {
			this.getHelper().handle(request, response);
		}
	},

	setClients: function(clients) {
		this.clients = clients;
	},

	setContext: function(context) {
		this.callSuper("setContext", context);
		this.getServices().setContext(context);
	},

	setDefaultHost: function(defaultHost) {
		this.defaultHost = defaultHost;
	},

	setHosts: function(hosts) {
		if (hosts != this.getHosts()) {
			this.getHosts().clear();

			if (hosts != null) {
				this.getHosts().addAll(hosts);
			}
		}
	},

	setInternalRouter: function(internalRouter) {
		this.internalRouter = internalRouter;
	},

	/*setLogService: function(logService) {
		this.getServices().set(logService);
	},*/

/*public void setRealms(List<Realm> realms) {
    synchronized (getRealms()) {
        if (realms != getRealms()) {
            getRealms().clear();

            if (realms != null) {
                getRealms().addAll(realms);
            }
        }
    }
}*/

	setServers: function(servers) {
		this.servers = servers;
	},

	setStatusService: function(statusService) {
		this.getServices().set(statusService);
	},

	start: function() {
		if (this.isStopped()) {
			this.startClients();
			this.startServers();
			this.startRouters();
			/*this.startServices();
			//this.startRealms();*/
			this.startHelper();
			this.callSuper("start");
		}
	},

	startClients: function() {
		if (this.clients != null) {
			for (var i=0; i<this.clients.length; i++) {
				var client = this.clients[i];
				client.start();
			}
		}
	},

	startHelper: function() {
		if (this.getHelper() != null) {
			this.getHelper().start();
		}
	},

/*protected synchronized void startRealms() throws Exception {
    if (this.realms != null) {
        for (Realm realm : this.realms) {
            realm.start();
        }
    }
}*/

	startRouters: function() {
		if (this.internalRouter != null) {
			this.internalRouter.start();
		}

		if (this.defaultHost != null) {
			this.defaultHost.start();
		}

		var hosts = this.getHosts();
		for (var i=0; i<hosts.length; i++) {
			var host = hosts[i];
			host.start();
		}
	},

	startServers: function() {
		if (this.servers != null) {
			for (var i=0; i<this.servers.length; i++) {
				var server = this.servers[i];
				server.start();
			}
		}
	},

	/*startServices: function() {
		this.getServices().start();
	},*/

	stop: function() {
		this.stopHelper();
		//this.stopRealms();
		/*this.stopServices();
		this.stopRouters();*/
		this.stopServers();
		this.stopClients();
		this.callSuper("stop");
	},

	stopClients: function() {
		if (this.clients != null) {
			for (var i=0; i<this.clients.length; i++) {
				var client = this.clients[i];
				client.stop();
			}
		}
	},

	stopHelper: function() {
		if (this.getHelper() != null) {
			this.getHelper().stop();
		}
	},

/*protected synchronized void stopRealms() throws Exception {
    if (this.realms != null) {
        for (Realm realm : this.realms) {
            realm.stop();
        }
    }
}*/

	stopRouters: function() {
		var hosts = this.getHosts();
		for (var i=0; i<hosts.length; i++) {
			var host = hosts[i];
			host.stop();
		}

		if (this.defaultHost != null) {
			this.defaultHost.stop();
		}

		if (this.internalRouter != null) {
			this.internalRouter.stop();
		}
	},

	stopServers: function() {
		if (this.servers != null) {
			for (var i=0; i<this.servers.length; i++) {
				var server = this.servers[i];
				server.stop();
			}
		}
	},

	/*stopServices: function() {
		this.getServices().stop();
	},*/

	updateHosts: function() {
		this.getHelper().update();
	}
});

//Client

var ClientCall = new commons.Class(Call, {
	initialize: function() {
		this.callSuperCstr();
		this.requestHeaders = [];
		this.responseHeaders = [];
	},
	getContentLength: function() {
		return HeaderUtils.getContentLength(this.getResponseHeaders());
	},
	getResponseEntity: function(response) {
        var result = response.getEntity();
        var size = representation.Representation.UNKNOWN_SIZE;

        // Compute the content length
        var responseHeaders = this.getResponseHeaders();
        var transferEncoding = responseHeaders.getFirstValue(
        			HeaderConstants.HEADER_TRANSFER_ENCODING, true);
        if ((transferEncoding != null)
        		&& !"identity".equalsIgnoreCase(transferEncoding)) {
        	size = representation.Representation.UNKNOWN_SIZE;
        } else {
        	size = this.getContentLength();
        }

        if (!this.getMethod().equals(Method.HEAD)
                && !response.getStatus().isInformational()
                && !response.getStatus().equals(data.Status.REDIRECTION_NOT_MODIFIED)
                && !response.getStatus().equals(data.Status.SUCCESS_NO_CONTENT)
                && !response.getStatus().equals(data.Status.SUCCESS_RESET_CONTENT)) {
        	result = response.getEntity();
        }

        if (result != null) {
            result.setSize(size);

            // Informs that the size has not been specified in the header.
            if (size == representation.Representation.UNKNOWN_SIZE) {
                /*getLogger()
                        .fine("The length of the message body is unknown. The entity must be handled carefully and consumed entirely in order to surely release the connection.");*/
            }
        }
        result = HeaderUtils.extractEntityHeaders(responseHeaders, result);

        return result;
    }
});

var NodeJsHttpClientCall = new commons.Class(ClientCall, {
	initialize: function() {
		this.callSuperCstr();
	},
	extractResponseHeaders: function(clientResponse) {
		var headers = [];
		for (var headerName in clientResponse.headers) {
			var header = new data.Parameter(
							headerName,
							clientResponse.headers[headerName]);
			headers.push(header);
		}
		this.setResponseHeaders(headers);
	},
	sendRequest: function(request, callback) {
		var url = request.getResourceRef().toString(true, true);
		var method = request.getMethod().getName();
		this.method = request.getMethod();
		var clientInfo = request.getClientInfo();
		var requestHeaders = {};
		for (var i=0; i<this.requestHeaders.length; i++) {
			var requestHeader = this.requestHeaders[i];
			requestHeaders[requestHeader.getName()] = requestHeader.getValue();
		}
		var data = "";
		if (request.getEntity()!=null) {
			data = request.getEntity().getText();
		}
		var debugHandler = Engine.getInstance().getDebugHandler();
		if (debugHandler!=null && debugHandler.beforeSendingRequest!=null) {
			debugHandler.beforeSendingRequest(url, method, requestHeaders, data);
		}

		var currentThis = this;
		var response = new Response(request);
		var port = request.getResourceRef().getHostPort();
		if (port==-1) {
			if (request.getResourceRef().getScheme()=='http') {
				port = 80;
			} else if (request.getResourceRef().getScheme()=='http') {
				port = 443;
			}
		}
		var host = request.getResourceRef().getHostDomain();
		var path = request.getResourceRef().getPath();

		var requestOptions = {
			host: host,
			port: port,
			path: path,
			method: method,
			headers: requestHeaders
		};
		var clientRequest = http.request(requestOptions);
		
		clientRequest.on("response", function (clientResponse) {
			currentThis.extractResponseHeaders(clientResponse);

			var repr = new representation.Representation();
			repr = HeaderUtils.extractEntityHeaders(
								currentThis.getResponseHeaders(), repr);
			clientResponse.on('data', function (chunk) {
				repr.write({responseText: chunk, responseXML: null});
			});
			clientResponse.on('end', function (chunk) {
				if (debugHandler!=null && debugHandler.afterReceivedResponse!=null) {
					var responseHeaders = {};
					for (var i=0; i<currentThis.responseHeaders.length; i++) {
						var header = currentThis.responseHeaders[i];
						responseHeaders[header.getName()] = header.getValue();
					}
					debugHandler.afterReceivedResponse(clientResponse.statusCode, "", responseHeaders, repr.getText());
				}
				callback(response);
			});
			//TODO: fix me!
			/*var status = new data.Status(clientResponse.statusCode, null);
			response.setStatus(status);*/
			response.setEntity(repr);
		});

		//TODO: problem with the write method on Restlet server side 
		if (data!=null && data!="") {
			//TODO: support chunking
			//TODO: support encoding
			clientRequest.write(data);
		}
		clientRequest.end();
	}
});

var ClientAdapter = new commons.Class(Adapter, {
	initialize: function(context) {
	},
    readResponseHeaders: function(httpCall, response) {
        try {
            var responseHeaders = httpCall.getResponseHeaders();

            // Put the response headers in the call's attributes map
            response.getAttributes()[HeaderConstants.ATTRIBUTE_HEADERS] = responseHeaders;

           HeaderUtils.copyResponseTransportHeaders(responseHeaders, response);
        } catch (err) {
            response.setStatus(data.Status.CONNECTOR_ERROR_INTERNAL, err);
        }
    },
    toSpecific: function(client, request) {
        // Create the low-level HTTP client call
        var result = client.create(request);

        // Add the headers
        if (result != null) {
        	HeaderUtils.addGeneralHeaders(request, result.getRequestHeaders());

            if (request.getEntity() != null) {
            	HeaderUtils.addEntityHeaders(request.getEntity(),
                        result.getRequestHeaders());
            }

            // NOTE: This must stay at the end because the AWS challenge
            // scheme requires access to all HTTP headers
            HeaderUtils.addRequestHeaders(request, result.getRequestHeaders());
        }

        return result;
    },
    updateResponse: function(response, status, httpCall) {
        // Send the request to the client
        response.setStatus(status);

        // Get the server address
        response.getServerInfo().setAddress(httpCall.getServerAddress());
        response.getServerInfo().setPort(httpCall.getServerPort());

    	// Read the response headers
        this.readResponseHeaders(httpCall, response);

    	// Set the entity
        response.setEntity(httpCall.getResponseEntity(response));

        // Release the representation's content for some obvious cases
        if (response.getEntity() != null) {
            if (response.getEntity().getSize() == 0) {
                response.getEntity().release();
            } else if (response.getRequest().getMethod()==data.Method.HEAD) {
                response.getEntity().release();
            } else if (response.getStatus()==data.Status.SUCCESS_NO_CONTENT) {
                response.getEntity().release();
            } else if (response.getStatus()
                    ==data.Status.SUCCESS_RESET_CONTENT) {
                response.getEntity().release();
                response.setEntity(null);
            } else if (response.getStatus()==
            	data.Status.REDIRECTION_NOT_MODIFIED) {
                response.getEntity().release();
            } else if (response.getStatus().isInformational()) {
                response.getEntity().release();
                response.setEntity(null);
            }
        }
    },
    commit: function(httpCall, request, callback) {
    	console.log("1 -commit");
    	if (httpCall != null) {
            // Send the request to the client
        	var currentThis = this;
            httpCall.sendRequest(request, function(response) {
                try {
                	currentThis.updateResponse(response,
                            new data.Status(httpCall.getStatusCode(), null,
                                    httpCall.getReasonPhrase(), null),
                            httpCall);
                    callback(response);
                } catch (err) {
                    // Unexpected exception occurred
                    if ((response.getStatus() == null)
                            || !response.getStatus().isError()) {
                        response.setStatus(
                        		data.Status.CONNECTOR_ERROR_INTERNAL, err);
                        callback(response);
                    }
                }
            });
        }
    }
});

var HttpClientHelper = new commons.Class({
    //public abstract ClientCall create(Request request);
	getAdapter: function() {
        if (this.adapter == null) {
            this.adapter = new ClientAdapter(/*this.getContext()*/);
        }

        return this.adapter;
	},
    handle: function(request, callback) {
        try {
            var clientCall = this.getAdapter().toSpecific(this, request);
            this.getAdapter().commit(clientCall, request, callback);
        } catch (err) {
            this.getLogger().log(Level.INFO,
                    "Error while handling an HTTP client call", e);
        	var response = new Response(request);
            response.setStatus(data.Status.CONNECTOR_ERROR_INTERNAL, err);
            response.setEntity(new representation.Representation());
            callback(response);
        }
    }
});

var NodeJsHttpClientHelper = new commons.Class(HttpClientHelper, {
	initialize: function(client) {
		this.client = client;
	},
	create: function(request) {
		return new NodeJsHttpClientCall();
	}
});

// Server

var Helper = new commons.Class({
	
});

var RestletHelper = new commons.Class(Helper, {
    initialize: function(helped) {
        this.attributes = {};
        this.helped = helped;
    },

    getAttributes: function() {
        return this.attributes;
    },

    getContext: function() {
        return this.getHelped().getContext();
    },

    getHelped: function() {
        return this.helped;
    },

    getHelpedParameters: function() {
        var result = null;

        if ((this.getHelped() != null) && (this.getHelped().getContext() != null)) {
            result = this.getHelped().getContext().getParameters();
        } else {
            result = new util.Series();
        }

        return result;
    },

    getLogger: function() {
        if (this.getHelped() != null && this.getHelped().getContext() != null) {
            return this.getHelped().getContext().getLogger();
        }
        return Context.getCurrentLogger();
    },

    /*public MetadataService getMetadataService() {
        MetadataService result = null;

        if (getHelped() != null) {
            org.restlet.Application application = getHelped().getApplication();

            if (application != null) {
                result = application.getMetadataService();
            }
        }

        if (result == null) {
            result = new MetadataService();
        }

        return result;
    }*/

    handle: function(request, response) {
        /*// [ifndef gwt]
        // Associate the response to the current thread
        Response.setCurrent(response);

        // Associate the context to the current thread
        if (getContext() != null) {
            Context.setCurrent(getContext());
        }
        // [enddef]*/
    },

    setHelped: function(helpedRestlet) {
        this.helped = helpedRestlet;
    },

    start: function() {
    	throw new Error("This method must be overloaded.")
    },

    stop: function() {
    	throw new Error("This method must be overloaded.")
    },

    update: function() {
    	throw new Error("This method must be overloaded.")
    }
});


var ConnectorHelper = new commons.Class(RestletHelper, {
    initialize: function(connector) {
        this.callSuperCstr(connector);
        this.protocols = [];
    },

    getContext: function() {
        /*if (Edition.CURRENT == Edition.GWT) {
            return null;
        }*/

        return this.callSuper("getContext");
    },

    getProtocols: function() {
        return this.protocols;
    },

    start: function() {
    },

    stop: function() {
    },

    update: function() {
    }
});

/*// [ifndef gwt] method
public static org.restlet.service.ConnectorService getConnectorService() {
    org.restlet.service.ConnectorService result = null;
    org.restlet.Application application = org.restlet.Application
            .getCurrent();

    if (application != null) {
        result = application.getConnectorService();
    } else {
        result = new org.restlet.service.ConnectorService();
    }

    return result;
}*/

var ServerHelper = new commons.Class(ConnectorHelper, {
    initialize: function(server) {
        this.callSuperCstr(server);

        // Clear the ephemeral port
        this.getAttributes()["ephemeralPort"] = -1;
    },

    handle: function(request, response) {
        this.callSuper("handle", request, response);
        this.getHelped().handle(request, response);
    },

    setEphemeralPort: function(localPort) {
        // If an ephemeral port is used, make sure we update the attribute for
        // the API
        if (this.getHelped().getPort() == 0) {
        	this.getAttributes()["ephemeralPort"] = localPort;
        }
    },

    stop: function() { 
        this.callSuper("stop");

        // Clear the ephemeral port
        this.getAttributes()["ephemeralPort"] = -1;
    }
});

var Filter = new commons.Class(Restlet, {
	initialize: function() {
    	var context = null;
    	var next = null;
    	if (arguments.length==1) {
    		context = arguments[0];
    	} else if (arguments.length==2) {
    		context = arguments[0];
    		next = arguments[1];
    	}
        this.callSuperCstr(context);
        this.next = next;
    },

    afterHandle: function(request, response) {
        // To be overriden
    },

    beforeHandle: function(request, response) {
        return Filter.CONTINUE;
    },

    doHandle: function(request, response) {
        var result = Filter.CONTINUE;

        if (this.getNext() != null) {
            this.getNext().handle(request, response);

            // Re-associate the response to the current thread
            //Response.setCurrent(response);

            // Associate the context to the current thread
            /*if (this.getContext() != null) {
                Context.setCurrent(getContext());
            }*/
        } else {
            response.setStatus(data.Status.SERVER_ERROR_INTERNAL);
            this.getLogger()
                    .warning(
                            "The filter "
                                    + this.getName()
                                    + " was executed without a next Restlet attached to it.");
        }

        return result;
    },

    getNext: function() {
        return this.next;
    },

    handle: function(request, response) {
        this.callSuper("handle", request, response);

        switch (this.beforeHandle(request, response)) {
        case Filter.CONTINUE:
            switch (this.doHandle(request, response)) {
            case Filter.CONTINUE:
                this.afterHandle(request, response);
                break;

            default:
                // Stop the processing
                break;
            }
            break;

        case Filter.SKIP:
            this.afterHandle(request, response);
            break;

        default:
            // Stop the processing
            break;
        }
    },

    hasNext: function() {
        return this.getNext() != null;
    },

    /*public void setNext(Class<? extends ServerResource> targetClass) {
        setNext(createFinder(targetClass));
    }*/

    setNext: function(next) {
        if ((next != null) && (next.getContext() == null)) {
            next.setContext(this.getContext());
        }

        this.next = next;
    },

    start: function() {
        if (this.isStopped()) {
            if (this.getNext() != null) {
            	this.getNext().start();
            }

            // Must be invoked as a last step
            this.callSuper("start");
        }
    },

    stop: function() {
        if (this.isStarted()) {
            // Must be invoked as a first step
            this.callSuper("stop");

            if (this.getNext() != null) {
                this.getNext().stop();
            }
        }
    }
});

Filter.extend({
    SKIP: 1,
    STOP: 2
});

var Service = new commons.Class({
    initialize: function() {
        this.context = null;
    	var enabled = true;
    	if (arguments.length==1) {
    		enabled = arguments[0];
    	}
    	this.enabled = enabled;
    },

    createInboundFilter: function(context) {
        return null;
    },

    createOutboundFilter: function(context) {
        return null;
    },

    getContext: function() {
        return this.context;
    },

    isEnabled: function() {
        return this.enabled;
    },

    isStarted: function() {
        return this.started;
    },

    isStopped: function() {
        return !this.started;
    },

    setContext: function(context) {
        this.context = context;
    },

    setEnabled: function(enabled) {
        this.enabled = enabled;
    },

    start: function() {
        if (this.isEnabled()) {
            this.started = true;
        }
    },

    stop: function() {
        if (this.isEnabled()) {
            this.started = false;
        }
    }
});

var StatusFilter = new commons.Class(Filter, {
    initialize: function() {
    	var context = arguments[0];
    	this.callSuperCstr(context);

    	var overwriting = null;
        var contactEmail = null;
        var homeRef = null;
        var statusService = null;
    	if (arguments.length==2) {
    		var statusService = arguments[1];
            this.overwriting = statusService.isOverwriting();
            this.contactEmail = statusService.getContactEmail();
            this.homeRef = statusService.getHomeRef();
            this.statusService = statusService;
    	} else if (arguments.length==4) {
            this.overwriting = overwriting;
            this.contactEmail = email;
            this.homeRef = homeRef;
            this.statusService = null;
    	}
    },

    afterHandle: function(request, response) {
        // If no status is set, then the "success ok" status is assumed.
        if (response.getStatus() == null) {
            response.setStatus(data.Status.SUCCESS_OK);
        }

        // Do we need to get a representation for the current status?
        if (response.getStatus().isError()
                && ((response.getEntity() == null) || this.isOverwriting())) {
            response.setEntity(this.getRepresentation(response.getStatus(), request,
                    response));
        }
    },

    doHandle: function(request, response) {
        // Normally handle the call
        try {
            this.callSuper("doHandle", request, response);
        } catch (err) {
        	console.log(err.stack);
            this.getLogger().log(Level.WARNING,
                    "Exception or error caught in status service", err);
            response.setStatus(this.getStatus(err, request, response));
        }

        return Filter.CONTINUE;
    },

    getContactEmail: function() {
        return this.contactEmail;
    },

    getDefaultRepresentation: function(status, request, response) {
        var sb = new commons.StringBuilder();
        sb.append("<html>\n");
        sb.append("<head>\n");
        sb.append("   <title>Status page</title>\n");
        sb.append("</head>\n");
        sb.append("<body style=\"font-family: sans-serif;\">\n");

        sb.append("<p style=\"font-size: 1.2em;font-weight: bold;margin: 1em 0px;\">");
        sb.append(StringUtils.htmlEscape(this.getStatusInfo(status)));
        sb.append("</p>\n");
        if (status.getDescription() != null) {
            sb.append("<p>");
            sb.append(StringUtils.htmlEscape(status.getDescription()));
            sb.append("</p>\n");
        }

        sb.append("<p>You can get technical details <a href=\"");
        sb.append(status.getUri());
        sb.append("\">here</a>.<br>\n");

        if (this.getContactEmail() != null) {
            sb.append("For further assistance, you can contact the <a href=\"mailto:");
            sb.append(this.getContactEmail());
            sb.append("\">administrator</a>.<br>\n");
        }

        if (this.getHomeRef() != null) {
            sb.append("Please continue your visit at our <a href=\"");
            sb.append(this.getHomeRef());
            sb.append("\">home page</a>.\n");
        }

        sb.append("</p>\n");
        sb.append("</body>\n");
        sb.append("</html>\n");

        return new representation.StringRepresentation(sb.toString(), data.MediaType.TEXT_HTML);
    },

    getHomeRef: function() {
        return this.homeRef;
    },

    getRepresentation: function(status, request, response) {
        var result = null;

        try {
            result = this.getStatusService().getRepresentation(status, request,
                    response);
        } catch (err) {
            this.getLogger().log(Level.WARNING,
                    "Unable to get the custom status representation", err);
        }

        if (result == null) {
            result = this.getDefaultRepresentation(status, request, response);
        }

        return result;
    },

    getStatus: function(throwable, request, response) {
        return this.getStatusService().getStatus(throwable, request, response);
    },

    getStatusInfo: function(status) {
        return (status.getReasonPhrase() != null) ? status.getReasonPhrase()
                : "No information available for this result status";
    },

    getStatusService: function() {
        return this.statusService;
    },

    isOverwriting: function() {
        return this.overwriting;
    },

    setContactEmail: function(email) {
        this.contactEmail = email;
    },

    setHomeRef: function(homeRef) {
        this.homeRef = homeRef;
    },

    setOverwriting: function(overwriting) {
        this.overwriting = overwriting;
    },

    setStatusService: function(statusService) {
        this.statusService = statusService;
    },
});

var StatusService = new commons.Class(Service, {
    initialize: function() {
    	var enabled = true;
    	if (arguments.length==1) {
    		enabled = arguments[0];
    	}
    	this.callSuperCstr(enabled);
        this.contactEmail = null;
        this.homeRef = new data.Reference("/");
        this.overwriting = false;
    },

    createInboundFilter: function(context) {
        return new StatusFilter(context, this);
    },

    getContactEmail: function() {
        return this.contactEmail;
    },

    getHomeRef: function() {
        return this.homeRef;
    },

    getRepresentation: function(status, request, response) {
        return null;
    },

    getStatus: function() {
    	console.log("getStatus");
    	var err = null;
    	var request = null;
    	var response = null;
    	if (arguments.length==2) {
        	console.log("getStatus - 1");
    		err = arguments[0];
        	console.log("getStatus - 1 - err = "+err+", arguments[0] = "+arguments[0]);
    		var resource = arguments[1];
    		if (resource!=null) {
    			request = resource.getRequest();
    			response = resource.getResponse();
    		}
    	} else if (arguments.length==3) {
        	console.log("getStatus - 2");
    		err = arguments[0];
        	console.log("getStatus - 2 - err = "+err+", arguments[0] = "+arguments[0]);
    		request = arguments[1];
    		response = arguments[2];
    	}

    	var result = null;

        /*if (err instanceof ResourceException) {
            ResourceException re = (ResourceException) throwable;

            if (re.getCause() != null) {
                // What is most interesting is the embedded cause
                result = new Status(re.getStatus(), re.getCause());
            } else {
                result = re.getStatus();
            }
        } else {*/
    	console.log("getStatus -  err = "+err);
    	if (err!=null) {
        	console.log("getStatus - 3");
    		console.log("err - "+err.stack);
            result = new data.Status(data.Status.SERVER_ERROR_INTERNAL, err);
    	}
        /*}*/

        return result;
    },

    isOverwriting: function() {
        return this.overwriting;
    },

    setContactEmail: function(contactEmail) {
        this.contactEmail = contactEmail;
    },

    setHomeRef: function(homeRef) {
        this.homeRef = homeRef;
    },

    setOverwriting: function(overwriting) {
        this.overwriting = overwriting;
    }
});

var MetadataExtension = new commons.Class({
    initialize: function(name, metadata) {
        this.name = name;
        this.metadata = metadata;
    },

    getCharacterSet: function() {
        return this.getMetadata();
    },

    getEncoding: function() {
        return this.getMetadata();
    },

    getLanguage: function() {
        return this.getMetadata();
    },

    getMediaType: function() {
        return this.getMetadata();
    },

    getMetadata: function() {
        return this.metadata;
    },

    getName: function() {
        return this.name;
    }
});

var MetadataService = new commons.Class(Service, {
    initialize: function() {
        this.defaultCharacterSet = data.CharacterSet.DEFAULT;
        this.defaultEncoding = data.Encoding.IDENTITY;
        this.defaultLanguage = data.Language.DEFAULT;
        // [ifndef gwt] instruction
        this.defaultMediaType = data.MediaType.APPLICATION_OCTET_STREAM;
        // [ifdef gwt] instruction uncomment
        // this.defaultMediaType = data.MediaType.APPLICATION_JSON;
        this.mappings = [];
        this.addCommonExtensions();
    },

    addCommonExtensions: function() {
        var dm = [];

        this.ext(dm, "en", data.Language.ENGLISH);
        this.ext(dm, "es", data.Language.SPANISH);
        this.ext(dm, "fr", data.Language.FRENCH);

        this.ext(dm, "ascii", data.CharacterSet.US_ASCII);

        this.ext(dm, "ai", data.MediaType.APPLICATION_POSTSCRIPT);
        this.ext(dm, "atom", data.MediaType.APPLICATION_ATOM);
        this.ext(dm, "atomcat", data.MediaType.APPLICATION_ATOMPUB_CATEGORY);
        this.ext(dm, "atomsvc", data.MediaType.APPLICATION_ATOMPUB_SERVICE);
        this.ext(dm, "au", data.MediaType.AUDIO_BASIC);
        this.ext(dm, "bin", data.MediaType.APPLICATION_OCTET_STREAM);
        this.ext(dm, "bmp", data.MediaType.IMAGE_BMP);
        this.ext(dm, "class", data.MediaType.APPLICATION_JAVA);
        this.ext(dm, "css", data.MediaType.TEXT_CSS);
        this.ext(dm, "csv", data.MediaType.TEXT_CSV);
        this.ext(dm, "dat", data.MediaType.TEXT_DAT);
        this.ext(dm, "dib", data.MediaType.IMAGE_BMP);
        this.ext(dm, "doc", data.MediaType.APPLICATION_WORD);
        this.ext(dm, "docm", data.MediaType.APPLICATION_MSOFFICE_DOCM);
        this.ext(dm, "docx", data.MediaType.APPLICATION_MSOFFICE_DOCX);
        this.ext(dm, "dotm", data.MediaType.APPLICATION_MSOFFICE_DOTM);
        this.ext(dm, "dotx", data.MediaType.APPLICATION_MSOFFICE_DOTX);
        this.ext(dm, "dtd", data.MediaType.APPLICATION_XML_DTD);
        this.ext(dm, "ecore", data.MediaType.APPLICATION_ECORE);
        this.ext(dm, "eps", data.MediaType.APPLICATION_POSTSCRIPT);
        this.ext(dm, "exe", data.MediaType.APPLICATION_OCTET_STREAM);
        this.ext(dm, "fmt", data.Encoding.FREEMARKER);
        this.ext(dm, "form", data.MediaType.APPLICATION_WWW_FORM);
        this.ext(dm, "ftl", data.Encoding.FREEMARKER, true);
        this.ext(dm, "gif", data.MediaType.IMAGE_GIF);
        this.ext(dm, "gwt", data.MediaType.APPLICATION_JAVA_OBJECT_GWT);
        this.ext(dm, "hqx", data.MediaType.APPLICATION_MAC_BINHEX40);
        this.ext(dm, "ico", data.MediaType.IMAGE_ICON);
        this.ext(dm, "jad", data.MediaType.TEXT_J2ME_APP_DESCRIPTOR);
        this.ext(dm, "jar", data.MediaType.APPLICATION_JAVA_ARCHIVE);
        this.ext(dm, "java", data.MediaType.TEXT_PLAIN);
        this.ext(dm, "jnlp", data.MediaType.APPLICATION_JNLP);
        this.ext(dm, "jpe", data.MediaType.IMAGE_JPEG);
        this.ext(dm, "jpeg", data.MediaType.IMAGE_JPEG);
        this.ext(dm, "jpg", data.MediaType.IMAGE_JPEG);
        this.ext(dm, "js", data.MediaType.APPLICATION_JAVASCRIPT);
        this.ext(dm, "jsf", data.MediaType.TEXT_PLAIN);
        this.ext(dm, "kar", data.MediaType.AUDIO_MIDI);
        this.ext(dm, "latex", data.MediaType.APPLICATION_LATEX);
        this.ext(dm, "latin1", data.CharacterSet.ISO_8859_1);
        this.ext(dm, "mac", data.CharacterSet.MACINTOSH);
        this.ext(dm, "man", data.MediaType.APPLICATION_TROFF_MAN);
        this.ext(dm, "mathml", data.MediaType.APPLICATION_MATHML);
        this.ext(dm, "mid", data.MediaType.AUDIO_MIDI);
        this.ext(dm, "midi", data.MediaType.AUDIO_MIDI);
        this.ext(dm, "mov", data.MediaType.VIDEO_QUICKTIME);
        this.ext(dm, "mp2", data.MediaType.AUDIO_MPEG);
        this.ext(dm, "mp3", data.MediaType.AUDIO_MPEG);
        this.ext(dm, "mp4", data.MediaType.VIDEO_MP4);
        this.ext(dm, "mpe", data.MediaType.VIDEO_MPEG);
        this.ext(dm, "mpeg", data.MediaType.VIDEO_MPEG);
        this.ext(dm, "mpg", data.MediaType.VIDEO_MPEG);
        this.ext(dm, "n3", data.MediaType.TEXT_RDF_N3);
        this.ext(dm, "nt", data.MediaType.TEXT_PLAIN);
        this.ext(dm, "odb", data.MediaType.APPLICATION_OPENOFFICE_ODB);
        this.ext(dm, "odc", data.MediaType.APPLICATION_OPENOFFICE_ODC);
        this.ext(dm, "odf", data.MediaType.APPLICATION_OPENOFFICE_ODF);
        this.ext(dm, "odi", data.MediaType.APPLICATION_OPENOFFICE_ODI);
        this.ext(dm, "odm", data.MediaType.APPLICATION_OPENOFFICE_ODM);
        this.ext(dm, "odg", data.MediaType.APPLICATION_OPENOFFICE_ODG);
        this.ext(dm, "odp", data.MediaType.APPLICATION_OPENOFFICE_ODP);
        this.ext(dm, "ods", data.MediaType.APPLICATION_OPENOFFICE_ODS);
        this.ext(dm, "odt", data.MediaType.APPLICATION_OPENOFFICE_ODT);
        this.ext(dm, "onetoc", data.MediaType.APPLICATION_MSOFFICE_ONETOC);
        this.ext(dm, "onetoc2", data.MediaType.APPLICATION_MSOFFICE_ONETOC2);
        this.ext(dm, "otg", data.MediaType.APPLICATION_OPENOFFICE_OTG);
        this.ext(dm, "oth", data.MediaType.APPLICATION_OPENOFFICE_OTH);
        this.ext(dm, "otp", data.MediaType.APPLICATION_OPENOFFICE_OTP);
        this.ext(dm, "ots", data.MediaType.APPLICATION_OPENOFFICE_OTS);
        this.ext(dm, "ott", data.MediaType.APPLICATION_OPENOFFICE_OTT);
        this.ext(dm, "oxt", data.MediaType.APPLICATION_OPENOFFICE_OXT);
        this.ext(dm, "pdf", data.MediaType.APPLICATION_PDF);
        this.ext(dm, "png", data.MediaType.IMAGE_PNG);
        this.ext(dm, "potx", data.MediaType.APPLICATION_MSOFFICE_POTX);
        this.ext(dm, "potm", data.MediaType.APPLICATION_MSOFFICE_POTM);
        this.ext(dm, "ppam", data.MediaType.APPLICATION_MSOFFICE_PPAM);
        this.ext(dm, "pps", data.MediaType.APPLICATION_POWERPOINT);
        this.ext(dm, "ppsm", data.MediaType.APPLICATION_MSOFFICE_PPSM);
        this.ext(dm, "ppsx", data.MediaType.APPLICATION_MSOFFICE_PPSX);
        this.ext(dm, "ppt", data.MediaType.APPLICATION_POWERPOINT);
        this.ext(dm, "pptm", data.MediaType.APPLICATION_MSOFFICE_PPTM);
        this.ext(dm, "pptx", data.MediaType.APPLICATION_MSOFFICE_PPTX);
        this.ext(dm, "ps", data.MediaType.APPLICATION_POSTSCRIPT);
        this.ext(dm, "qt", data.MediaType.VIDEO_QUICKTIME);
        this.ext(dm, "rdf", data.MediaType.APPLICATION_RDF_XML);
        this.ext(dm, "rnc", data.MediaType.APPLICATION_RELAXNG_COMPACT);
        this.ext(dm, "rng", data.MediaType.APPLICATION_RELAXNG_XML);
        this.ext(dm, "rss", data.MediaType.APPLICATION_RSS);
        this.ext(dm, "rtf", data.MediaType.APPLICATION_RTF);
        this.ext(dm, "sav", data.MediaType.APPLICATION_SPSS_SAV);
        this.ext(dm, "sit", data.MediaType.APPLICATION_STUFFIT);
        this.ext(dm, "sldm", data.MediaType.APPLICATION_MSOFFICE_SLDM);
        this.ext(dm, "sldx", data.MediaType.APPLICATION_MSOFFICE_SLDX);
        this.ext(dm, "snd", data.MediaType.AUDIO_BASIC);
        this.ext(dm, "sps", data.MediaType.APPLICATION_SPSS_SPS);
        this.ext(dm, "sta", data.MediaType.APPLICATION_STATA_STA);
        this.ext(dm, "svg", data.MediaType.IMAGE_SVG);
        this.ext(dm, "swf", data.MediaType.APPLICATION_FLASH);
        this.ext(dm, "tar", data.MediaType.APPLICATION_TAR);
        this.ext(dm, "tex", data.MediaType.APPLICATION_TEX);
        this.ext(dm, "tif", data.MediaType.IMAGE_TIFF);
        this.ext(dm, "tiff", data.MediaType.IMAGE_TIFF);
        this.ext(dm, "tsv", data.MediaType.TEXT_TSV);
        this.ext(dm, "ulw", data.MediaType.AUDIO_BASIC);
        this.ext(dm, "utf16", data.CharacterSet.UTF_16);
        this.ext(dm, "utf8", data.CharacterSet.UTF_8);
        this.ext(dm, "vm", data.Encoding.VELOCITY);
        this.ext(dm, "vrml", data.MediaType.MODEL_VRML);
        this.ext(dm, "vxml", data.MediaType.APPLICATION_VOICEXML);
        this.ext(dm, "wadl", data.MediaType.APPLICATION_WADL);
        this.ext(dm, "wav", data.MediaType.AUDIO_WAV);
        this.ext(dm, "win", data.CharacterSet.WINDOWS_1252);
        this.ext(dm, "wrl", data.MediaType.MODEL_VRML);
        this.ext(dm, "xht", data.MediaType.APPLICATION_XHTML);
        this.ext(dm, "xls", data.MediaType.APPLICATION_EXCEL);
        this.ext(dm, "xlsx", data.MediaType.APPLICATION_MSOFFICE_XLSX);
        this.ext(dm, "xlsm", data.MediaType.APPLICATION_MSOFFICE_XLSM);
        this.ext(dm, "xltx", data.MediaType.APPLICATION_MSOFFICE_XLTX);
        this.ext(dm, "xltm", data.MediaType.APPLICATION_MSOFFICE_XLTM);
        this.ext(dm, "xlsb", data.MediaType.APPLICATION_MSOFFICE_XLSB);
        this.ext(dm, "xlam", data.MediaType.APPLICATION_MSOFFICE_XLAM);
        this.ext(dm, "xmi", data.MediaType.APPLICATION_XMI);
        this.ext(dm, "xsd", data.MediaType.APPLICATION_W3C_SCHEMA);
        this.ext(dm, "xsl", data.MediaType.APPLICATION_W3C_XSLT);
        this.ext(dm, "xslt", data.MediaType.APPLICATION_W3C_XSLT);
        this.ext(dm, "xul", data.MediaType.APPLICATION_XUL);
        this.ext(dm, "yaml", data.MediaType.APPLICATION_YAML);
        this.ext(dm, "yaml", data.MediaType.TEXT_YAML);
        this.ext(dm, "z", data.MediaType.APPLICATION_COMPRESS);
        this.ext(dm, "zip", data.MediaType.APPLICATION_ZIP);
        this.ext(dm, "htm", data.MediaType.TEXT_HTML);
        this.ext(dm, "html", data.MediaType.TEXT_HTML);
        this.ext(dm, "json", data.MediaType.APPLICATION_JSON);
        this.ext(dm, "txt", data.MediaType.TEXT_PLAIN, true);
        this.ext(dm, "xhtml", data.MediaType.APPLICATION_XHTML);
        this.ext(dm, "xml", data.MediaType.TEXT_XML);
        this.ext(dm, "xml", data.MediaType.APPLICATION_XML);

        // Add all those mappings
        this.mappings.addAll(dm);
    },

    addExtension: function(extension, metadata, preferred) {
    	if (preferred==null) {
    		preferred = false;
    	}
        if (preferred) {
            // Add the mapping at the beginning of the list
            this.mappings.add(0, new MetadataExtension(extension, metadata));
        } else {
            // Add the mapping at the end of the list
            this.mappings.add(new MetadataExtension(extension, metadata));
        }
    },

    clearExtensions: function() {
        this.mappings.clear();
    },

    ext: function(extensions, extension, metadata, preferred) {
    	if (preferred==null) {
    		preferred = false;
    	}
        if (preferred) {
            // Add the mapping at the beginning of the list
            extensions.add(0, new MetadataExtension(extension, metadata));
        } else {
            // Add the mapping at the end of the list
            extensions.add(new MetadataExtension(extension, metadata));
        }
    },

    getAllCharacterSetExtensionNames: function() {
        var result = [];

        for (var i=0; i<this.mappings.length; i++) {
        	var mapping = this.mappings[i];
            if ((mapping.getMetadata() instanceof data.CharacterSet)
                    && !result.contains(mapping.getName())) {
                result.push(mapping.getName());
            }
        }

        return result;
    },

    getAllCharacterSets: function(extension) {
        var result = null;

        if (extension != null) {
            // Look for all registered convenient mapping.
            for (var i=0; i<this.mappings.length; i++) {
            	var metadataExtension = this.mappings[i];
                if (extension.equals(metadataExtension.getName())
                        && (metadataExtension.getMetadata() instanceof data.CharacterSet)) {
                    if (result == null) {
                        result = [];
                    }

                    result.push(metadataExtension.getCharacterSet());
                }
            }
        }

        return result;
    },

    getAllEncodingExtensionNames: function() {
        var result = [];

        for (var i=0; i<this.mappings.length; i++) {
        	var mapping = this.mappings[i];
            if ((mapping.getMetadata() instanceof data.Encoding)
                    && !result.contains(mapping.getName())) {
                result.push(mapping.getName());
            }
        }

        return result;
    },

    getAllExtensionNames: function() {
        var result = [];

        for (var i=0; i<this.mappings.length; i++) {
        	var mapping = this.mappings[i];
            if (!result.contains(mapping.getName())) {
                result.push(mapping.getName());
            }
        }

        return result;
    },

    getAllLanguageExtensionNames: function() {
        var result = [];

        for (var i=0; i<this.mappings.length; i++) {
        	var mapping = this.mappings[i];
            if ((mapping.getMetadata() instanceof data.Language)
                    && !result.contains(mapping.getName())) {
                result.push(mapping.getName());
            }
        }

        return result;
    },

    getAllLanguages: function(extension) {
        var result = null;

        if (extension != null) {
            // Look for all registered convenient mapping.
            for (var i=0; i<this.mappings.length; i++) {
            	var metadataExtension = this.mappings[i];
                if (extension.equals(metadataExtension.getName())
                        && (metadataExtension.getMetadata() instanceof data.Language)) {
                    if (result == null) {
                        result = [];
                    }

                    result.push(metadataExtension.getLanguage());
                }
            }
        }

        return result;
    },

    getAllMediaTypeExtensionNames: function() {
        var result = [];

        for (var i=0; i<this.mappings.length; i++) {
        	var mapping = this.mappings[i];
            if ((mapping.getMetadata() instanceof data.MediaType)
                    && !result.contains(mapping.getName())) {
                result.add(mapping.getName());
            }
        }

        return result;
    },

    getAllMediaTypes: function(extension) {
        var result = null;

        if (extension != null) {
            // Look for all registered convenient mapping.
            for (var i=0; i<this.mappings.length; i++) {
            	var metadataExtension = this.mappings[i];
                if (extension.equals(metadataExtension.getName())
                        && (metadataExtension.getMetadata() instanceof data.MediaType)) {
                    if (result == null) {
                        result = [];
                    }

                    result.add(metadataExtension.getMediaType());
                }
            }
        }

        return result;
    },

    getAllMetadata: function(extension) {
        var result = null;

        if (extension != null) {
            // Look for all registered convenient mapping.
            for (var i=0; i<this.mappings.length; i++) {
            	var metadataExtension = this.mappings[i];
                if (extension.equals(metadataExtension.getName())) {
                    if (result == null) {
                        result = [];
                    }

                    result.add(metadataExtension.getMetadata());
                }
            }
        }

        return result;
    },

    getCharacterSet: function(extension) {
        var metadata = this.getMetadata(extension);
        if (metadata instanceof data.CharacterSet) {
        	return metadata;
        } else {
        	return null;
        }
    },

    getDefaultCharacterSet: function() {
        return this.defaultCharacterSet;
    },

    getDefaultEncoding: function() {
        return this.defaultEncoding;
    },

    getDefaultLanguage: function() {
        return this.defaultLanguage;
    },

    getDefaultMediaType: function() {
        return this.defaultMediaType;
    },

    getEncoding: function(extension) {
        var metadata = this.getMetadata(extension);
        if (metadata instanceof Encoding) {
        	return metadata;
        } else {
        	return null;
        }
    },

    getExtension: function(metadata) {
        if (metadata != null) {
            // Look for the first registered convenient mapping.
            for (var i=0; i<this.mappings.length; i++) {
            	var metadataExtension = this.mappings[i];
                if (metadata.equals(metadataExtension.getMetadata())) {
                    return metadataExtension.getName();
                }
            }
        }
        return null;
    },

    getLanguage: function(extension) {
        var metadata = this.getMetadata(extension);
        if (metadata instanceof data.Language) {
        	return metadata;
        } else {
        	return null;
        }
    },

    getMediaType: function(extension) {
    	var metadata = this.getMetadata(extension);
    	if (metadata instanceof data.MediaType) {
    		return metadata;
    	} else {
    		return null;
    	}
    },

    getMetadata: function(extension) {
        if (extension != null) {
            // Look for the first registered convenient mapping.
            for (var i=0; i<this.mappings.length; i++) {
            	var metadataExtension = this.mappings[i];
                if (extension.equals(metadataExtension.getName())) {
                    return metadataExtension.getMetadata();
                }
            }
        }

        return null;
    },

    setDefaultCharacterSet: function(defaultCharacterSet) {
        this.defaultCharacterSet = defaultCharacterSet;
    },

    setDefaultEncoding: function(defaultEncoding) {
        this.defaultEncoding = defaultEncoding;
    },

    setDefaultLanguage: function(defaultLanguage) {
        this.defaultLanguage = defaultLanguage;
    },

    setDefaultMediaType: function(defaultMediaType) {
        this.defaultMediaType = defaultMediaType;
    }
});

var ConverterService = new commons.Class(Service, {
    initialize: function(enabled) {
    	
    }
});

var Conneg = new commons.Class({
    initialize: function(request, metadataService) {
        this.request = request;
    },

    getRequest: function() {
        return this.request;
    },

    getPreferredVariant: function(variants) {
        var result = null;

        if ((variants != null) && !variants.isEmpty()) {
            var bestScore = -1.0;
            var current;

            // Compute the score of each variant
            for (var i=0; i<variants.length; i++) {
            	var variant = variants[i];
                current = this.scoreVariant(variant);

                if (current > bestScore) {
                    bestScore = current;
                    result = variant;
                }
            }
        }

        return result;
    },

    scoreVariant: function(variant) {
    	return 0;
    }
});

var StrictConneg = new commons.Class(Conneg, {
    initialize: function(request, metadataService) {
        this.callSuperCstr(request, metadataService);
    },

    getCharacterSetPrefs: function() {
        return this.getRequest().getClientInfo().getAcceptedCharacterSets();
    },

    getEncodingPrefs: function() {
        return this.getRequest().getClientInfo().getAcceptedEncodings();
    },

    getLanguagePrefs: function() {
        return this.getRequest().getClientInfo().getAcceptedLanguages();
    },

    getMediaTypePrefs: function() {
        return this.getRequest().getClientInfo().getAcceptedMediaTypes();
    },

    scoreAnnotation: function(annotation) {
        var result = -1.0;

        if (annotation != null) {
            if (annotation.getQuery() != null) {
                if ((this.getRequest().getResourceRef() == null)
                        || (this.getRequest().getResourceRef().getQuery() == null)) {
                    // Query constraint defined, but no query provided, no fit
                    result = -1.0;
                } else {
                    // Query constraint defined and a query provided, see if fit
                    var constraintParams = new data.Form(annotation.getQuery());
                    var actualParams = this.getRequest().getResourceRef()
                            .getQueryAsForm();
                    var matchedParams = [];
                    var constraintParam;
                    var actualParam;

                    var allConstraintsMatched = true;
                    var constraintMatched = false;

                    // Verify that each query constraint has been matched
                    for (var i = 0; (i < constraintParams.size())
                            && allConstraintsMatched; i++) {
                        constraintParam = constraintParams.get(i);
                        constraintMatched = false;

                        for (var j = 0; j < actualParams.size(); j++) {
                            actualParam = actualParams.get(j);

                            if (constraintParam.getName().equals(
                                    actualParam.getName())) {
                                // Potential match found based on name
                                if ((constraintParam.getValue() == null)
                                        || constraintParam.getValue().equals(
                                                actualParam.getValue())) {
                                    // Actual match found!
                                    constraintMatched = true;
                                    matchedParams.add(actualParam);
                                }
                            }
                        }

                        allConstraintsMatched = allConstraintsMatched
                                && constraintMatched;
                    }

                    // Test if all actual query parameters matched a constraint,
                    // so
                    // increase score
                    var allActualMatched = (actualParams.size() == matchedParams
                            .size());

                    if (allConstraintsMatched) {
                        if (allActualMatched) {
                            // All filter parameters matched, no additional
                            // parameter found
                            result = 1.0;
                        } else {
                            // All filter parameters matched, but additional
                            // parameters found
                            result = 0.75;
                        }
                    } else {
                        result = -1.0;
                    }
                }
            } else {
                if ((this.getRequest().getResourceRef() == null)
                        || (this.getRequest().getResourceRef().getQuery() == null)) {
                    // No query filter, but no query provided, average fit
                    result = 0.5;
                } else {
                    // No query filter, but a query provided, lower fit
                    result = 0.25;
                }
            }

            /*if (Context.getCurrentLogger().isLoggable(Level.FINE)) {
                Context.getCurrentLogger()
                        .fine("Score of annotation \"" + annotation + "\"= "
                                + result);
            }*/
        } else {
            result = 0.0;
        }

        return result;
    },

    scoreCharacterSet: function(characterSet) {
        return this.scoreMetadata(characterSet, this.getCharacterSetPrefs());
    },

    scoreEncodings: function(encodings) {
        return this.scoreMetadata(encodings, this.getEncodingPrefs());
    },

    scoreLanguages: function(languages) {
        return this.scoreMetadata(languages, this.getLanguagePrefs());
    },

    scoreMediaType: function(mediaType) {
        return this.scoreMetadata(mediaType, this.getMediaTypePrefs());
    },

    scoreMetadata: function() {
    	if (arguments.length==2) {
    		if (arguments[0] instanceof data.Metadata) {
    			return this._scoreMetadataSimple.apply(this, arguments);
    		} else {
    			return this._scoreMetadataList.apply(this, arguments);
    		}
    	}
    },

    _scoreMetadataList: function(metadataList, prefs) {
        var result = -1.0;
        var current;

        if ((metadataList != null) && !metadataList.isEmpty()) {
            for (var i=0; i<prefs.length; i++) {
            	var pref = prefs[i];
                for (var j=0; j<metadataList.length; j++) {
                	var metadata = metadataList[j];
                    if (pref.getMetadata().includes(metadata)) {
                        current = pref.getQuality();
                    } else {
                        current = -1.0;
                    }

                    if (current > result) {
                        result = current;
                    }
                }
            }
        } else {
            result = 0.0;
        }

        return result;
    },

    _scoreMetadataSimple: function(metadata, prefs) {
        var result = -1.0;
        var current;

        if (metadata != null) {
            for (var i=0; i<prefs.length; i++) {
            	var pref = prefs[i];
                if (pref.getMetadata().includes(metadata)) {
                    current = pref.getQuality();
                } else {
                    current = -1.0;
                }

                if (current > result) {
                    result = current;
                }
            }
        } else {
            result = 0.0 ;
        }

        return result;
    },

    scoreVariant: function(variant) {
        var result = -1.0;
        var languageScore = this.scoreLanguages(variant.getLanguages());

        if (languageScore != -1.0) {
            var mediaTypeScore = this.scoreMediaType(variant.getMediaType());

            if (mediaTypeScore != -1.0) {
                var characterSetScore = this.scoreCharacterSet(variant
                        .getCharacterSet());

                if (characterSetScore != -1.0) {
                    var encodingScore = this.scoreEncodings(variant.getEncodings());

                    if (encodingScore != -1.0) {
                        if (variant instanceof resource.VariantInfo) {
                            var annotationScore = this.scoreAnnotation(variant
                                    .getAnnotationInfo());

                            // Return the weighted average score
                            result = ((languageScore * 4.0)
                                    + (mediaTypeScore * 3.0)
                                    + (characterSetScore * 2.0)
                                    + (encodingScore * 1.0) + (annotationScore * 2.0)) / 12.0;
                            // Take into account the affinity with the input entity
                            result = result * variant.getInputScore();
                        } else {
                            // Return the weighted average score
                            result = ((languageScore * 4.0)
                                    + (mediaTypeScore * 3.0)
                                    + (characterSetScore * 2.0) + (encodingScore * 1.0)) / 10.0;
                        }
                    }
                }
            }
        }

        /*if (Context.getCurrentLogger().isLoggable(Level.FINE)) {
            Context.getCurrentLogger().fine(
                    "Total score of variant \"" + variant + "\"= " + result);
        }*/

        return result;
    }
});

var FlexibleConneg = new commons.Class(StrictConneg, {
    initialize: function(request, metadataService) {
        this.callSuperCstr(request, metadataService);
        var clientInfo = request.getClientInfo();

        if (clientInfo != null) {
            // Get the enriched user preferences
            this.languagePrefs = this.getEnrichedPreferences(
                    clientInfo.getAcceptedLanguages(),
                    (metadataService == null) ? null : metadataService
                            .getDefaultLanguage(), data.Language.ALL);
            this.mediaTypePrefs = this.getEnrichedPreferences(
                    clientInfo.getAcceptedMediaTypes(),
                    (metadataService == null) ? null : metadataService
                            .getDefaultMediaType(), data.MediaType.ALL);
            this.characterSetPrefs = this.getEnrichedPreferences(
                    clientInfo.getAcceptedCharacterSets(),
                    (metadataService == null) ? null : metadataService
                            .getDefaultCharacterSet(), data.CharacterSet.ALL);
            this.encodingPrefs = this.getEnrichedPreferences(
                    clientInfo.getAcceptedEncodings(),
                    (metadataService == null) ? null : metadataService
                            .getDefaultEncoding(), data.Encoding.ALL);
        }
    },

    canAdd: function(metadata, undesired) {
        var add = true;
        if (undesired != null) {
            for (var i=0; i<undesired.length; i++) {
            	var u = undesired[i];
                if (u.equals(metadata)) {
                    add = false;
                    break;
                }
            }
        }

        return add;
    },

    getCharacterSetPrefs: function() {
        return this.characterSetPrefs;
    },

    getEncodingPrefs: function() {
        return this.encodingPrefs;
    },

    getEnrichedPreferences: function(userPreferences, defaultValue, allValue) {
        var result = [];

        // 0) List all undesired metadata
        var undesired = null;
        for (var i=0; i<userPreferences.length; i++) {
        	var pref = userPreferences[i];
            if (pref.getQuality() == 0) {
                if (undesired == null) {
                    undesired = [];
                }
                undesired.add(pref.getMetadata());
            }
        }

        // 1) Add the user preferences
        result.addAll(userPreferences);

        // 2) Add the user parent preferences
        var parent;
        for (var i = 0; i < result.length; i++) {
            var userPref = result[i];
            parent = userPref.getMetadata().getParent();

            // Add the parent, if it is not proscribed.
            if ((parent != null)) {
                if (this.canAdd(parent, undesired)) {
                    result.add(new data.Preference(parent,
                            0.005 + (0.001 * userPref.getQuality())));
                }
            }
        }

        // 3) Add the default preference
        if (defaultValue != null && this.canAdd(defaultValue, undesired)) {
            var defaultPref = new data.Preference(defaultValue, 0.003);
            result.add(defaultPref);
            var defaultParent = defaultValue.getParent();

            if (defaultParent != null && this.canAdd(defaultParent, undesired)) {
                result.add(new data.Preference(defaultParent, 0.002));
            }
        }

        // 5) Add "all" preference
        for (var i = result.length - 1; i >= 0; i--) {
            // Remove any existing preference
            if (result[i].getMetadata().equals(allValue)) {
                result.remove(i);
            }
        }

        result.add(new data.Preference(allValue, 0.001));

        // 6) Return the enriched preferences
        return result;
    },

    getLanguagePrefs: function() {
        return this.languagePrefs;
    },

    getMediaTypePrefs: function() {
        return this.mediaTypePrefs;
    }
});

var ConnegService = new commons.Class(Service, {
    initialize: function(enabled) {
    	if (enabled==null) {
    		enabled = true;
    	}
        this.callSuperCstr(enabled);
        this.strict = false;
    },

    getPreferredVariant: function(variants, request, metadataService) {
        var conneg = this.isStrict() ? new StrictConneg(request, metadataService)
                : new FlexibleConneg(request, metadataService);
        return conneg.getPreferredVariant(variants);
    },

    isStrict: function() {
        return this.strict;
    },

    setStrict: function(strict) {
        this.strict = strict;
    }
});

var Route = new commons.Class(Filter, {
    initialize: function() {
    	var router = null;
    	var next = null;
    	if (arguments.length==1) {
    		next = arguments[0];
    	} else if (arguments.length==2) {
    		router = arguments[0];
    		next = arguments[1];
    	}

        this.callSuperCstr((router != null) ? router.getContext() : (next != null) ? next
                .getContext() : null, next);
        this.router = router;
    },

    getRouter: function() {
        return this.router;
    },

    score: function(request, response) {
    	throw new Error("This method must be implemented.");
    },

    setRouter: function(router) {
        this.router = router;
    },
    
    setApplication: function(application) {
    	this.callSuper("setApplication", application);
    	if (this.next!=null) {
    		this.next.setApplication(application);
    	}
    }
});

var Router = new commons.Class(Restlet, {
	className: "Router",
    initialize: function(context) {
    	var context = null;
    	if (arguments.length==1) {
    		context = arguments[0];
    	}
        this.callSuperCstr(context);
        this.routes = new util.RouteList();
        this.defaultMatchingMode = Template.MODE_EQUALS;
        this.defaultMatchingQuery = false;
        this.defaultRoute = null;
        this.routingMode = Router.MODE_FIRST_MATCH;
        this.requiredScore = 0.5;
        /*this.maxAttempts = 1;
        this.retryDelay = 500;*/
    },

    /*public TemplateRoute attach(String pathTemplate,
            Class<? extends ServerResource> targetClass) {
        return attach(pathTemplate, createFinder(targetClass));
    }

    public TemplateRoute attach(String pathTemplate,
            Class<? extends ServerResource> targetClass, int matchingMode) {
        return attach(pathTemplate, createFinder(targetClass), matchingMode);
    }*/
    
    _checkTarget: function(target) {
    	if (typeof target == "function") {
        	/*console.log("_checkTarget - 1");
    		var restlet = new Restlet();
    		restlet.handle = target;
    		return restlet;
    	} else if (target instanceof resource.ServerResource) {*/
    		return this.createFinder(target);
    	} else {
    		return target;
    	}
    },

    attach: function() {
    	var pathTemplate = "";
    	var target = null;
        var matchingMode = null;
        if (arguments.length==1) {
        	pathTemplate = "";
        	target = this._checkTarget(arguments[0]);
        	matchingMode = this.getMatchingMode(target);
        } else if (arguments.length==2) {
        	if (typeof arguments[0] == "string") {
            	pathTemplate = arguments[0];
            	target = this._checkTarget(arguments[1]);
            	matchingMode = this.getMatchingMode(target);
        	} else {
            	pathTemplate = "";
            	target = this._checkTarget(arguments[0]);
            	matchingMode = arguments[1];
        	}
        } else if (arguments.length==3) {
        	pathTemplate = arguments[0];
        	target = this._checkTarget(arguments[1]);
        	matchingMode = arguments[2];
        }

        var result = this.createRoute(pathTemplate, target, matchingMode);
        this.getRoutes().add(result);
        return result;
    },

    attachDefault: function(defaultTarget) {
        var result = this.createRoute("", this._checkTarget(defaultTarget));
        result.setMatchingMode(Template.MODE_STARTS_WITH);
        this.setDefaultRoute(result);
        return result;
    },

    createRoute: function() {
    	var uriPattern = arguments[0];
    	var target = arguments[1];
    	if (arguments.length==3) {
    		matchingMode = arguments[2];
    	} else if (arguments.length<3) {
    		matchingMode = this.getMatchingMode(target);
    	}
        var result = new TemplateRoute(this, uriPattern, target);
        result.getTemplate().setMatchingMode(matchingMode);
        result.setMatchingQuery(this.getDefaultMatchingQuery());
        return result;
    },

    /*public void detach(Class<?> targetClass) {
        for (int i = getRoutes().size() - 1; i >= 0; i--) {
            Restlet target = getRoutes().get(i).getNext();

            if (target != null
                    && Finder.class.isAssignableFrom(target.getClass())) {
                Finder finder = (Finder) target;

                if (finder.getTargetClass().equals(targetClass)) {
                    getRoutes().remove(i);
                }
            }
        }

        if (getDefaultRoute() != null) {
            Restlet target = getDefaultRoute().getNext();

            if (target != null
                    && Finder.class.isAssignableFrom(target.getClass())) {
                Finder finder = (Finder) target;

                if (finder.getTargetClass().equals(targetClass)) {
                    setDefaultRoute(null);
                }
            }
        }
    }*/

    detach: function(target) {
        this.getRoutes().removeAll(target);
        if ((this.getDefaultRoute() != null)
                && (this.getDefaultRoute().getNext() == target)) {
            this.setDefaultRoute(null);
        }
    },

    doHandle: function(next, request, response) {
   		next.handle(request, response);
    },

    getCustom: function(request, response) {
        return null;
    },

    getDefaultMatchingMode: function() {
        return this.defaultMatchingMode;
    },

    getDefaultMatchingQuery: function() {
        return this.defaultMatchingQuery;
    },

    getDefaultRoute: function() {
        return this.defaultRoute;
    },

    getMatchingMode: function(target) {
        var result = this.getDefaultMatchingMode();

        if (/*(target instanceof resource.Directory) || */(target instanceof Router)) {
            result = Template.MODE_STARTS_WITH;
        } else if (target instanceof Filter) {
            result = this.getMatchingMode(target.getNext());
        }

        return result;
    },

    /*public int getMaxAttempts() {
        return this.maxAttempts;
    }*/

    getNext: function(request, response) {
        var result = null;
        
        //Removed attempt processing
        if (this.routes != null) {
            // Select the routing mode
            switch (this.getRoutingMode()) {
            	case Router.MODE_BEST_MATCH:
            		result = this.getRoutes().getBest(request, response,
            				this.getRequiredScore());
            		break;

            	case Router.MODE_FIRST_MATCH:
            		result = this.getRoutes().getFirst(request, response,
            				this.getRequiredScore());
            		break;

            	case Router.MODE_LAST_MATCH:
            		result = this.getRoutes().getLast(request, response,
            				this.getRequiredScore());
            		break;

            	case Router.MODE_NEXT_MATCH:
            		result = this.getRoutes().getNext(request, response,
            				this.getRequiredScore());
            		break;

            	case Router.MODE_RANDOM_MATCH:
            		result = this.getRoutes().getRandom(request, response,
            				this.getRequiredScore());
            		break;

            	case Router.MODE_CUSTOM:
            		result = this.getCustom(request, response);
            		break;
            }
        }

        if (result == null) {
            // If nothing matched in the routes list,
            // check the default route
            if ((this.getDefaultRoute() != null)
                    && (this.getDefaultRoute().score(request, response) >= this.getRequiredScore())) {
                result = this.getDefaultRoute();
            } else {
                // No route could be found
                response.setStatus(data.Status.CLIENT_ERROR_NOT_FOUND);
            }
        }

        if (request.isLoggable()) {
            this.logRoute(result);
        }

        return result;
    },

    getRequiredScore: function() {
        return this.requiredScore;
    },

    /*public long getRetryDelay() {
        return this.retryDelay;
    },*/

    //RouteList
    getRoutes: function() {
        return this.routes;
    },

    getRoutingMode: function() {
        return this.routingMode;
    },

    handle: function(request, response) {
        this.callSuper("handle", request, response);
        var next = this.getNext(request, response);

        if (next != null) {
            this.doHandle(next, request, response);
        } else {
            response.setStatus(data.Status.CLIENT_ERROR_NOT_FOUND);
        }
    },

    logRoute: function(route) {
        if (this.getLogger().isLoggable(Level.FINE)) {
            if (this.getDefaultRoute() == route) {
            	this.getLogger().fine("The default route was selected");
            } else {
            	this.getLogger().fine("Selected route: " + route);
            }
        }
    },

    setDefaultMatchingMode: function(defaultMatchingMode) {
        this.defaultMatchingMode = defaultMatchingMode;
    },

    setDefaultMatchingQuery: function(defaultMatchingQuery) {
        this.defaultMatchingQuery = defaultMatchingQuery;
    },

    setDefaultRoute: function(defaultRoute) {
        this.defaultRoute = defaultRoute;
    },

    /*setMaxAttempts: function(maxAttempts) {
        this.maxAttempts = maxAttempts;
    },*/

    setRequiredScore: function(score) {
        this.requiredScore = score;
    },

    /*public void setRetryDelay(long retryDelay) {
        this.retryDelay = retryDelay;
    },*/

    setRoutes: function(routes) {
        this.routes = routes;
    },

    setRoutingMode: function(routingMode) {
        this.routingMode = routingMode;
    },
    
    setApplication: function(application) {
    	this.callSuper("setApplication", application);

    	for (var i=0; i<this.getRoutes().length; i++) {
        	var route = this.getRoutes()[i];
        	route.setApplication(application)
        }

        if (this.getDefaultRoute() != null) {
        	this.getDefaultRoute().setApplication(application);
        }
    },

    start: function() {
        if (this.isStopped()) {
            for (var i=0; i<this.getRoutes().length; i++) {
            	var route = this.getRoutes()[i];
                route.start();
            }

            if (this.getDefaultRoute() != null) {
            	this.getDefaultRoute().start();
            }

            // Must be invoked as a last step
            this.callSuper("start");
        }
    },

    stop: function() {
        if (this.isStarted()) {
            // Must be invoked as a first step
            this.callSuper("stop");

            if (this.getDefaultRoute() != null) {
            	this.getDefaultRoute().stop();
            }

            for (var i=0; i<this.getRoutes().length; i++) {
            	var route = this.getRoutes()[i];
                route.stop();
            }
        }
    }
});

Router.extend({
	MODE_BEST_MATCH: 1,
	MODE_CUSTOM: 6,
	MODE_FIRST_MATCH: 2,
	MODE_LAST_MATCH: 3,
	MODE_NEXT_MATCH: 4,
	MODE_RANDOM_MATCH: 5
});

var Template = new commons.Class({
    initialize: function() {
    	var pattern = arguments[0];
    	var matchingMode = Template.MODE_EQUALS;
    	var defaultType = Variable.TYPE_ALL;
        var defaultDefaultValue = "";
        var defaultRequired = true;
        var defaultFixed = false;
        var encodingVariables = false;
        if (arguments.length==2) {
        	matchingMode = arguments[1];
        } else if (arguments.length==6) {
        	matchingMode = arguments[1];
        	defaultType = arguments[2];
            defaultDefaultValue = arguments[3];
            defaultRequired = arguments[4];
            defaultFixed = arguments[5];
        } else if (arguments.length==7) {
        	matchingMode = arguments[1];
        	defaultType = arguments[2];
            defaultDefaultValue = arguments[3];
            defaultRequired = arguments[4];
            defaultFixed = arguments[5];
            encodingVariables = arguments[6];
        }

        //this.logger = (logger == null) ? Context.getCurrentLogger() : logger;
        this.logger = Context.getCurrentLogger();
        this.pattern = pattern;
        this.defaultVariable = new Variable(defaultType, defaultDefaultValue,
                defaultRequired, defaultFixed);
        this.matchingMode = matchingMode;
        this.variables = {};
        this.regexPattern = null;
        this.encodingVariables = encodingVariables;
    },

    format: function(values) {
    	if (arguments.length==1 && !arguments[0] instanceof Resolver) {
    		var values = arguments[0];
    		return this.formatFromResolver(util.Resolver.createResolver(values));
    	} else if (arguments.length==1 && arguments[0] instanceof Resolver) {
    		var resolver = arguments[0];
    		return this.formatFromResolver(resolver);
    	} else if (arguments.length==2) {
    		var request = arguments[0];
    		var response = arguments[1];
    		return this.formatFromResolver(util.Resolver.createResolver(request, response));
    	}
    },

    formatFromResolver: function(resolver) {
        var result = new commons.StringBuilder();
        var varBuffer = null;
        var next;
        var inVariable = false;
        var patternLength = this.getPattern().length();
        for (var i = 0; i < patternLength; i++) {
            next = this.getPattern().charAt(i);

            if (inVariable) {
                if (data.Reference.isUnreserved(next)) {
                    // Append to the variable name
                    varBuffer.append(next);
                } else if (next == '}') {
                    // End of variable detected
                    if (varBuffer.length() == 0) {
                        this.getLogger().warning(
                                "Empty pattern variables are not allowed : "
                                        + this.regexPattern);
                    } else {
                        var varName = varBuffer.toString();
                        var varValue = resolver.resolve(varName);

                        var varb = this.getVariables()[varName];

                        // Use the default values instead
                        if (varValue == null) {
                            if (varb == null) {
                            	varb = this.getDefaultVariable();
                            }

                            if (varb != null) {
                                varValue = varb.getDefaultValue();
                            }
                        }

                        var varValueString = (varValue == null) ? null
                                : varValue.toString();

                        if (this.encodingVariables) {
                            // In case the values must be encoded.
                            if (varb != null) {
                                result.append(varb.encode(varValueString));
                            } else {
                                result.append(data.Reference.encode(varValueString));
                            }
                        } else {
                            if ((varb != null) && varb.isEncodingOnFormat()) {
                                result.append(data.Reference.encode(varValueString));
                            } else {
                                result.append(varValueString);
                            }
                        }

                        // Reset the variable name buffer
                        varBuffer = new commons.StringBuilder();
                    }
                    inVariable = false;
                } else {
                    this.getLogger().warning(
                            "An invalid character was detected inside a pattern variable : "
                                    + this.regexPattern);
                }
            } else {
                if (next == '{') {
                    inVariable = true;
                    varBuffer = new commons.StringBuilder();
                } else if (next == '}') {
                    this.getLogger().warning(
                            "An invalid character was detected inside a pattern variable : "
                                    + this.regexPattern);
                } else {
                    result.append(next);
                }
            }
        }
        return result.toString();
    },

    getDefaultVariable: function() {
        return this.defaultVariable;
    },

    getLogger: function() {
        return this.logger;
    },

    getMatchingMode: function() {
        return this.matchingMode;
    },

    getPattern: function() {
        return this.pattern;
    },

    getRegexPattern: function() {
        if (this.regexPattern == null) {
            this.getRegexVariables().clear();
            var patternBuffer = new commons.StringBuilder();
            var varBuffer = null;
            var next;
            var inVariable = false;
            for (var i = 0; i < this.getPattern().length; i++) {
                next = this.getPattern().charAt(i);
                var nextCode = this.getPattern().charCodeAt(i);

                if (inVariable) {
                    if (data.Reference.isUnreserved(nextCode)) {
                        // Append to the variable name
                        varBuffer.append(next);
                    } else if (next == '}') {
                        // End of variable detected
                        if (varBuffer.length() == 0) {
                            this.getLogger().warning(
                                    "Empty pattern variables are not allowed : "
                                            + this.regexPattern);
                        } else {
                            var varName = varBuffer.toString();
                            var varIndex = this.getRegexVariables()
                                    .indexOf(varName);

                            if (varIndex != -1) {
                                // The variable is used several times in
                                // the pattern, ensure that this
                                // constraint is enforced when parsing.
                                patternBuffer.append("\\"
                                        + (varIndex + 1));
                            } else {
                                // New variable detected. Insert a
                                // capturing group.
                                this.getRegexVariables().add(varName);
                                var varb = this.getVariables()[varName];
                                if (varb == null) {
                                    varb = this.getDefaultVariable();
                                }
                                patternBuffer
                                        .append(Template.getVariableRegex(varb));
                            }

                            // Reset the variable name buffer
                            varBuffer = new commons.StringBuilder();
                        }
                        inVariable = false;

                    } else {
                        this.getLogger().warning(
                                "An invalid character was detected inside a pattern variable : "
                                        + this.regexPattern);
                    }
                } else {
                    if (next == '{') {
                        inVariable = true;
                        varBuffer = new commons.StringBuilder();
                    } else if (next == '}') {
                        this.getLogger().warning(
                                "An invalid character was detected inside a pattern variable : "
                                        + this.regexPattern);
                    } else {
                        patternBuffer.append(this.quote(next));
                    }
                }
            }

            this.regexPattern = patternBuffer
                    .toString();
        }

        return this.regexPattern;
    },

    getRegexVariables: function() {
        // Lazy initialization with double-check.
        if (this.regexVariables==null) {
        	this.regexVariables = [];
        }
        return this.regexVariables;
    },

    getVariableNames: function() {
        var result = [];
        var varBuffer = null;
        var next;
        var inVariable = false;
        var pattern = this.getPattern();

        for (var i = 0; i < pattern.length(); i++) {
            next = pattern.charAt(i);
            var nextCode = pattern.charCodeAt(i);

            if (inVariable) {
                if (data.Reference.isUnreserved(nextCode)) {
                    // Append to the variable name
                    varBuffer.append(next);
                } else if (next == '}') {
                    // End of variable detected
                    if (varBuffer.length() == 0) {
                        this.getLogger().warning(
                                "Empty pattern variables are not allowed : "
                                        + this.pattern);
                    } else {
                        result.add(varBuffer.toString());

                        // Reset the variable name buffer
                        varBuffer = new commons.StringBuilder();
                    }

                    inVariable = false;
                } else {
                    this.getLogger().warning(
                            "An invalid character was detected inside a pattern variable : "
                                    + this.pattern);
                }
            } else {
                if (next == '{') {
                    inVariable = true;
                    varBuffer = new commons.StringBuilder();
                } else if (next == '}') {
                    this.getLogger().warning(
                            "An invalid character was detected inside a pattern variable : "
                                    + this.pattern);
                }
            }
        }

        return result;
    },

    getVariables: function() {
        return this.variables;
    },

    isEncodingVariables: function() {
        return this.encodingVariables;
    },

    match: function(formattedString) {
        var result = -1;

        try {
            if (formattedString != null) {
            	var regexPattern = this.getRegexPattern();
                var matcher = new RegExp(regexPattern);//.matcher(
                        //formattedString);

            	var index = -1;
                if ((this.getMatchingMode() == Template.MODE_EQUALS) && matcher.test(formattedString)) {
                    //result = matcher.end();
                	result = formattedString.length;
                } else if ((this.getMatchingMode() == Template.MODE_STARTS_WITH)
                        && (index=formattedString.search(regexPattern))!=-1) {
                    result = index;
                }
            }
        } catch (err) {
            this.getLogger().warning(
                    "error encountered while matching this string : "
                            + formattedString, err);
        }

        return result;
    },

    parse: function() {
    	var formattedString = arguments[0];
    	var variables = null;
    	var loggable = false;
    	if (arguments.length==2 && !arguments[1] instanceof Request) {
    		variables = arguments[1];
    		loggable = true;
    	} else if (arguments.length==2 && arguments[1] instanceof Request) {
    		variables = arguments[1].getAttributes();
    		loggable = arguments[1].isLoggable();
    	} else if (arguments.length==3) {
    		variables = arguments[1];
    		loggable = arguments[2];
    	}

        var result = -1;

        if (formattedString != null) {
            try {
            	var regexPattern = this.getRegexPattern();
                var matcher = new RegExp(regexPattern);//.matcher(
                //formattedString);
                var index = -1;
                var matched = ((this.getMatchingMode() == Template.MODE_EQUALS) && matcher
                        .test(formattedString))
                        || ((this.getMatchingMode() == Template.MODE_STARTS_WITH) && ((index=formattedString.search(regexPattern))!=-1));

                if (matched) {
                    // Update the number of matched characters
                	if ((this.getMatchingMode() == Template.MODE_EQUALS)) {
                		result = formattedString.length;
                	} else if ((this.getMatchingMode() == Template.MODE_STARTS_WITH)) {
                		result = index;
                	}

                	var groups = formattedString.match(regexPattern);
                    // Update the attributes with the variables value
                    var attributeName = null;
                    var attributeValue = null;

                    for (var i = 0; i < this.getRegexVariables().length; i++) {
                        attributeName = this.getRegexVariables()[i];
                        attributeValue = groups[i + 1];
                        var varb = this.getVariables()[attributeName];

                        if ((varb != null) && varb.isDecodingOnParse()) {
                            attributeValue = data.Reference.decode(attributeValue);
                        }

                        if (loggable) {
                            this.getLogger().fine(
                                    "Template variable \"" + attributeName
                                            + "\" matched with value \""
                                            + attributeValue + "\"");
                        }

                        variables[attributeName] = attributeValue;
                    }
                }
            } catch (err) {
                this.getLogger().warning(
                        "error encountered while matching this string : "
                                + formattedString, err);
            }
        }

        return result;
    },

    quote: function(character) {
        switch (character) {
        case '[':
            return "\\[";
        case ']':
            return "\\]";
        case '.':
            return "\\.";
        case '\\':
            return "\\\\";
        case '$':
            return "\\$";
        case '^':
            return "\\^";
        case '?':
            return "\\?";
        case '*':
            return "\\*";
        case '|':
            return "\\|";
        case '(':
            return "\\(";
        case ')':
            return "\\)";
        case ':':
            return "\\:";
        case '-':
            return "\\-";
        case '!':
            return "\\!";
        case '<':
            return "\\<";
        case '>':
            return "\\>";
        default:
        	//TODO: convert char to string with js
            //return Character.toString(character);
        	return character;
        }
    },

    setDefaultVariable: function(defaultVariable) {
        this.defaultVariable = defaultVariable;
    },

    setEncodingVariables: function(encodingVariables) {
        this.encodingVariables = encodingVariables;
    },

    setLogger: function(logger) {
        this.logger = logger;
    },

    setMatchingMode: function(matchingMode) {
        this.matchingMode = matchingMode;
    },

    setPattern: function(pattern) {
        this.pattern = pattern;
        this.regexPattern = null;
    },

    setVariables: function(variables) {
        if (variables != this.variables) {
            this.variables.clear();

            if (variables != null) {
                this.variables.putAll(variables);
            }
        }
    }
});

Template.extend({
	/** Mode where all characters must match the template and size be identical. */
	MODE_EQUALS: 2,
	/** Mode where characters at the beginning must match the template. */
	MODE_STARTS_WITH: 1,

    appendClass: function(pattern, content, required) {
        pattern.append("(");

        if (content.equals(".")) {
            // Special case for the TYPE_ALL variable type because the
            // dot looses its meaning inside a character class
            pattern.append(content);
        } else {
            pattern.append("[").append(content).append(']');
        }

        if (required) {
            pattern.append("+");
        } else {
            pattern.append("*");
        }

        pattern.append(")");
    },

    appendGroup: function(pattern, content, required) {
        pattern.append("((?:").append(content).append(')');

        if (required) {
            pattern.append("+");
        } else {
            pattern.append("*");
        }

        pattern.append(")");
    },

    getVariableRegex: function(variable) {
        var result = null;

        if (variable.isFixed()) {
        	//TODO: use native js regexp
            result = "(" + Pattern.quote(variable.getDefaultValue()) + ")";
        } else {
            // Expressions to create character classes
            var ALL = ".";
            var ALPHA = "a-zA-Z";
            var DIGIT = "\\d";
            var ALPHA_DIGIT = ALPHA + DIGIT;
            var HEXA = DIGIT + "ABCDEFabcdef";
            var URI_UNRESERVED = ALPHA_DIGIT + "\\-\\.\\_\\~";
            var URI_GEN_DELIMS = "\\:\\/\\?\\#\\[\\]\\@";
            var URI_SUB_DELIMS = "\\!\\$\\&\\'\\(\\)\\*\\+\\,\\;\\=";
            var URI_RESERVED = URI_GEN_DELIMS + URI_SUB_DELIMS;
            var WORD = "\\w";

            // Basic rules expressed by the HTTP rfc.
            var CRLF = "\\r\\n";
            var CTL = "\\p{Cntrl}";
            var LWS = CRLF + "\\ \\t";
            var SEPARATOR = "\\(\\)\\<\\>\\@\\,\\;\\:\\[\\]\"\\/\\\\?\\=\\{\\}\\ \\t";
            var TOKEN = "[^" + SEPARATOR + "]";
            var COMMENT = "[^" + CTL + "]" + "[^\\(\\)]" + LWS;
            var COMMENT_ATTRIBUTE = "[^\\;\\(\\)]";

            // Expressions to create non-capturing groups
            var PCT_ENCODED = "\\%[" + HEXA + "][" + HEXA + "]";
            // var PCHAR = "[" + URI_UNRESERVED + "]|(?:" + PCT_ENCODED
            // + ")|[" + URI_SUB_DELIMS + "]|\\:|\\@";
            var PCHAR = "[" + URI_UNRESERVED + URI_SUB_DELIMS
                    + "\\:\\@]|(?:" + PCT_ENCODED + ")";
            var QUERY = PCHAR + "|\\/|\\?";
            var FRAGMENT = QUERY;
            var URI_PATH = PCHAR + "|\\/";
            var URI_ALL = "[" + URI_RESERVED + URI_UNRESERVED
                    + "]|(?:" + PCT_ENCODED + ")";

            // Special case of query parameter characters
            var QUERY_PARAM_DELIMS = "\\!\\$\\'\\(\\)\\*\\+\\,\\;";
            var QUERY_PARAM_CHAR = "[" + URI_UNRESERVED
                    + QUERY_PARAM_DELIMS + "\\:\\@]|(?:" + PCT_ENCODED + ")";
            var QUERY_PARAM = QUERY_PARAM_CHAR + "|\\/|\\?";

            var coreRegex = new commons.StringBuilder();

            switch (variable.getType()) {
            case Variable.TYPE_ALL:
            	Template.appendClass(coreRegex, ALL, variable.isRequired());
                break;
            case Variable.TYPE_ALPHA:
            	Template.appendClass(coreRegex, ALPHA, variable.isRequired());
                break;
            case Variable.TYPE_DIGIT:
            	Template.appendClass(coreRegex, DIGIT, variable.isRequired());
                break;
            case Variable.TYPE_ALPHA_DIGIT:
            	Template.appendClass(coreRegex, ALPHA_DIGIT, variable.isRequired());
                break;
            case Variable.TYPE_URI_ALL:
                Template.appendGroup(coreRegex, URI_ALL, variable.isRequired());
                break;
            case Variable.TYPE_URI_UNRESERVED:
            	Template.appendClass(coreRegex, URI_UNRESERVED, variable.isRequired());
                break;
            case Variable.TYPE_WORD:
            	Template.appendClass(coreRegex, WORD, variable.isRequired());
                break;
            case Variable.TYPE_URI_FRAGMENT:
            	Template.appendGroup(coreRegex, FRAGMENT, variable.isRequired());
                break;
            case Variable.TYPE_URI_PATH:
            	Template.appendGroup(coreRegex, URI_PATH, variable.isRequired());
                break;
            case Variable.TYPE_URI_QUERY:
            	Template.appendGroup(coreRegex, QUERY, variable.isRequired());
                break;
            case Variable.TYPE_URI_QUERY_PARAM:
            	Template.appendGroup(coreRegex, QUERY_PARAM, variable.isRequired());
                break;
            case Variable.TYPE_URI_SEGMENT:
            	Template.appendGroup(coreRegex, PCHAR, variable.isRequired());
                break;
            case Variable.TYPE_TOKEN:
            	Template.appendClass(coreRegex, TOKEN, variable.isRequired());
                break;
            case Variable.TYPE_COMMENT:
            	Template.appendClass(coreRegex, COMMENT, variable.isRequired());
                break;
            case Variable.TYPE_COMMENT_ATTRIBUTE:
            	Template.appendClass(coreRegex, COMMENT_ATTRIBUTE, variable.isRequired());
                break;
            }

            result = coreRegex.toString();
        }

        return result;
    }
});

var TemplateRoute = new commons.Class(Route, {
    initialize: function() {
    	var router = null;
    	var template = null;
    	var next = null;
    	if (arguments.length==1) {
    		next = arguments[0];
    	} else if (arguments.length==3) {
    		router = arguments[0];
    		if (typeof arguments[1] == "string") {
    			template = new Template(arguments[1], Template.MODE_STARTS_WITH,
    	                Variable.TYPE_URI_SEGMENT, "", true, false);
    		} else {
    			template = arguments[1];
    		}
    		next = arguments[2];
    	}
        this.callSuperCstr(router, next);
        this.matchingQuery = (router == null) ? true : router
                .getDefaultMatchingQuery();
        this.template = template;
    },

    beforeHandle: function(request, response) {
        // 1 - Parse the template variables and adjust the base reference
        if (this.getTemplate() != null) {
            remainingPart = request.getResourceRef().getRemainingPart(
                    false, this.isMatchingQuery());
            var matchedLength = this.getTemplate().parse(remainingPart, request);

            if (matchedLength == 0) {
                /*if (request.isLoggable() && getLogger().isLoggable(Level.FINER)) {
                    getLogger().finer("No characters were matched");
                }*/
            } else if (matchedLength > 0) {
                /*if (request.isLoggable() && getLogger().isLoggable(Level.FINER)) {
                    getLogger().finer(
                            "" + matchedLength + " characters were matched");
                }*/

                // Updates the context
                var matchedPart = remainingPart.substring(0, matchedLength);
                var baseRef = request.getResourceRef().getBaseRef();

                if (baseRef == null) {
                    baseRef = new data.Reference(matchedPart);
                } else {
                    baseRef = new data.Reference(baseRef.toString(false, false)
                            + matchedPart);
                }

                request.getResourceRef().setBaseRef(baseRef);

                if (request.isLoggable()) {
                    if (this.getLogger().isLoggable(Level.FINE)) {
                        remainingPart = request.getResourceRef()
                                .getRemainingPart(false, this.isMatchingQuery());

                        if ((remainingPart != null)
                                && (!"".equals(remainingPart))) {
                            this.getLogger().fine(
                                    "New base URI: \""
                                            + request.getResourceRef()
                                                    .getBaseRef()
                                            + "\". New remaining part: \""
                                            + remainingPart + "\"");
                        } else {
                            this.getLogger().fine(
                                    "New base URI: \""
                                            + request.getResourceRef()
                                                    .getBaseRef()
                                            + "\". No remaining part to match");
                        }
                    }

                    if (getLogger().isLoggable(Level.FINER)) {
                        getLogger().finer(
                                "Delegating the call to the target Restlet");
                    }
                }
            } else {
                if (request.isLoggable() && getLogger().isLoggable(Level.FINE)) {
                    this.getLogger().fine(
                            "Unable to match this pattern: "
                                    + this.getTemplate().getPattern());
                }

                response.setStatus(data.Status.CLIENT_ERROR_NOT_FOUND);
            }
        }

        return Filter.CONTINUE;
    },

    getMatchingMode: function() {
        return this.getTemplate().getMatchingMode();
    },

    getTemplate: function() {
        return this.template;
    },

    isMatchingQuery: function() {
        return this.matchingQuery;
    },

    score: function(request, response) {
        var result = 0;

        if ((this.getRouter() != null) && (request.getResourceRef() != null)
                && (this.getTemplate() != null)) {
            var remainingPart = request.getResourceRef()
                    .getRemainingPart(false, this.isMatchingQuery());
            if (remainingPart != null) {
                var matchedLength = this.getTemplate().match(remainingPart);

                if (matchedLength != -1) {
                    var totalLength = remainingPart.length;

                    if (totalLength > 0) {
                        result = this.getRouter().getRequiredScore()
                                + (1 - this.getRouter().getRequiredScore())
                                * (matchedLength / totalLength);
                    } else {
                        result = 1;
                    }
                }
            }

            /*if (request.isLoggable() && getLogger().isLoggable(Level.FINER)) {
                getLogger().finer(
                        "Call score for the \"" + getTemplate().getPattern()
                                + "\" URI pattern: " + result);
            }*/
        }

        return result;
    },

    setMatchingMode: function(matchingMode) {
        this.getTemplate().setMatchingMode(matchingMode);
    },

    setMatchingQuery: function(matchingQuery) {
        this.matchingQuery = matchingQuery;
    },

    setTemplate: function(template) {
        this.template = template;
    },

    toString: function() {
    	/*console.log("template route - this.getTemplate() = "+this.getTemplate());
    	console.log("template route - this.getNext() = "+this.getNext());*/
        return "\""
                + ((this.getTemplate() == null) ? this/*.callSuper("toString")*/ : this.getTemplate()
                        .getPattern()) + "\" -> "
                + ((this.getNext() == null) ? "null" : this.getNext().toString());
    }
});

var Variable = new commons.Class({
    initialize: function() {
    	var type = Variable.TYPE_ALL;
    	var defaultValue = "";
    	var required = true;
        var fixed = false;
        var decodingOnParse = false;
        var encodingOnFormat = false;
    	if (arguments.length==1) {
    		type = arguments[0];
    	} else if (arguments.length==4) {
    		type = arguments[0];
        	defaultValue = arguments[1];
        	required = arguments[2];
            fixed = arguments[3];
    	} else if (arguments.length==6) {
    		type = arguments[0];
        	defaultValue = arguments[1];
        	required = arguments[2];
            fixed = arguments[3];
            decodingOnParse = arguments[4];
            encodingOnFormat = arguments[5];
    	}

        this.type = type;
        this.defaultValue = defaultValue;
        this.required = required;
        this.fixed = fixed;
        this.decodingOnParse = decodingOnParse;
        this.encodingOnFormat = encodingOnFormat;
    },

    encode: function(value) {
        switch (this.type) {
        case Variable.TYPE_URI_ALL:
            return data.Reference.encode(value);
        case Variable.TYPE_URI_UNRESERVED:
            return data.Reference.encode(value);
        case Variable.TYPE_URI_FRAGMENT:
            return data.Reference.encode(value);
        case Variable.TYPE_URI_PATH:
            return data.Reference.encode(value);
        case Variable.TYPE_URI_QUERY:
            return data.Reference.encode(value);
        case Variable.TYPE_URI_SEGMENT:
            return data.Reference.encode(value);
        default:
            return value;
        }
    },

    getDefaultValue: function() {
        return this.defaultValue;
    },

    getType: function() {
        return this.type;
    },

    isDecodingOnParse: function() {
        return this.decodingOnParse;
    },

    isEncodingOnFormat: function() {
        return this.encodingOnFormat;
    },

    isFixed: function() {
        return this.fixed;
    },

    isRequired: function() {
        return this.required;
    },

    setDecodingOnParse: function(decodingOnParse) {
        this.decodingOnParse = decodingOnParse;
    },

    setDefaultValue: function(defaultValue) {
        this.defaultValue = defaultValue;
    },

    setEncodingOnFormat: function(encodingOnFormat) {
        this.encodingOnFormat = encodingOnFormat;
    },

    setFixed: function(fixed) {
        this.fixed = fixed;
    },

    setRequired: function(required) {
        this.required = required;
    },

    setType: function(type) {
        this.type = type;
    }
});

Variable.extend({
	/** Matches all characters. */
	TYPE_ALL: 1,
	/** Matches all alphabetical characters. */
	TYPE_ALPHA: 2,
	/** Matches all alphabetical and digital characters. */
	TYPE_ALPHA_DIGIT: 3,
	/** Matches any TEXT excluding "(" and ")". */
	TYPE_COMMENT: 4,
	/** Matches any TEXT inside a comment excluding ";". */
	TYPE_COMMENT_ATTRIBUTE: 5,
	/** Matches all digital characters. */
	TYPE_DIGIT: 6,
	/** Matches any CHAR except CTLs or separators. */
	TYPE_TOKEN: 7,
	/** Matches all URI characters. */
	TYPE_URI_ALL: 8,
	/** Matches URI fragment characters. */
	TYPE_URI_FRAGMENT: 9,
	/** Matches URI path characters (not the query or the fragment parts). */
	TYPE_URI_PATH: 10,
	/** Matches URI query characters. */
	TYPE_URI_QUERY: 11,
	/** Matches URI query parameter characters (name or value). */
	TYPE_URI_QUERY_PARAM: 12,
	/** Matches URI scheme characters. */
	TYPE_URI_SCHEME: 13,
	/** Matches URI segment characters. */
	TYPE_URI_SEGMENT: 14,
	/** Matches unreserved URI characters. */
	TYPE_URI_UNRESERVED: 15,
	/** Matches all alphabetical and digital characters plus the underscore. */
	TYPE_WORD: 16
});

var VirtualHost = new commons.Class(Router, {
	className: "VirtualHost",
    initialize: function() {
    	var parentContext = null;
    	var hostDomain = ".*";
        var hostPort = ".*";
        var hostScheme = ".*";
        var resourceDomain = ".*";
        var resourcePort = ".*";
        var resourceScheme = ".*";
        var serverAddress = ".*";
        var serverPort = ".*";
        if (arguments.length==1) {
        	parentContext = arguments[0];
        }
        
        this.callSuperCstr((parentContext == null) ? null : parentContext
                .createChildContext());

        // Override Router's default modes
        this.setDefaultMatchingMode(Template.MODE_STARTS_WITH);
        this.setRoutingMode(Router.MODE_BEST_MATCH);

        this.parentContext = parentContext;

        this.hostDomain = hostDomain;
        this.hostPort = hostPort;
        this.hostScheme = hostScheme;

        this.resourceDomain = resourceDomain;
        this.resourcePort = resourcePort;
        this.resourceScheme = resourceScheme;

        this.serverAddress = serverAddress;
        this.serverPort = serverPort;
    },

    attach: function() {
    	var uriPattern = null;
    	var target = null;
    	if (arguments.length==1) {
    		target = arguments[0];
    	} else if (arguments.length==2) {
    		uriPattern = arguments[0];
    		target = arguments[1];
    	}
        this.checkContext(target);
        if (uriPattern!=null) {
        	this.callSuper("attach", uriPattern, target);
        } else {
        	this.callSuper("attach", target);
        }
    },

    attachDefault: function(defaultTarget) {
        this.checkContext(defaultTarget);
        var ret = this.callSuper("attachDefault", defaultTarget);
    	
    	return ret;
    },

    checkContext: function(target) {
        if ((target.getContext() == null) && (this.parentContext != null)) {
            target.setContext(this.parentContext.createChildContext());
        }
    },

    /*public Finder createFinder(Class<? extends ServerResource> targetClass) {
        Finder result = super.createFinder(targetClass);
        result.setContext(getContext().createChildContext());
        return result;
    },*/

    createRoute: function(uriPattern, target, matchingMode) {
        var result = new TemplateRoute(this, uriPattern, target);
        result.beforeHandle = function(request, response) {
        	var result = this.callSuper("beforeHandle", request, response);

            // Set the request's root reference
            request.setRootRef(request.getResourceRef().getBaseRef());

            // Save the hash code of the current host
            //this.setCurrent(VirtualHost.this.hashCode());

            return result;
        };

        result.getTemplate().setMatchingMode(matchingMode);
        result.setMatchingQuery(this.getDefaultMatchingQuery());
        return result;
    },

    getHostDomain: function() {
        return this.hostDomain;
    },

    getHostPort: function() {
        return this.hostPort;
    },

    getHostScheme: function() {
        return this.hostScheme;
    },

    getResourceDomain: function() {
        return this.resourceDomain;
    },

    getResourcePort: function() {
        return this.resourcePort;
    },

    getResourceScheme: function() {
        return this.resourceScheme;
    },

    getServerAddress: function() {
        return this.serverAddress;
    },

    getServerPort: function() {
        return this.serverPort;
    },

    setContext: function(parentContext) {
        this.parentContext = parentContext;
        this.callSuper("setContext", (parentContext == null) ? null : parentContext
                .createChildContext());
    },

    setHostDomain: function(hostDomain) {
        this.hostDomain = hostDomain;
    },

    setHostPort: function(hostPort) {
        this.hostPort = hostPort;
    },

    setHostScheme: function(hostScheme) {
        this.hostScheme = hostScheme;
    },

    setResourceDomain: function(resourceDomain) {
        this.resourceDomain = resourceDomain;
    },

    setResourcePort: function(resourcePort) {
        this.resourcePort = resourcePort;
    },

    setResourceScheme: function(resourceScheme) {
        this.resourceScheme = resourceScheme;
    },

    setServerAddress: function(serverAddress) {
        this.serverAddress = serverAddress;
    },

    setServerPort: function(serverPort) {
        this.serverPort = serverPort;
    }
});

VirtualHost.extend({
/*public static String getIpAddress(String domain) {
    String result = null;

    try {
        result = InetAddress.getByName(domain).getHostAddress();
    } catch (UnknownHostException e) {
    }

    return result;
}

public static String getLocalHostAddress() {
    String result = null;

    try {
        result = InetAddress.getLocalHost().getHostAddress();
    } catch (UnknownHostException e) {
    }

    return result;
}

public static String getLocalHostName() {
    String result = null;

    try {
        result = InetAddress.getLocalHost().getHostName();
    } catch (UnknownHostException e) {
    }

    return result;
}*/
});

var CompositeHelper = new commons.Class(RestletHelper, {
    initialize: function(helped) {
        this.callSuperCstr(helped);
        this.inboundNext = null;
        this.firstInboundFilter = null;
        this.firstOutboundFilter = null;
        this.lastInboundFilter = null;
        this.lastOutboundFilter = null;
        this.outboundNext = null;
    },

    addInboundFilter: function(filter) {
        var next = this.getInboundNext();

        if (this.getFirstInboundFilter() == null) {
            this.setFirstInboundFilter(filter);
        } else if (getLastInboundFilter() != null) {
        	this.getLastInboundFilter().setNext(filter);
        }

        this.setLastInboundFilter(filter);
        this.setInboundNext(next);
    },

    addOutboundFilter: function(filter) {
        var next = this.getOutboundNext();

        if (this.getFirstOutboundFilter() == null) {
        	this.setFirstOutboundFilter(filter);
        } else if (this.getLastOutboundFilter() != null) {
        	this.getLastOutboundFilter().setNext(filter);
        }

        this.setLastOutboundFilter(filter);
        this.setOutboundNext(next);
    },

    clear: function() {
    	this.setFirstInboundFilter(null);
    	this.setFirstOutboundFilter(null);
    	this.setInboundNext(null);
    	this.setLastInboundFilter(null);
    	this.setLastOutboundFilter(null);
    	this.setOutboundNext(null);
    },

    getFirstInboundFilter: function() {
        return this.firstInboundFilter;
    },

    getFirstOutboundFilter: function() {
        return this.firstOutboundFilter;
    },

    getInboundNext: function() {
        var result = null;

        if (this.getLastInboundFilter() != null) {
            result = this.getLastInboundFilter().getNext();
        } else {
            result = this.inboundNext;
        }

        return result;
    },

    getLastInboundFilter: function() {
        return this.lastInboundFilter;
    },

    getLastOutboundFilter: function() {
        return this.lastOutboundFilter;
    },

    getOutboundNext: function() {
        var result = null;

        if (this.getLastOutboundFilter() != null) {
            result = this.getLastOutboundFilter().getNext();
        } else {
            result = this.outboundNext;
        }

        return result;
    },

    handle: function(request, response) {
    	//response.setFirstOutboundFilter(this.getFirstOutboundFilter());
        this.callSuper("handle", request, response);

        if (this.getFirstInboundFilter() != null) {
        	this.getFirstInboundFilter().handle(request, response);
        } else {
            response.setStatus(data.Status.SERVER_ERROR_INTERNAL);
            this.getHelped()
                    .getLogger()
                    .log(Level.SEVERE,
                            "The "
                                    + getHelped()
                                    + " class has no Restlet defined to process calls. Maybe it wasn't properly started.");
        }
    },

    setFirstInboundFilter: function(firstInboundFilter) {
        this.firstInboundFilter = firstInboundFilter;
    },

    setFirstOutboundFilter: function(firstOutboundFilter) {
        this.firstOutboundFilter = firstOutboundFilter;
    },

    setInboundNext: function(next) {
        if (this.getLastInboundFilter() != null) {
        	this.getLastInboundFilter().setNext(next);
        }

        this.inboundNext = next;
    },

    setLastInboundFilter: function(last) {
        this.lastInboundFilter = last;
    },

    setLastOutboundFilter: function(last) {
        this.lastOutboundFilter = last;
    },

    setOutboundNext: function(next) {
        if (this.getLastOutboundFilter() != null) {
        	this.getLastOutboundFilter().setNext(next);
        }

        this.outboundNext = next;
    }
});

var CallResolver = new commons.Class(util.Resolver, {
    initialize: function(request, response) {
        this.request = request;
        this.response = response;
    },

    getReferenceContent: function(partName, reference) {
        var result = null;

        if (reference != null) {
            if (partName.equals("a")) {
                result = reference.getAuthority();
            } else if (partName.startsWith("b")) {
                result = getReferenceContent(partName.substring(1), reference
                        .getBaseRef());
            } else if (partName.equals("e")) {
                result = reference.getRelativePart();
            } else if (partName.equals("f")) {
                result = reference.getFragment();
            } else if (partName.equals("h")) {
                result = reference.getHostIdentifier();
            } else if (partName.equals("i")) {
                result = reference.getIdentifier();
            } else if (partName.equals("p")) {
                result = reference.getPath();
            } else if (partName.equals("q")) {
                result = reference.getQuery();
            } else if (partName.equals("r")) {
                result = reference.getRemainingPart();
            }
        }

        return result;
    },

    resolve: function(variableName) {
        var result = null;

        // Check for a matching response attribute
        if (this.response != null
                && this.response.getAttributes().containsKey(variableName)) {
            result = this.response.getAttributes().get(variableName);
        }

        // Check for a matching request attribute
        if ((result == null) && (this.request != null)
                && this.request.getAttributes().containsKey(variableName)) {
            result = this.request.getAttributes().get(variableName);
        }

        // Check for a matching request or response property
        if (result == null) {
            if (this.request != null) {
                if (variableName.equals("c")) {
                    result = Boolean.toString(this.request.isConfidential());
                } else if (variableName.equals("cia")) {
                    result = this.request.getClientInfo().getAddress();
                } else if (variableName.equals("ciua")) {
                    result = this.request.getClientInfo().getUpstreamAddress();
                } else if (variableName.equals("cig")) {
                    result = this.request.getClientInfo().getAgent();
                } else if (variableName.equals("cri")) {
                    var cr = this.request.getChallengeResponse();
                    if (cr != null) {
                        result = cr.getIdentifier();
                    }
                } else if (variableName.equals("crs")) {
                    var cr = this.request.getChallengeResponse();
                    if (cr != null && cr.getScheme() != null) {
                        result = cr.getScheme().getTechnicalName();
                    }
                } else if (variableName.equals("d")) {
                    result = DateUtils.format(new Date(),
                    		DateUtils.FORMAT_RFC_1123.get(0));
                } else if (variableName.equals("ecs")) {
                    if ((this.request.getEntity() != null)
                            && (this.request.getEntity().getCharacterSet() != null)) {
                        result = this.request.getEntity().getCharacterSet()
                                .getName();
                    }
                } else if (variableName.equals("ee")) {
                    if ((this.request.getEntity() != null)
                            && (!this.request.getEntity().getEncodings()
                                    .isEmpty())) {
                        var value = new commons.StringBuilder();
                        for (var i = 0; i < this.request.getEntity()
                                .getEncodings().size(); i++) {
                            if (i > 0) {
                                value.append(", ");
                            }
                            value.append(this.request.getEntity()
                                    .getEncodings().get(i).getName());
                        }
                        result = value.toString();
                    }
                } else if (variableName.equals("eed")) {
                    if ((this.request.getEntity() != null)
                            && (this.request.getEntity().getExpirationDate() != null)) {
                        result = DateUtils.format(this.request.getEntity()
                                .getExpirationDate(), DateUtils.FORMAT_RFC_1123
                                .get(0));
                    }
                } else if (variableName.equals("el")) {
                    if ((this.request.getEntity() != null)
                            && (!this.request.getEntity().getLanguages()
                                    .isEmpty())) {
                        var value = new commons.StringBuilder();
                        for (var i = 0; i < this.request.getEntity()
                                .getLanguages().size(); i++) {
                            if (i > 0) {
                                value.append(", ");
                            }
                            value.append(this.request.getEntity()
                                    .getLanguages().get(i).getName());
                        }
                        result = value.toString();
                    }
                } else if (variableName.equals("emd")) {
                    if ((this.request.getEntity() != null)
                            && (this.request.getEntity().getModificationDate() != null)) {
                        result = DateUtils.format(this.request.getEntity()
                                .getModificationDate(),
                                DateUtils.FORMAT_RFC_1123.get(0));
                    }
                } else if (variableName.equals("emt")) {
                    if ((this.request.getEntity() != null)
                            && (this.request.getEntity().getMediaType() != null)) {
                        result = this.request.getEntity().getMediaType()
                                .getName();
                    }
                } else if (variableName.equals("es")) {
                    if ((this.request.getEntity() != null)
                            && (this.request.getEntity().getSize() != -1)) {
                        result = Long.toString(this.request.getEntity()
                                .getSize());
                    }
                } else if (variableName.equals("et")) {
                    if ((this.request.getEntity() != null)
                            && (this.request.getEntity().getTag() != null)) {
                        result = this.request.getEntity().getTag().getName();
                    }
                } else if (variableName.startsWith("f")) {
                    result = getReferenceContent(variableName.substring(1),
                            this.request.getReferrerRef());
                } else if (variableName.startsWith("h")) {
                    result = getReferenceContent(variableName.substring(1),
                            this.request.getHostRef());
                } else if (variableName.equals("m")) {
                    if (this.request.getMethod() != null) {
                        result = this.request.getMethod().getName();
                    }
                } else if (variableName.startsWith("o")) {
                    result = getReferenceContent(variableName.substring(1),
                            this.request.getRootRef());
                } else if (variableName.equals("p")) {
                    if (this.request.getProtocol() != null) {
                        result = this.request.getProtocol().getName();
                    }
                } else if (variableName.startsWith("r")) {
                    result = getReferenceContent(variableName.substring(1),
                            this.request.getResourceRef());
                }
            }

            if ((result == null) && (this.response != null)) {
                if (variableName.equals("ECS")) {
                    if ((this.response.getEntity() != null)
                            && (this.response.getEntity().getCharacterSet() != null)) {
                        result = this.response.getEntity().getCharacterSet()
                                .getName();
                    }
                } else if (variableName.equals("EE")) {
                    if ((this.response.getEntity() != null)
                            && (!this.response.getEntity().getEncodings()
                                    .isEmpty())) {
                        var value = new commons.StringBuilder();
                        for (var i = 0; i < this.response.getEntity()
                                .getEncodings().size(); i++) {
                            if (i > 0) {
                                value.append(", ");
                            }
                            value.append(this.response.getEntity()
                                    .getEncodings().get(i).getName());
                        }
                        result = value.toString();
                    }
                } else if (variableName.equals("EED")) {
                    if ((this.response.getEntity() != null)
                            && (this.response.getEntity().getExpirationDate() != null)) {
                        result = DateUtils.format(this.response.getEntity()
                                .getExpirationDate(), DateUtils.FORMAT_RFC_1123
                                .get(0));
                    }
                } else if (variableName.equals("EL")) {
                    if ((this.response.getEntity() != null)
                            && (!this.response.getEntity().getLanguages()
                                    .isEmpty())) {
                        var value = new commons.StringBuilder();
                        for (var i = 0; i < this.response.getEntity()
                                .getLanguages().size(); i++) {
                            if (i > 0) {
                                value.append(", ");
                            }
                            value.append(this.response.getEntity()
                                    .getLanguages().get(i).getName());
                        }
                        result = value.toString();
                    }
                } else if (variableName.equals("EMD")) {
                    if ((this.response.getEntity() != null)
                            && (this.response.getEntity().getModificationDate() != null)) {
                        result = DateUtils.format(this.response.getEntity()
                                .getModificationDate(),
                                DateUtils.FORMAT_RFC_1123.get(0));
                    }
                } else if (variableName.equals("EMT")) {
                    if ((this.response.getEntity() != null)
                            && (this.response.getEntity().getMediaType() != null)) {
                        result = this.response.getEntity().getMediaType()
                                .getName();
                    }
                } else if (variableName.equals("ES")) {
                    if ((this.response.getEntity() != null)
                            && (this.response.getEntity().getSize() != -1)) {
                        result = Long.toString(this.response.getEntity()
                                .getSize());
                    }
                } else if (variableName.equals("ET")) {
                    if ((this.response.getEntity() != null)
                            && (this.response.getEntity().getTag() != null)) {
                        result = this.response.getEntity().getTag().getName();
                    }
                } else if (variableName.startsWith("R")) {
                    result = getReferenceContent(variableName.substring(1),
                            this.response.getLocationRef());
                } else if (variableName.equals("S")) {
                    if (this.response.getStatus() != null) {
                        result = Integer.toString(this.response.getStatus()
                                .getCode());
                    }
                } else if (variableName.equals("SIA")) {
                    result = this.response.getServerInfo().getAddress();
                } else if (variableName.equals("SIG")) {
                    result = this.response.getServerInfo().getAgent();
                } else if (variableName.equals("SIP")) {
                    if (this.response.getServerInfo().getPort() != -1) {
                        result = Integer.toString(this.response.getServerInfo()
                                .getPort());
                    }
                }
            }
        }

        return result;
    }
});

var MapResolver = new commons.Class(util.Resolver, {
	initialize: function(map) {
        this.map = map;
    },

    resolve: function(variableName) {
        return this.map.get(variableName);
    }
});

var ChildContext = new commons.Class(Context, {
    initialize: function(parentContext) {
        this.child = null;
        this.parentContext = parentContext;
        /*this.setClientDispatcher(new ChildClientDispatcher(this));
        this.setServerDispatcher((parentContext != null) ? this.getParentContext()
                .getServerDispatcher() : null);*/
    },

    getChild: function() {
        return this.child;
    },

    getParentContext: function() {
        return this.parentContext;
    },

    setChild: function(child) {
        this.child = child;
        /*setLogger(LogUtils.getLoggerName(this.parentContext.getLogger()
                .getName(), child));*/
    }
});

var ClientRoute = new commons.Class(Route, {
	initialize: function(router, target) {
        this.callSuperCstr(router, target);
    },

    getClient: function() {
        return this.getNext();
    },

    score: function(request, response) {
        var result = 0;

        // Add the protocol score
        var protocol = request.getProtocol();

        if (protocol == null) {
            /*this.getLogger().warning(
                    "Unable to determine the protocol to use for this call.");*/
        } else if (this.getClient().getProtocols().contains(protocol)) {
            result = 1;
        }

        /*if (getLogger().isLoggable(Level.FINER)) {
            getLogger().finer(
                    "Call score for the \""
                            + getClient().getProtocols().toString()
                            + "\" client: " + result);
        }*/

        return result;
    },

    setNext: function(next) {
        this.callSuper("setNext", next);
    }
});

var ClientRouter = new commons.Class(Router, {
    initialize: function(component) {
        this.callSuperCstr((component == null) ? null : component.getContext()
                .createChildContext());
        this.component = component;
    },

    logRoute: function(route) {
        /*if (getLogger().isLoggable(Level.FINE)) {
            if (route instanceof ClientRoute) {
                Client client = ((ClientRoute) route).getClient();

                getLogger().fine(
                        "This client was selected: \"" + client.getProtocols()
                                + "\"");
            } else {
                super.logRoute(route);
            }
        }*/
    },

    getNext: function(request, response) {
        var result = this.callSuper("getNext", request, response);

        if (result == null) {
            /*getLogger()
                    .warning(
                            "The protocol used by this request is not declared in the list of client connectors. ("
                                    + request.getResourceRef()
                                            .getSchemeProtocol() + "). In case you are using an instance of the Component class, check its \"clients\" property.");*/
        }
        return result;
    },

    getComponent: function() {
        return this.component;
    },

    start: function() {
    	var clients = this.getComponent().getClients();
        for (var i=0; i<clients.length; i++) {
        	var client = clients[i];
            this.getRoutes().add(new ClientRoute(this, client));
        }

        this.callSuper("start");
    }
});

var ApplicationHelper = new commons.Class(CompositeHelper, {
    initialize: function(application) {
        this.callSuperCstr(application);
    },

    handle: function(request, response) {
        // Actually handle call
        this.callSuper("handle", request, response);
    },

    setContext: function(context) {
        if (context != null) {
            this.setOutboundNext(context.getClientDispatcher());
        }
    },

    /** Start hook. */
    start: function() {
        var filter = null;

        var services = this.getHelped().getServices();
        for (var i=0; i<services.length; i++) {
        	var service = services[i];
            if (service.isEnabled()) {
                // Attach the service inbound filters
                filter = service
                        .createInboundFilter((this.getContext() == null) ? null
                                : this.getContext().createChildContext());

                if (filter != null) {
                	this.addInboundFilter(filter);
                }

                // Attach the service outbound filters
                filter = service
                        .createOutboundFilter((this.getContext() == null) ? null
                                : this.getContext().createChildContext());

                if (filter != null) {
                	this.addOutboundFilter(filter);
                }
            }
        }

        // Attach the Application's server root Restlet
        this.setInboundNext(this.getHelped().getInboundRoot());

        /*if (this.getOutboundNext() == null) {
            // Warn about chaining problem
            getLogger()
                    .fine("By default, an application should be attached to a parent component in order to let application's outbound root handle calls properly.");
            setOutboundNext(new Restlet() {
                Map<Protocol, Client> clients = new ConcurrentHashMap<Protocol, Client>();

                @Override
                public void handle(Request request, Response response) {
                    Protocol rProtocol = request.getProtocol();
                    Reference rReference = request.getResourceRef();
                    Protocol protocol = (rProtocol != null) ? rProtocol
                            : (rReference != null) ? rReference
                                    .getSchemeProtocol() : null;

                    if (protocol != null) {
                        Client c = clients.get(protocol);

                        if (c == null) {
                            c = new Client(protocol);
                            clients.put(protocol, c);
                            getLogger().fine(
                                    "Added runtime client for protocol: "
                                            + protocol.getName());
                        }

                        c.handle(request, response);
                    } else {
                        response.setStatus(Status.SERVER_ERROR_INTERNAL,
                                "The server isn't properly configured to handle client calls.");
                        getLogger().warning(
                                "There is no protocol detected for this request: "
                                        + request.getResourceRef());
                    }
                }

                @Override
                public synchronized void stop() throws Exception {
                    super.stop();
                    for (Client client : clients.values()) {
                        client.stop();
                    }
                }
            });
        }*/
    },

    stop: function() {
        this.clear();
    },

    update: function() {
    }
});

var ComponentContext = new commons.Class(Context, {
    initialize: function(componentHelper) {
        /*super(LogUtils
                .getLoggerName("org.restlet", componentHelper.getHelped()));*/
        this.componentHelper = componentHelper;
        /*this.setClientDispatcher(new ComponentClientDispatcher(this));
        this.setServerDispatcher(new ComponentServerDispatcher(this));*/
    },

    createChildContext: function() {
        return new ChildContext(this.getComponentHelper().getHelped().getContext());
    },

    getComponentHelper: function() {
        return this.componentHelper;
    },

    setComponentHelper: function(componentHelper) {
        this.componentHelper = componentHelper;
    }
});

var ComponentHelper = new commons.Class(CompositeHelper, {
    initialize: function(component) {
        this.callSuperCstr(component);
        component.setContext(new ComponentContext(this));
        this.clientRouter = new ClientRouter(this.getHelped());
        this.serverRouter = new ServerRouter(this.getHelped());
    },

    checkVirtualHost: function(host) {
        var result = true;

        /*if (host != null) {
            for (var i=0; i<host.getRoutes().length; i++) {
            	var route = host.getRoutes()[i];
                var next = route.getNext();

                if (next instanceof Application) {
                    var application = next;

                    if (application.getConnectorService() != null) {
                        if (application.getConnectorService()
                                .getClientProtocols() != null) {
                        	var clientProtocols = application
                            		.getConnectorService().getClientProtocols();
                            for (var i=0; i<clientProtocols.length; i++) {
                            	var clientProtocol = clientProtocols[i]
                                var clientFound = false;

                                // Try to find a client connector matching the
                                // client protocol
                                var client = null;
                                for (Iterator<Client> iter = getHelped()
                                        .getClients().iterator(); !clientFound
                                        && iter.hasNext();) {
                                    client = iter.next();
                                    clientFound = client.getProtocols()
                                            .contains(clientProtocol);
                                }

                                if (!clientFound) {
                                    getLogger()
                                            .severe("Unable to start the application \""
                                                    + application.getName()
                                                    + "\". Client connector for protocol "
                                                    + clientProtocol.getName()
                                                    + " is missing.");
                                    result = false;
                                }
                            }
                        }

                        if (application.getConnectorService()
                                .getServerProtocols() != null) {
                            for (Protocol serverProtocol : application
                                    .getConnectorService().getServerProtocols()) {
                                boolean serverFound = false;

                                // Try to find a server connector matching the
                                // server protocol
                                Server server;
                                for (Iterator<Server> iter = getHelped()
                                        .getServers().iterator(); !serverFound
                                        && iter.hasNext();) {
                                    server = iter.next();
                                    serverFound = server.getProtocols()
                                            .contains(serverProtocol);
                                }

                                if (!serverFound) {
                                    getLogger()
                                            .severe("Unable to start the application \""
                                                    + application.getName()
                                                    + "\". Server connector for protocol "
                                                    + serverProtocol.getName()
                                                    + " is missing.");
                                    result = false;
                                }
                            }
                        }
                    }

                    if (result && application.isStopped()) {
                        application.start();
                    }
                }
            }
        }*/

        return result;
    },

    getClientRouter: function() {
        return this.clientRouter;
    },

    getServerRouter: function() {
        return this.serverRouter;
    },

    setServerRouter: function(serverRouter) {
        this.serverRouter = serverRouter;
    },

    start: function() {
        // Checking if all applications have proper connectors
        var success = this.checkVirtualHost(this.getHelped().getDefaultHost());

        if (success) {
            for (var i=0; i<this.getHelped().getHosts().length; i++) {
            	var host = this.getHelped().getHosts()[i];
                success = success && this.checkVirtualHost(host);
            }
        }

        // Let's actually start the component
        if (!success) {
        	this.getHelped().stop();
        } else {
            var filter = null;

            var services = this.getHelped().getServices();
            for (var i=0; i<services.length; i++) {
            	var service = services[i];
                if (service.isEnabled()) {
                    // Attach the service inbound filters
                    filter = service
                            .createInboundFilter((this.getContext() == null) ? null
                                    : this.getContext().createChildContext());

                    if (filter != null) {
                    	this.addInboundFilter(filter);
                    }

                    // Attach the service outbound filters
                    filter = service
                            .createOutboundFilter((this.getContext() == null) ? null
                                    : this.getContext().createChildContext());

                    if (filter != null) {
                    	this.addOutboundFilter(filter);
                    }
                }
            }

            // Re-attach the original filter's attached Restlet
            this.setInboundNext(this.getServerRouter());
        }
    },

    stop: function() {
        // Stop the server's router
        this.getServerRouter().stop();

        // Stop all applications
        this.stopHostApplications(this.getHelped().getDefaultHost());

        for (var i=0; i<this.getHelped().getHosts().length; i++) {
        	var host = this.getHelped().getHosts()[i];
            this.stopHostApplications(host);
        }
    },

    stopHostApplications: function(host) {
        for (var i=0; i<host.getRoutes().length; i++) {
        	var route = host.getRoutes()[i];
            if (route.getNext().isStarted()) {
                route.getNext().stop();
            }
        }
    },

    update: function() {
        // Note the old router to be able to stop it at the end
        var oldRouter = this.getServerRouter();

        // Set the new server router that will compute the new routes when the
        // first request will be received (automatic start).
        this.setServerRouter(new ServerRouter(this.getHelped()));

        // Replace the old server router
        this.setInboundNext(this.getServerRouter());

        // Stop the old server router
        if (oldRouter != null) {
            oldRouter.stop();
        }
    }
});

var HostRoute = new commons.Class(Route, {
	initialize: function(router, target) {
        this.callSuperCstr(router, target);
    },

    beforeHandle: function(request, response) {
        if (request.getHostRef() == null) {
            request.getResourceRef().setBaseRef(
                    request.getResourceRef().getHostIdentifier());
        } else {
            request.getResourceRef().setBaseRef(request.getHostRef());
        }

        /*if (request.isLoggable() && getLogger().isLoggable(Level.FINE)) {
            getLogger().fine(
                    "Base URI: \"" + request.getResourceRef().getBaseRef()
                            + "\". Remaining part: \""
                            + request.getResourceRef().getRemainingPart()
                            + "\"");
        }*/

        return Filter.CONTINUE;
    },

    getVirtualHost: function() {
        return this.getNext();
    },

    //TODO: use JS regexp
    matches: function(regex, formattedString) {
        /*return Pattern.compile(regex, Pattern.CASE_INSENSITIVE)
                .matcher(formattedString).matches();*/
        return new RegExp(regex).test(formattedString);
    },

    score: function(request, response) {
        var result = 0;

        // Prepare the value to be matched
        var hostDomain = "";
        var hostPort = "";
        var hostScheme = "";

        if (request.getHostRef() != null) {
            hostDomain = request.getHostRef().getHostDomain();

            if (hostDomain == null) {
                hostDomain = "";
            }

            var basePortValue = request.getHostRef().getHostPort();

            if (basePortValue == -1) {
                basePortValue = request.getHostRef().getSchemeProtocol()
                        .getDefaultPort();
            }

            hostPort = basePortValue.toString();

            hostScheme = request.getHostRef().getScheme();

            if (hostScheme == null) {
                hostScheme = "";
            }
        }

        if (request.getResourceRef() != null) {
            var resourceDomain = request.getResourceRef().getHostDomain();

            if (resourceDomain == null) {
                resourceDomain = "";
            }

            var resourcePortValue = request.getResourceRef().getHostPort();

            if (resourcePortValue == -1) {
                resourcePortValue = request.getResourceRef()
                        .getSchemeProtocol().getDefaultPort();
            }

            var resourcePort = resourcePortValue.toString();
            var resourceScheme = request.getResourceRef().getScheme();

            if (resourceScheme == null) {
                resourceScheme = "";
            }

            var serverAddress = response.getServerInfo().getAddress();

            if (serverAddress == null) {
                serverAddress = "";
            }

            var serverPortValue = response.getServerInfo().getPort();

            if (serverPortValue == -1) {
                serverPortValue = request.getProtocol().getDefaultPort();
            }

            var serverPort = response.getServerInfo()
                    .getPort().toString();

            // Check if all the criteria match
            if (this.matches(this.getVirtualHost().getHostDomain(), hostDomain)
                    && this.matches(this.getVirtualHost().getHostPort(), hostPort)
                    && this.matches(this.getVirtualHost().getHostScheme(), hostScheme)
                    && this.matches(this.getVirtualHost().getResourceDomain(),
                            resourceDomain)
                    && this.matches(this.getVirtualHost().getResourcePort(), resourcePort)
                    && this.matches(this.getVirtualHost().getResourceScheme(),
                            resourceScheme)
                    && this.matches(this.getVirtualHost().getServerAddress(),
                            serverAddress)
                    && this.matches(this.getVirtualHost().getServerPort(), serverPort)) {
                result = 1;
            }
        }

        // Log the result of the matching
        /*if (getLogger().isLoggable(Level.FINER)) {
            getLogger().finer(
                    "Call score for the \"" + getVirtualHost().getName()
                            + "\" host: " + result);
        }*/

        return result;
    },

    setNext: function(next) {
        this.callSuper("setNext", next);
    }
});

var InternalRouter = new commons.Class(Router, {
    initialize: function(context) {
        this.callSuperCstr(context);
        // Override Router's default modes
        this.setDefaultMatchingMode(Template.MODE_STARTS_WITH);
        this.setRoutingMode(Router.MODE_BEST_MATCH);
    },

    createRoute: function(uriPattern, target, matchingMode) {
        var result = new TemplateRoute(this, uriPattern, target);
        result.beforeHandle = function(request, response) {
            var result = this.callSuper("beforeHandle", request, response);

            // Set the request's root reference in order to help the
            // retrieval of the relative reference.
            request.setRootRef(request.getResourceRef().getBaseRef());

            return result;
        };

        result.getTemplate().setMatchingMode(matchingMode);
        result.setMatchingQuery(getDefaultMatchingQuery());
        return result;
    },

    attach: function() {
    	var target = null;
    	var uriPattern = null;
    	if (arguments.length==1) {
    		target = arguments[0];
    	} else if (arguments.length==2) {
    		uriPattern = arguments[0];
    		target = arguments[1];
    	}
        if (target.getContext() == null) {
            target.setContext(getContext().createChildContext());
        }

        return this.callSuper("attach", uriPattern, target);
    },

    attachDefault: function(defaultTarget) {
        if (defaultTarget.getContext() == null) {
            defaultTarget.setContext(getContext().createChildContext());
        }

        return this.callSuper("attachDefault", defaultTarget);
    }

    /*public Finder createFinder(Class<? extends ServerResource> targetClass) {
        Finder result = super.createFinder(targetClass);
        result.setContext(getContext().createChildContext());
        return result;
    }*/
});

var ServerRouter = new commons.Class(Router, {
    initialize: function(component) {
        this.callSuperCstr((component == null) ? null : component.getContext()
                .createChildContext());
        this.component = component;
        this.setRoutingMode(Router.MODE_FIRST_MATCH);
    },

    getComponent: function() {
        return this.component;
    },

    logRoute: function(route) {
        if (getLogger().isLoggable(Level.FINE)) {
            if (route instanceof HostRoute) {
                var vhost = route.getVirtualHost();

                if (getComponent().getDefaultHost() == vhost) {
                    getLogger().fine("Default virtual host selected");
                } else {
                    getLogger().fine(
                            "Virtual host selected: \"" + vhost.getHostScheme()
                                    + "\", \"" + vhost.getHostDomain()
                                    + "\", \"" + vhost.getHostPort() + "\"");
                }
            } else {
                this.callSuper("logRoute", route);
            }
        }
    },

    /** Starts the Restlet. */
    start: function() {
        // Attach all virtual hosts
    	var hosts = this.getComponent().getHosts();
        for (var i=0; i<hosts.length; i++) {
        	var host = hosts[i];
            this.getRoutes().add(new HostRoute(this, host));
        }

        // Also attach the default host if it exists
        if (this.getComponent().getDefaultHost() != null) {
            this.getRoutes().push(
                    new HostRoute(this, this.getComponent().getDefaultHost()));
        }

        // If no host matches, display and error page with a precise message
        var noHostMatched = new Restlet(this.getComponent().getContext()
                .createChildContext());
        noHostMatched.handle = function(request, response) {
            response.setStatus(data.Status.CLIENT_ERROR_NOT_FOUND,
                    "No virtual host could handle the request");
        };

        this.setDefaultRoute(new TemplateRoute(this, "",
                noHostMatched));

        // Start the router
        this.callSuper("start");
    },

    stop: function() {
        this.getRoutes().clear();
        this.callSuper("stop");
    }
});

var ServerCall = new commons.Class(Call, {
    initialize: function(server) {
    	this.callSuperCstr();
    	var serverAddress = null;
    	var serverPort = -1;
    	if (arguments.length==1) {
        	serverAddress = server.getAddress();
        	serverPort = server.getPort();
    	} else if (arguments.length==2) {
        	serverAddress = arguments[0];
        	serverPort = arguments[1];
    	}

        this.setServerAddress(serverAddress);
        this.setServerPort(serverPort);
        this.hostParsed = false;
    },

    abort: function() {
    	
    },

    complete: function() {

    },

    /*public List<Certificate> getCertificates() {
        return null;
    }

    public String getCipherSuite() {
        return null;
    }*/

    getContentLength: function() {
        return HeaderUtils.getContentLength(this.getRequestHeaders());
    },

    getHostDomain: function() {
        if (this.hostParsed==null || !this.hostParsed) {
            this.parseHost();
        }
        //return this.callSuper("getHostDomain");
        return this.hostDomain;
    },

    getHostPort: function() {
        if (this.hostParsed==null || !this.hostParsed) {
            this.parseHost();
        }
        //return this.callSuper("getHostPort");
        return this.hostPort;
    },

    getRequestEntity: function() {
        var result = null;
        var contentLength = this.getContentLength();
        var chunkedEncoding = HeaderUtils
                .isChunkedEncoding(this.getRequestHeaders());
        // In some cases there is an entity without a content-length header
        var connectionClosed = HeaderUtils
                .isConnectionClose(this.getRequestHeaders());

        // Create the representation
        /*if (((contentLength != representation.Representation.UNKNOWN_SIZE) && (contentLength != 0))
                || chunkedEncoding || connectionClosed) {
            // Create the result representation
            InputStream requestStream = getRequestEntityStream(contentLength);

            if (connectionClosed) {
                // We need to detect if there is really an entity or not as only
                // the end of connection can let us know at this point
                PushbackInputStream pbi = new PushbackInputStream(requestStream);

                try {
                    int next = pbi.read();

                    if (next != -1) {
                        pbi.unread(next);
                        requestStream = pbi;
                    } else {
                        requestStream = null;
                    }
                } catch (IOException e) {
                    getLogger().fine("Unable to read request entity");
                }
            }

            if (requestStream != null) {
                result = new InputRepresentation(requestStream, null,
                        contentLength);
            } else {
                result = new EmptyRepresentation();
            }

            result.setSize(contentLength);
        } else {
            result = new EmptyRepresentation();
        }*/

        // Extract some interesting header values
        for (var i=0; i<this.getRequestHeaders().length; i++) {
        	var header = this.getRequestHeaders()[i];
            if (header.getName().equalsIgnoreCase(
                    HeaderConstants.HEADER_CONTENT_ENCODING)) {
                new EncodingReader(header.getValue()).addValues(result
                        .getEncodings());
            } else if (header.getName().equalsIgnoreCase(
            		HeaderConstants.HEADER_CONTENT_LANGUAGE)) {
                new LanguageReader(header.getValue()).addValues(result
                        .getLanguages());
            } else if (header.getName().equalsIgnoreCase(
            		HeaderConstants.HEADER_CONTENT_TYPE)) {
                var contentType = new ContentType(header.getValue());
                result.setMediaType(contentType.getMediaType());
                result.setCharacterSet(contentType.getCharacterSet());
            } else if (header.getName().equalsIgnoreCase(
            		HeaderConstants.HEADER_CONTENT_RANGE)) {
            	RangeReader.update(header.getValue(), result);
            } else if (header.getName().equalsIgnoreCase(
            		HeaderConstants.HEADER_CONTENT_MD5)) {
                /*result.setDigest(new Digest(Digest.ALGORITHM_MD5, Base64
                        .decode(header.getValue())));*/
            } else if (header.getName().equalsIgnoreCase(
            		HeaderConstants.HEADER_CONTENT_DISPOSITION)) {
                try {
                    result.setDisposition(new DispositionReader(header
                            .getValue()).readValue());
                } catch (err) {
                    Context.getCurrentLogger().log(
                            Level.WARNING,
                            "Error during Content-Disposition header parsing. Header: "
                                    + header.getValue(), err);
                }
            }
        }

        return result;
    },

    /*public Integer getSslKeySize() {
        return null;
    }

    public String getSslSessionId() {
        byte[] byteArray = getSslSessionIdBytes();

        if (byteArray != null) {
            return BioUtils.toHexString(byteArray);
        } else {
            return null;
        }
    }

    protected byte[] getSslSessionIdBytes() {
        return null;
    }*/

    isClientKeepAlive: function() {
        return !HeaderUtils.isConnectionClose(this.getRequestHeaders());
    },

    isServerKeepAlive: function() {
        return true;
    },

    parseHost: function() {
        var host = this.getRequestHeaders().getFirstValue(
                HeaderConstants.HEADER_HOST, true);

        if (host != null) {
            var colonIndex = host.indexOf(':');

            if (colonIndex != -1) {
                this.setHostDomain(host.substring(0, colonIndex));
                this.setHostPort(parseInt(host
                        .substring(colonIndex + 1)));
            } else {
                this.setHostDomain(host);
                this.setHostPort(getProtocol().getDefaultPort());
            }
        } else {
            /*getLogger().info(
                    "Couldn't find the mandatory \"Host\" HTTP header.");*/
        }

        this.hostParsed = true;
    },

    sendResponse: function(response) {
        if (response != null) {
            // Get the connector service to callback
            var responseEntity = response.getEntity();
            /*ConnectorService connectorService = ConnectorHelper
                    .getConnectorService();

            if (connectorService != null) {
                connectorService.beforeSend(responseEntity);
            }*/

            try {
                this.writeResponseHead(response);

                if (responseEntity != null) {
                    this.writeResponseBody(responseEntity);

                    /*if (responseEntityStream != null) {
                        try {
                            responseEntityStream.flush();
                            responseEntityStream.close();
                        } catch (IOException ioe) {
                            // The stream was probably already closed by the
                            // connector. Probably OK, low message priority.
                            getLogger()
                                    .log(Level.FINE,
                                            "Exception while flushing and closing the entity stream.",
                                            ioe);
                        }
                    }*/
                }
            } catch(err) {
            	console.log(err.stack);
            } finally {
                if (responseEntity != null) {
                    responseEntity.release();
                }

                /*if (connectorService != null) {
                    connectorService.afterSend(responseEntity);
                }*/
            }
        	this.endResponse();
        }
    },

    shouldResponseBeChunked: function(response) {
        return (response.getEntity() != null)
                && !response.getEntity().hasKnownSize();
    },

    writeResponseBody: function(responseEntity) {
        // Send the entity to the client
        /*if (responseEntityStream != null) {
            entity.write(responseEntityStream);
            responseEntityStream.flush();
        }*/
    	this.writeData(responseEntity.getText());
    },

    writeResponseHead: function(response) {
        // We don't support persistent connections yet
        this.getResponseHeaders().set(HeaderConstants.HEADER_CONNECTION, "close",
                true);

        // Check if 'Transfer-Encoding' header should be set
        if (this.shouldResponseBeChunked(response)) {
            this.getResponseHeaders().add(HeaderConstants.HEADER_TRANSFER_ENCODING,
                    "chunked");
        }

        // Write the response headers
        for (var i=0; i<this.getResponseHeaders().size(); i++) {
        	var header = this.getResponseHeaders().get(i);
        	this.response.setHeader(header.name, header.value);
        }

    	var reasonPhrase = null;
        if (this.getReasonPhrase() != null) {
        	reasonPhrase = StringUtils.getLatin1Bytes(this.getReasonPhrase());
        } else {
        	reasonPhrase = StringUtils
                    .getAsciiBytes(("Status " + this.getStatusCode()));
        }
        this.response.writeHead(StringUtils.getAsciiBytes(
                this.getStatusCode()), reasonPhrase);
    }
});


var NodeJsHttpServerCall = new commons.Class(ServerCall, {
	initialize: function(server, request, response, confidential) {
    	this.callSuperCstr(server);
		this.server = server;
		this.request = request;
		this.response = response;
		this.requestHeadersAdded = false;
		
		this.parseRequestHeaders();
	},

	parseRequestHeaders: function() {
		var nodeHeaders = this.request.headers;
		var headers = this.getRequestHeaders();
		for (var elt in nodeHeaders) {
			headers.add(elt, nodeHeaders[elt]);
		}
	},
	
	getMethod: function() {
		return this.request.method;
	},
	
	getRequestUri: function() {
		return this.request.url;
	},
	
	/*handleRequest: function(request, response) {
        this.getHelper().handle(
                new SimpleCall(getHelper().getHelped(), request, response,
                        this.getHelper().isConfidential()));

            response.close();
	}*/
	
	writeData: function(data) {
		this.response.write(data);
	},
	
	endResponse: function() {
		this.response.end();
	}
});

var ServerAdapter = new commons.Class(Adapter, {
    initialize: function(context) {
        this.callSuperCstr(context);
    },

    addEntityHeaders: function(response) {
        var responseHeaders = response.getHttpCall()
                .getResponseHeaders();
        var entity = response.getEntity();
        HeaderUtils.addEntityHeaders(entity, responseHeaders);
    },

    addResponseHeaders: function(response) {
        try {
            // Add all the necessary headers
            HeaderUtils.addGeneralHeaders(response, response.getHttpCall()
                    .getResponseHeaders());
            HeaderUtils.addResponseHeaders(response, response.getHttpCall()
                    .getResponseHeaders());

            // Set the status code in the response
            if (response.getStatus() != null) {
                response.getHttpCall().setStatusCode(
                        response.getStatus().getCode());
                response.getHttpCall().setReasonPhrase(
                        response.getStatus().getReasonPhrase());
            }
        } catch (err) {
        	console.log(err.stack);
            this.getLogger().log(Level.INFO,
                    "Exception intercepted while adding the response headers",
                    err);
            response.getHttpCall().setStatusCode(
                    data.Status.SERVER_ERROR_INTERNAL.getCode());
            response.getHttpCall().setReasonPhrase(
                    data.Status.SERVER_ERROR_INTERNAL.getReasonPhrase());
        }
    },

    commit: function(response) {
        try {
            if ((response.getRequest().getMethod() != null)
                    && response.getRequest().getMethod().equals(data.Method.HEAD)) {
                this.addEntityHeaders(response);
                response.setEntity(null);
            } else if (data.Method.GET.equals(response.getRequest().getMethod())
                    && data.Status.SUCCESS_OK.equals(response.getStatus())
                    && (!response.isEntityAvailable())) {
                this.addEntityHeaders(response);
                this.getLogger()
                        .warning(
                                "A response with a 200 (Ok) status should have an entity. Make sure that resource \""
                                        + response.getRequest()
                                                .getResourceRef()
                                        + "\" returns one or sets the status to 204 (No content).");
            } else if (response.getStatus().equals(data.Status.SUCCESS_NO_CONTENT)) {
                this.addEntityHeaders(response);

                if (response.isEntityAvailable()) {
                    this.getLogger()
                            .fine("Responses with a 204 (No content) status generally don't have an entity. Only adding entity headers for resource \""
                                    + response.getRequest().getResourceRef()
                                    + "\".");
                    response.setEntity(null);
                }
            } else if (response.getStatus()
                    .equals(data.Status.SUCCESS_RESET_CONTENT)) {
                if (response.isEntityAvailable()) {
                    this.getLogger()
                            .warning(
                                    "Responses with a 205 (Reset content) status can't have an entity. Ignoring the entity for resource \""
                                            + response.getRequest()
                                                    .getResourceRef() + "\".");
                    response.setEntity(null);
                }
            } else if (response.getStatus().equals(
                    data.Status.REDIRECTION_NOT_MODIFIED)) {
                if (response.getEntity() != null) {
                    HeaderUtils.addNotModifiedEntityHeaders(response
                            .getEntity(), response.getHttpCall()
                            .getResponseHeaders());
                    response.setEntity(null);
                }
            } else if (response.getStatus().isInformational()) {
                if (response.isEntityAvailable()) {
                    this.getLogger()
                            .warning(
                                    "Responses with an informational (1xx) status can't have an entity. Ignoring the entity for resource \""
                                            + response.getRequest()
                                                    .getResourceRef() + "\".");
                    response.setEntity(null);
                }
            } else {
                this.addEntityHeaders(response);

                if (!response.isEntityAvailable()) {
                    if ((response.getEntity() != null)
                            && (response.getEntity().getSize() != 0)) {
                        this.getLogger()
                                .warning(
                                        "A response with an unavailable and potentially non empty entity was returned. Ignoring the entity for resource \""
                                                + response.getRequest()
                                                        .getResourceRef()
                                                + "\".");
                    }

                    response.setEntity(null);
                }
            }

            // Add the response headers
            this.addResponseHeaders(response);

            // Send the response to the client
            response.getHttpCall().sendResponse(response);
        } catch (err) {
        	console.log(err.stack);
            /*if (response.getHttpCall().isConnectionBroken(t)) {
                getLogger()
                        .log(Level.INFO,
                                "The connection was broken. It was probably closed by the client.",
                                t);
            } else
            {
                getLogger().log(Level.SEVERE,
                        "An exception occured writing the response entity", t);
                response.getHttpCall().setStatusCode(
                        Status.SERVER_ERROR_INTERNAL.getCode());
                response.getHttpCall().setReasonPhrase(
                        "An exception occured writing the response entity");
                response.setEntity(null);

                try {
                    response.getHttpCall().sendResponse(response);
                } catch (IOException ioe) {
                    getLogger().log(Level.WARNING,
                            "Unable to send error response", ioe);
                }
            }*/
        } finally {
            response.getHttpCall().complete();

            /*if (response.getOnSent() != null) {
                response.getOnSent().handle(response.getRequest(), response);
            }*/
        }
    },

    toRequest: function(httpCall) {
        var result = new HttpRequest(this.getContext(), httpCall);
        result.getAttributes()[HeaderConstants.ATTRIBUTE_HEADERS] =
                httpCall.getRequestHeaders();

        if (httpCall.getVersion() != null) {
            result.getAttributes()[HeaderConstants.ATTRIBUTE_VERSION] =
                    httpCall.getVersion();
        }

        /*if (httpCall.isConfidential()) {
            List<Certificate> clientCertificates = httpCall.getCertificates();

            if (clientCertificates != null) {
                result.getAttributes().put(
                        HeaderConstants.ATTRIBUTE_HTTPS_CLIENT_CERTIFICATES,
                        clientCertificates);
                result.getClientInfo().setCertificates(clientCertificates);
            }

            String cipherSuite = httpCall.getCipherSuite();

            if (cipherSuite != null) {
                result.getAttributes().put(
                        HeaderConstants.ATTRIBUTE_HTTPS_CIPHER_SUITE,
                        cipherSuite);
                result.getClientInfo().setCipherSuite(cipherSuite);
            }

            Integer keySize = httpCall.getSslKeySize();

            if (keySize != null) {
                result.getAttributes().put(
                        HeaderConstants.ATTRIBUTE_HTTPS_KEY_SIZE, keySize);
            }

            String sslSessionId = httpCall.getSslSessionId();

            if (sslSessionId != null) {
                result.getAttributes().put(
                        HeaderConstants.ATTRIBUTE_HTTPS_SSL_SESSION_ID,
                        sslSessionId);
            }
        }*/

        return result;
    },
});


var HttpServerHelper = new commons.Class(ServerHelper, {
	initialize: function(server) {
		this.callSuperCstr(server);
        this.adapter = null;
	},

    getAdapter: function() {
    	if (this.adapter==null) {
    		/*
                final String adapterClass = getHelpedParameters()
                        .getFirstValue("adapter",
                                "org.restlet.engine.adapter.ServerAdapter");
                this.adapter = (ServerAdapter) Engine.loadClass(adapterClass)
                        .getConstructor(Context.class)
                        .newInstance(getContext());
    		 */
    		this.adapter = new ServerAdapter(this.getContext());
    	}
		return this.adapter;
	},
	
	setAdapter: function(adapter) {
		this.adapter = adapter;
	},
	
	handle: function(httpCall) {
		try {
			var request = this.getAdapter().toRequest(httpCall);
			var response = new HttpResponse(httpCall, request);
			var currentThis = this;
			response.setCommitCallback(function() {
				currentThis.getAdapter().commit(response);
			});
			this.callSuper("handle", request, response);
			/*if (response.getStatus()!=data.Status.SUCCESS_OK) {
				response.commit();
			}*/
		} catch (err) {
                this.getLogger().log(Level.WARNING,
                        "Error while handling an HTTP server call: ",
                        err.message);
                this.getLogger().log(Level.INFO,
                        "Error while handling an HTTP server call", err);
		}
	}
});

var NodeJsHttpServerHelper = new commons.Class(HttpServerHelper, {
	initialize: function(server, protocol) {
		this.callSuperCstr(server);
		this.confidential = false;
        this.getProtocols().add(data.Protocol.HTTP);
    },

    isConfidential: function() {
    	return this.confidential;
    },
    
    setConfidential: function() {
    	this.confidential = confidential;
    },
    
	start: function() {
        var addr = "127.0.0.1";
        if (this.getHelped().getAddress()!=null) {
        	addr = this.getHelped().getAddress();
        }
        var port = this.getHelped().getPort();

        var currentThis = this;
        this.internalServer = http.createServer(function (request, response) {
        	currentThis.getLogger().info("-> incoming request : "+request.url);
        	currentThis.handle(
                    new NodeJsHttpServerCall(currentThis.getHelped(), request, response,
                            currentThis.isConfidential()));
        }).listen(port, addr);
        console.log("Server running at http://"+addr+":"+port+"/");

        //setConfidential(false);

        this.callSuper("start");
	},

	stop: function() {
		if (this.internalServer!=null) {
			this.internalServer.close();
		}
	}
});

//Engine

var Engine = new commons.Class({
	initialize: function() {
        this.registeredClients = new util.ClientList();
         this.registeredClients.push(NodeJsHttpClientHelper);

        //this.registeredProtocols = [];
         this.registeredServers = new util.ServerList();
         this.registeredServers.push(NodeJsHttpServerHelper);
        //this.registeredAuthenticators = [];
        //this.registeredConverters = [];
	},

	createHelper: function(restlet) {
		//TODO: fix me
		//return new this.registeredClients[0]();
		//return new this.registeredClients[0]();
		 if (restlet instanceof Client) {
		 	return new this.registeredClients[0](restlet);
		 } else if (restlet instanceof Server) {
		 	return new this.registeredServers[0](restlet);
		 }
	},
	
	/*
    public ConnectorHelper<org.restlet.Server> createHelper(
            org.restlet.Server server, String helperClass) {
        ConnectorHelper<org.restlet.Server> result = null;

        if (server.getProtocols().size() > 0) {
            ConnectorHelper<org.restlet.Server> connector = null;
            for (final Iterator<ConnectorHelper<org.restlet.Server>> iter = getRegisteredServers()
                    .iterator(); (result == null) && iter.hasNext();) {
                connector = iter.next();

                if ((helperClass == null)
                        || connector.getClass().getCanonicalName()
                                .equals(helperClass)) {
                    if (connector.getProtocols().containsAll(
                            server.getProtocols())) {
                        try {
                            result = connector.getClass()
                                    .getConstructor(org.restlet.Server.class)
                                    .newInstance(server);
                        } catch (Exception e) {
                            Context.getCurrentLogger()
                                    .log(Level.SEVERE,
                                            "Exception while instantiation the server connector.",
                                            e);
                        }
                    }
                }
            }

            if (result == null) {
                // Couldn't find a matching connector
                final StringBuilder sb = new StringBuilder();
                sb.append("No available server connector supports the required protocols: ");

                for (final Protocol p : server.getProtocols()) {
                    sb.append("'").append(p.getName()).append("' ");
                }

                sb.append(". Please add the JAR of a matching connector to your classpath.");

                if (Edition.CURRENT == Edition.ANDROID) {
                    sb.append(" Then, register this connector helper manually.");
                }

                Context.getCurrentLogger().log(Level.WARNING, sb.toString());
            }
        }

        return result;
    }

	 */

	getRegisteredClients: function() {
		return this.registeredClients;
	},
	
	setRegisteredClients: function(registeredClients) {
		this.registeredClients = registeredClients;
	},
	
	getRegisteredServers: function() {
		return this.registeredServers;
	},
	
	setRegisteredServers: function(registeredServers) {
		this.registeredServers = registeredServers;
	},
	
	getDebugHandler: function() {
		return this.debugHandler;
	},

	setDebugHandler: function(debugHandler) {
		this.debugHandler = debugHandler;
	},
	
	enableDebug: function() {
		this.debugHandler = {
			beforeSendingRequest: function(url, method, headers, data) {
				console.log(method+" "+url);
				for (var elt in headers) {
					console.log(elt+": "+headers[elt]);
				}
				console.log("");
				console.log(data);
			},
			afterReceivedResponse: function(status, statusCode, headers, data) {
				console.log(status+" "+statusCode);
				for (var elt in headers) {
					console.log(elt+": "+headers[elt]);
				}
				console.log("");
				console.log(data);
			}
		};
	},

	disableDebug: function() {
		this.debugHandler = null;
	}
});

Engine.extend({
    /*MAJOR_NUMBER: "@major-number@",
    MINOR_NUMBER: "@minor-number@",
    RELEASE_NUMBER: "@release-type@@release-number@",*/
    MAJOR_NUMBER: "2.1",
    MINOR_NUMBER: "2.0",
    RELEASE_NUMBER: "2.1/nodejs",
	getInstance: function() {
		if (Engine.instance==null) {
			Engine.instance = new Engine();
		}
		return Engine.instance;
	},
	getLogger: function(loggerName) {
		return new Logger(loggerName);
	}
});

Engine.VERSION = Engine.MAJOR_NUMBER + '.' + Engine.MINOR_NUMBER + Engine.RELEASE_NUMBER;
Engine.VERSION_HEADER = "Restlet-Framework/" + Engine.VERSION;


module.exports["Restlet"] = Restlet;
module.exports["Filter"] = Filter;
module.exports["Context"] = Context;
module.exports["Logger"] = Logger;
module.exports["Message"] = Message;
module.exports["Request"] = Request;
module.exports["Response"] = Response;
module.exports["Connector"] = Connector;
module.exports["Client"] = Client;
module.exports["Server"] = Server;
module.exports["Application"] = Application;
module.exports["Component"] = Component;
module.exports["Engine"] = Engine;
module.exports["Router"] = Router;
module.exports["MetadataService"] = MetadataService;
module.exports["StatusService"] = StatusService;
module.exports["ConverterService"] = ConverterService;
module.exports["ConnegService"] = ConnegService;